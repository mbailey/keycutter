#!/usr/bin/env bash
# set -eu -o pipefail

# [preview] keycutter - Create FIDO SSH keys for authentication and commit signing.

# KEYCUTTER_ROOT="$(readlink -f "$(dirname -- "${BASH_SOURCE[0]:-${0:A}}")/../")"
SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]:-${0:A}}")")" && pwd)"
KEYCUTTER_ROOT="$(cd -- "$SCRIPT_DIR/../" && pwd)"
source "${KEYCUTTER_ROOT}/lib/functions"

# Skip stdin reattachment in test mode
[ -n "${KEYCUTTER_TEST_MODE:-}" ] || { [ -t 0 ] || exec </dev/tty; } # reattach keyboard to STDIN

# If run on ORIGIN (not connected by SSH), default KEYCUTTER_ORIGIN to local hostname.
# Track whether KEYCUTTER_ORIGIN was explicitly set
KEYCUTTER_ORIGIN_EXPLICIT=${KEYCUTTER_ORIGIN:+true}
[[ -z $SSH_CONNECTION ]] && : ${KEYCUTTER_ORIGIN:="$(hostname -s)"}

# Set any undefined environment variables to default values
: ${KEYCUTTER_CONFIG:="${HOME}/.ssh/keycutter/keycutter.conf"}
: ${KEYCUTTER_CONFIG_DIR:="$(dirname "${KEYCUTTER_CONFIG}")"}
: ${KEYCUTTER_SSH_KEY_DIR:="${KEYCUTTER_CONFIG_DIR}/keys"}

: ${KEYCUTTER_SSH_KEY_TYPE_SK:="ed25519-sk"} # was ecdsa-sk
: ${KEYCUTTER_SSH_KEY_TYPE_NON_SK:="ed25519"}
: ${KEYCUTTER_SSH_KEY_TYPES:="ecdsa-sk ed25519-sk rsa ecdsa ed25519"}

# Prerequisites:
#
# - Bash >= 4.0
# - Git >= 2.34.0 # XXX Still needed?
# - GitHub CLI >= 2.0 (Greater than 2.4.0+dfsg1-2 on Ubuntu)
# - OpenSSH >= 8.2p1
# - YubiKey Manager
#
# WSL (Windows Subsystem for Linux) Setup:
#
#   WSL does not support USB devices natively, so we need to use Windows OpenSSH to access the YubiKey.
#   This requires a recent version of OpenSSH for Windows and a helper program to access the YubiKey.
#
#   Download and install a recent version of OpenSSH for Windows. This will give you 'ssh-sk-helper.exe'
#   1. Download and install a recent OpenSSH for Windows:
#        OpenSSH for Windows: https://github.com/PowerShell/Win32-OpenSSH/releases
#   2. Tell WSL OpenSSH to ask Windows for help:
#
#        echo 'export SSH_SK_HELPER="/mnt/c/Program Files/OpenSSH/ssh-sk-helper.exe"' >> ~/.bashrc
#
# Recommendations:
#
#   1. Use separate Github account per security domain (personal, work, public).
#      This will give you more freedom to login to GitHub on a device you trust
#      with that account without crossing security boundaries.
#
#   2. Only use GitHub CLI from a device you trust with that GitHub account.
#      E.g. Don't login to your personal GitHub account from a managed laptop.
#

usage() {
  echo "Usage:"
  echo "       $(basename "$0") <command> [arguments]"
  echo
  echo "Commands:"
  echo "       create <ssh-keytag> [--resident] [--type <value>] Create a new SSH key"
  echo "       check-requirements                                Check if all required software is installed"
  echo "       authorized-keys <hostname>                        Show public keys that would be offered to host"
  echo "       push-keys <hostname>                             Push public keys to remote host"
  echo "       update                                            Update all: git, config, requirements, touch-detector"
  echo "       update git                                        Pull latest changes from git repository"
  echo "       update config                                     Update SSH config files from current installation"
  echo "       update requirements                               Check and update system requirements"
  echo "       update touch-detector                             Update YubiKey touch notification tool"
  echo "       install-touch-detector                            Install YubiKey touch notification tool"
  echo "       config <hostname>                                 Show config relevant to host"
  echo "       agents                                            List all agents"
  echo "       hosts                                             List all hosts"
  echo "       hosts edit <filename>                             Edit host configuration file"
  echo "       keys                                              List all keys"
  echo
  echo "Git commit signing:"
  echo "       git-signing enable [--global] [key-path]          Enable SSH commit signing with auto-detected key"
  echo "       git-signing disable [--global]                    Disable SSH commit signing"
  echo "       git-signing status                                Show current signing configuration"
  echo
  echo "SSH known_hosts management:"
  echo "       ssh-known-hosts delete-line <line_number>         Delete a specific line from known_hosts"
  echo "       ssh-known-hosts remove <hostname>                 Remove all entries for a host"
  echo "       ssh-known-hosts fix <hostname>                    Interactively fix entries for a host"
  echo "       ssh-known-hosts backup                            Create a backup of known_hosts"
  echo "       ssh-known-hosts list-backups                      List available backups"
  echo "       ssh-known-hosts restore <backup_file>             Restore from a backup"
  echo
  echo "GPG key management:"
  echo "       gpg key list [--all]                              List GPG keys on YubiKey and masters"
  echo "       gpg key create [--yes]                            Create master key + subkeys"
  echo "       gpg key install [--master KEY_ID]                 Install subkeys to YubiKey"
  echo "       gpg setup                                         Configure host for GPG/YubiKey"
  echo "       gpg backup                                        Backup master key to encrypted storage"
  echo
  echo "Agent commands:"
  echo "       agent show <agent>                                Show agent details"
  echo "       agent keys <agent>                                List keys in agent"
  echo "       agent hosts <agent>                               List hosts using agent"
  echo "       agent add-key <agent> <key>                       Add key to agent"
  echo "       agent remove-key <agent> <key>                    Remove key from agent"
  echo
  echo "Host commands:"
  echo "       host show <host>                                  Show host config"
  echo "       host agent <host> [agent]                         Get/set agent for host"
  echo "       host keys <host>                                  List keys for host"
  echo "       host config <host>                                Show SSH config for host"
  echo "       host edit <host>                                  Edit the file containing host"
  echo
  echo "Key commands:"
  echo "       key show <key>                                    Show key details"
  echo "       key agents <key>                                  List agents containing key"
  echo "       key hosts <key>                                   List hosts using key"
  echo
  echo "For create command:"
  echo "  ssh-keytag Required. Identifier for key (e.g. github.com_alex@laptop-personal)"
  echo "  --resident Optional. Create resident FIDO SSH key (default is non-resident)"
  echo "  --type     Optional. Which cryptographic key to use (ecdsa-sk, ed25519-sk, rsa, ecdsa, ed25519)"
  echo "                       Default is ed25519-sk"
  echo
  echo "For config command:"
  echo "  hostname   Required. The SSH hostname to analyze (e.g. github.com, server.example.com)"
  echo
  echo "SSH Keytag format: service_user@device"
  echo "  - service : Service this key is used with (e.g. 'github.com', 'aws', 'digitalocean')"
  echo "  - user    : Service User this SSH Key authenticates as (e.g. 'alex')"
  echo "  - device  : Device this ssh key resides on (e.g. 'yubikey1', 'work-laptop', 'zfold5')"
}

keycutter-create() {

  if [[ $# -lt 1 ]]; then
    usage
    exit 1
  fi

  # Set default values, override with command line options
  local ssh_key_resident=""
  local ssh_key_type="$KEYCUTTER_SSH_KEY_TYPE_SK"
  local ssh_keytag=""

  local KEYCUTTER_CONFIG_DIR="$(dirname "${KEYCUTTER_CONFIG}")"

  while (("$#")); do
    case "$1" in
    --resident)
      ssh_key_resident="yes"
      shift
      ;;
    --type)
      ssh_key_type="$2"
      shift 2
      ;;
    -h | --help)
      usage
      exit 0
      ;;
    *)
      if [[ -z $ssh_keytag ]]; then
        ssh_keytag="$1"
      else
        log "Error: Invalid option $1"
        usage
        exit 1
      fi
      shift
      ;;
    esac
  done

  if [[ -z "$ssh_keytag" ]]; then
    usage
    exit 1
  fi

  # Check if the ssh_keytag ends with @$KEYCUTTER_ORIGIN
  if [[ ! "$ssh_keytag" =~ @${KEYCUTTER_ORIGIN}$ ]]; then
    local ssh_keytag_proposed="${ssh_keytag/@*/}@${KEYCUTTER_ORIGIN}"
    log "Info: Using the SSH Keytag convention allows the magic to happen"
    if [[ -z $KEYCUTTER_ORIGIN_EXPLICIT ]]; then
      log "Tip: Use an alias instead of hostname by setting KEYCUTTER_ORIGIN env var."
    fi
    log "See also: https://github.com/mbailey/keycutter/blob/master/docs/ssh-keytags.md"
    log ""
    prompt "Append the current device to the SSH Keytag? (${ssh_keytag_proposed}). (Y/n) "
    read -n 1 -r
    echo
    if [[ $REPLY =~ ^[Nn]$ ]]; then
      log "Proceeding with original ssh_keytag: $ssh_keytag"
    else
      ssh_keytag="${ssh_keytag_proposed}"
      log "Updated ssh_keytag to: $ssh_keytag"
    fi
  fi

  local ssh_key_path="${KEYCUTTER_CONFIG_DIR}/keys/${ssh_keytag}" # Path SSH key will be written to

  # Ensure config dirs exists wth correct perms
  dir-ensure "$KEYCUTTER_CONFIG_DIR" 0700
  dir-ensure "$(dirname "$ssh_key_path")" 0700

  # Create SSH Key for $ssh_keytag
  log "Generating SSH key: $ssh_key_path"
  case "$ssh_key_type" in
  ecdsa-sk | ed25519-sk)
    ssh-keygen -t "$ssh_key_type" -f "$ssh_key_path" -C "$ssh_keytag" ${ssh_key_resident:+-O resident}
    ;;
  rsa)
    ssh-keygen -t "$ssh_key_type" -b 4096 -f "$ssh_key_path" -C "$ssh_keytag"
    ;;
  ecdsa | ed25519)
    ssh-keygen -t "$ssh_key_type" -f "$ssh_key_path" -C "$ssh_keytag"
    ;;
  *)
    log "Error: Unsupported key type: $ssh_key_type"
    return 1
    ;;
  esac
  local case_exit_code=$?
  if [[ case_exit_code -ne 0 ]]; then
    log "WARNING No key was created"
    return $case_exit_code
  fi

  chmod 0600 "${ssh_key_path}.pub"

  # If the SSH Keytag includes github.com
  local service="$(_ssh-keytag-service "$ssh_keytag")"
  if [[ $service =~ github.com ]]; then
    # Optionally add SSH key to GitHub for auth and commit/tag signing: $ssh_key_path
    github-ssh-key-add "$ssh_key_path" "$ssh_keytag"
    local demo_message="\nYou can SSH to GitHub by running:\n\n ssh -T $(_ssh-keytag-service-identity "$ssh_key_path")\n"
    # Option to access GitHub when firewall blocks outbound port 22
    prompt "Symlink key to enable ssh.github.com:443? [Y/n] "
    read -n 1 -r
    echo
    if ! [[ $REPLY =~ ^[Nn]$ ]]; then
      log "Creating symlink: ln -sf $ssh_key_path ${ssh_key_path/github.com/ssh.github.com}"
      ln -sf "$ssh_key_path" "${ssh_key_path/github.com/ssh.github.com}"
    fi
  elif [[ $service =~ (git\.)?sr\.ht ]]; then
    # Optionally add SSH key to Sourcehut
    sourcehut-ssh-key-add "$ssh_key_path" "$ssh_keytag"
    local demo_message="\nYou can SSH to Sourcehut by running:\n\n ssh -T $(_ssh-keytag-service-identity "$ssh_key_path")\n"
  else
    log "DEBUG Skipping service-specific setup - SSH Keytag doesn't match known services."
  fi

  log "Success! Setup complete for key: $ssh_keytag"

  if [[ -n ${demo_message:-} ]]; then
    echo -e "$demo_message" # Only for GitHub keys
  fi
}

keycutter-authorized-keys() {
  ssh-authorized-keys "$@"
}

keycutter-push-keys() {
  local host="$1"

  if [[ -z "$host" ]]; then
    log "Error: Host required"
    return 1
  fi

  # Get the authorized keys for this host
  local authorized_keys=$(keycutter authorized-keys "$host")

  if [[ -z "$authorized_keys" ]]; then
    log "Error: No authorized keys found for host: $host"
    return 1
  fi

  # Create a temporary file with .pub extension as ssh-copy-id expects
  local temp_key_file=$(mktemp --suffix=.pub)
  echo "$authorized_keys" > "$temp_key_file"

  # Create temp file for capturing stderr
  local error_output=$(mktemp)

  # First try with existing key authentication (BatchMode=yes prevents password prompts)
  log "Attempting to push keys to $host..."

  if ssh-copy-id \
    -f \
    -o BatchMode=yes \
    -o RemoteCommand=none \
    -o ConnectTimeout=5 \
    -i "$temp_key_file" \
    "$host" 2>"$error_output"; then
    log "Successfully pushed keys to $host using existing authentication"
    rm -f "$temp_key_file" "$error_output"
    return 0
  fi

  # Check if the error is due to host key verification failure
  if grep -q "REMOTE HOST IDENTIFICATION HAS CHANGED" "$error_output"; then
    log "⚠️  Host key verification failed for $host"

    # Extract the line number from the error message
    local offending_line=$(grep "Offending.*key in" "$error_output" | sed -n 's/.*:\([0-9]*\)$/\1/p')

    if [[ -n "$offending_line" ]]; then
      log "The offending key is on line $offending_line of ~/.ssh/known_hosts"

      # Ask user if they want to remove the old key
      echo -n "Do you want to remove the old host key and retry? (y/n): "
      read -r response

      if [[ "$response" == "y" || "$response" == "Y" ]]; then
        # Use our new ssh-known-hosts function
        if ssh-known-hosts-delete-line "$offending_line"; then
          log "Old host key removed. Retrying push-keys..."
          rm -f "$error_output"

          # Retry the push-keys operation
          keycutter-push-keys "$host"
          local retry_result=$?
          rm -f "$temp_key_file"
          return $retry_result
        else
          log "Error: Failed to remove old host key"
          rm -f "$temp_key_file" "$error_output"
          return 1
        fi
      else
        log "Cancelled. You can manually fix this with: keycutter ssh-known-hosts delete-line $offending_line"
        rm -f "$temp_key_file" "$error_output"
        return 1
      fi
    else
      # Couldn't extract line number, try removing by hostname
      log "Could not determine specific line. Checking for all entries for $host..."

      echo -n "Do you want to remove all known_hosts entries for $host and retry? (y/n): "
      read -r response

      if [[ "$response" == "y" || "$response" == "Y" ]]; then
        if ssh-known-hosts-remove "$host"; then
          log "Old host keys removed. Retrying push-keys..."
          rm -f "$error_output"

          # Retry the push-keys operation
          keycutter-push-keys "$host"
          local retry_result=$?
          rm -f "$temp_key_file"
          return $retry_result
        else
          log "Error: Failed to remove old host keys"
          rm -f "$temp_key_file" "$error_output"
          return 1
        fi
      else
        log "Cancelled. You can manually fix this with: keycutter ssh-known-hosts remove $host"
        rm -f "$temp_key_file" "$error_output"
        return 1
      fi
    fi
  fi

  rm -f "$error_output"

  # Fall back to password authentication
  log "Key authentication failed, trying password authentication..."

  ssh-copy-id \
    -f \
    -o PreferredAuthentications=password \
    -o RemoteCommand=none \
    -i "$temp_key_file" \
    "$host"

  local result=$?
  rm -f "$temp_key_file"

  if [[ $result -eq 0 ]]; then
    log "Successfully pushed keys to $host"
  else
    log "Error: Failed to push keys to $host"
    return 1
  fi
}

keycutter-list() {
  # ssh-keys-fido
  github-ssh-keys
}

keycutter-update() {
  keycutter-update-git
  check_requirements
  keycutter-update-ssh-config
  keycutter-update-touch-detector
  keycutter-migrate-agent-keys
}

keycutter-update-git() {
  log "Updating Keycutter from git..."

  # Check if we're in a git repository
  if ! git -C "${KEYCUTTER_ROOT}" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    log "Error: ${KEYCUTTER_ROOT} is not a git repository."
    return 1
  fi

  # Change to the KEYCUTTER_ROOT directory
  cd "${KEYCUTTER_ROOT}" || {
    log "Error: Unable to change to directory ${KEYCUTTER_ROOT}"
    return 1
  }

  # Get the current branch name
  local current_branch=$(git symbolic-ref --short HEAD)
  if [ -z "$current_branch" ]; then
    log "Error: Unable to determine current branch."
    return 1
  fi

  # Check if we're on the master branch
  if [[ "$current_branch" != "master" ]]; then
    log "Not on master branch. Current branch is $current_branch. Skipping update."
    return 0
  fi

  # Fetch the latest changes
  if ! git fetch origin; then
    log "Error: Failed to fetch updates from remote repository."
    return 1
  fi

  # Check if there are any changes to pull
  local behind_by=$(git rev-list HEAD..origin/"$current_branch" --count 2>/dev/null)
  if [ $? -ne 0 ]; then
    log "Error: Unable to determine if there are updates available."
    return 1
  fi

  if [ -z "$behind_by" ] || [ "$behind_by" -eq 0 ]; then
    log "Keycutter is already up to date."
    return 0
  fi

  # Pull the latest changes
  if ! git pull origin "$current_branch"; then
    log "Error: Failed to pull updates from remote repository."
    return 1
  fi

  log "Keycutter git update complete."
}

keycutter-update-ssh-config() {

  local src_dir="${KEYCUTTER_ROOT}/ssh_config/keycutter"
  local dest_dir="${KEYCUTTER_CONFIG_DIR}"

  # Find all files in the source directory
  for src_file in $(find "$src_dir" -type f); do
    # Get relative path from source directory
    local rel_path="${src_file#${src_dir}/}"
    local dest_file="${dest_dir}/${rel_path}"
    
    # Create destination directory if it doesn't exist
    local dest_subdir="$(dirname "$dest_file")"
    [[ -d "$dest_subdir" ]] || mkdir -p "$dest_subdir"
    
    # Check if file exists
    if [[ -f "$dest_file" ]]; then
      # Special handling for hosts directory - never overwrite
      if [[ "$rel_path" =~ ^hosts/ && "$rel_path" != "hosts/.README.md" ]]; then
        log "Preserving existing host file: $dest_file"
        continue
      fi
      
      # For other files, show diff and prompt
      if ! cmp -s "$src_file" "$dest_file"; then
        log "File is different: $dest_file"
        diff -u "$dest_file" "$src_file" || true
        prompt "Overwrite? [y/N] "
        read -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
          apply-template "$src_file" "$dest_file"
          log "Updated file: $dest_file"
        else
          log "Skipped update: $dest_file"
        fi
      else
        log "File is up to date: $dest_file"
      fi
    else
      # File doesn't exist, create it
      apply-template "$src_file" "$dest_file"
      log "Created new file: $dest_file"
    fi
  done

  # Add Include directive to the main SSH config file
  prepend-line-if-missing "${HOME}/.ssh/config" "Include ${KEYCUTTER_CONFIG#${HOME}/.ssh/}"

  log "Keycutter SSH update complete."
}

keycutter-update-touch-detector() {
  # Only check/prompt if we have FIDO keys
  local has_fido_keys=false
  if [[ -d "$KEYCUTTER_SSH_KEY_DIR" ]]; then
    for key_file in "$KEYCUTTER_SSH_KEY_DIR"/*; do
      if [[ -f "$key_file" && ! "$key_file" =~ \.pub$ && ! $(basename "$key_file") =~ ^\. ]]; then
        # Check if it's a FIDO key by looking at the public key
        if [[ -f "${key_file}.pub" ]] && grep -q "sk-" "${key_file}.pub"; then
          has_fido_keys=true
          break
        fi
      fi
    done
  fi
  
  if [[ "$has_fido_keys" != "true" ]]; then
    return 0
  fi
  
  # Check if touch detector is already installed
  local touch_detector_installed=false
  if [[ "$OSTYPE" == "linux-gnu"* ]]; then
    if command -v yubikey-touch-detector &>/dev/null || systemctl --user is-active yubikey-touch-detector.service &>/dev/null 2>&1; then
      touch_detector_installed=true
    fi
  elif [[ "$OSTYPE" == "darwin"* ]]; then
    if command -v yknotify &>/dev/null || launchctl list 2>/dev/null | grep -q com.user.yknotify; then
      touch_detector_installed=true
    fi
  fi
  
  if [[ "$touch_detector_installed" == "true" ]]; then
    return 0
  fi
  
  log ""
  log "YubiKey Touch Detector is not installed."
  log "This tool shows a notification when your YubiKey is waiting for a touch."
  prompt "Would you like to install it now? [Y/n] "
  read -n 1 -r
  echo
  
  if [[ ! ${REPLY:-} =~ ^[Nn]$ ]]; then
    keycutter-install-touch-detector
  fi
}

keycutter-migrate-agent-keys() {
  # Check if any agents have keys subdirectories that need migration
  local agents_to_migrate=()

  if [[ ! -d "${KEYCUTTER_CONFIG_DIR}/agents" ]]; then
    return 0
  fi

  for agent_dir in "${KEYCUTTER_CONFIG_DIR}/agents"/*/; do
    if [[ -d "${agent_dir}keys" ]]; then
      # Check if there are any symlinks in the keys subdirectory
      local has_keys=false
      for key_link in "${agent_dir}keys"/*; do
        if [[ -L "$key_link" ]]; then
          has_keys=true
          break
        fi
      done

      if [[ "$has_keys" == "true" ]]; then
        agents_to_migrate+=("$(basename "$agent_dir")")
      fi
    fi
  done

  if [[ ${#agents_to_migrate[@]} -eq 0 ]]; then
    return 0
  fi

  log ""
  log "Agent structure migration available:"
  log "Keycutter has simplified the agent directory structure."
  log "Key symlinks are now stored directly in the agent directory instead of a 'keys' subdirectory."
  log ""
  log "Agents with keys subdirectories: ${agents_to_migrate[*]}"
  prompt "Migrate symlinks? [Y/n] "
  read -n 1 -r
  echo

  if [[ ${REPLY:-} =~ ^[Nn]$ ]]; then
    log "Skipping migration. You can run 'keycutter update' again later to migrate."
    return 0
  fi

  # Perform migration
  for agent in "${agents_to_migrate[@]}"; do
    local agent_dir="${KEYCUTTER_CONFIG_DIR}/agents/${agent}"
    local keys_dir="${agent_dir}/keys"

    log "Migrating agent '$agent'..."

    # Move all symlinks from keys/ to parent directory
    for key_link in "${keys_dir}"/*; do
      if [[ -L "$key_link" ]]; then
        local key_name=$(basename "$key_link")
        # Update the symlink to point one level up
        local target=$(readlink "$key_link")
        # Remove the old symlink
        rm "$key_link"
        # Create new symlink in agent directory with corrected path
        # The target needs one less ../ since we're one level higher
        local new_target="${target#../}"
        ln -sf "$new_target" "${agent_dir}/${key_name}"
        log "  Moved $key_name"
      fi
    done

    # Remove the empty keys directory
    if rmdir "$keys_dir" 2>/dev/null; then
      log "  Removed empty keys directory"
    fi
  done

  log "Migration complete."
}

keycutter-check-requirements() {
  check_requirements
}

keycutter-config() {
  if [[ $# -lt 1 ]]; then
    log "Error: Hostname is required for config command"
    usage
    return 1
  fi

  local hostname="$1"
  local libexec_path="${KEYCUTTER_ROOT}/libexec/keycutter/ssh-config-impact"

  if [[ ! -x "$libexec_path" ]]; then
    log "Error: Required script not found or not executable: $libexec_path"
    return 1
  fi

  "$libexec_path" "$hostname"
}

keycutter-agents() {
  local agents_dir="${KEYCUTTER_CONFIG_DIR}/agents"

  if [[ ! -d "$agents_dir" ]]; then
    log "No agents directory found at $agents_dir"
    return 1
  fi

  log "SSH Agent Profiles:"
  for agent_path in "$agents_dir"/*/; do
    if [[ -d "$agent_path" ]]; then
      local agent_name=$(basename "$agent_path")
      echo "  $agent_name"
    fi
  done
}

keycutter-hosts() {
  if [[ $# -gt 0 ]]; then
    local subcmd="$1"
    shift
    case "$subcmd" in
    edit)
      keycutter-hosts-edit "$@"
      ;;
    *)
      # Default behavior - list hosts
      keycutter-hosts-list
      ;;
    esac
  else
    keycutter-hosts-list
  fi
}

keycutter-hosts-list() {
  local ssh_config="${HOME}/.ssh/config"
  local hosts_dir="${KEYCUTTER_CONFIG_DIR}/hosts"

  log "Configured hosts:"

  # Extract Host patterns from SSH config
  if [[ -f "$ssh_config" ]]; then
    grep -h "^Host " "$ssh_config" "$KEYCUTTER_CONFIG" "$hosts_dir"/* 2>/dev/null |
      awk '{for(i=2;i<=NF;i++) print $i}' |
      grep -v "\*" |
      sort -u |
      while read -r host; do
        echo "  $host"
      done
  fi
}

keycutter-hosts-edit() {
  if [[ $# -lt 1 ]]; then
    log "Error: Host file name required"
    echo "Usage: keycutter hosts edit <filename>"
    return 1
  fi

  local filename="$1"
  local hosts_dir="${KEYCUTTER_CONFIG_DIR}/hosts"
  local file_path="${hosts_dir}/${filename}"

  # Use EDITOR environment variable, fall back to vim
  local editor="${EDITOR:-vim}"

  if [[ ! -f "$file_path" ]]; then
    log "Creating new host file: $file_path"
  fi

  "$editor" "$file_path"
}

keycutter-keys() {
  local keys_dir="${KEYCUTTER_SSH_KEY_DIR}"
  local show_all=""
  local show_gpg=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --all|-a)
        show_all="true"
        shift
        ;;
      --gpg)
        show_gpg="true"
        shift
        ;;
      *)
        shift
        ;;
    esac
  done

  if [[ ! -d "$keys_dir" ]]; then
    log "No keys directory found at $keys_dir"
    return 1
  fi

  # Show FIDO2/OpenSSH keys (those with private key files)
  if [[ -z "$show_gpg" ]]; then
    log "SSH Keys (FIDO2/OpenSSH):"
    local found_ssh=0
    for key_file in "$keys_dir"/*; do
      if [[ -f "$key_file" && ! "$key_file" =~ \.pub$ && ! $(basename "$key_file") =~ ^\. ]]; then
        local key_name=$(basename "$key_file")
        echo "  $key_name"
        ((found_ssh++))
      fi
    done
    if [[ $found_ssh -eq 0 ]]; then
      echo "  (none)"
    fi
  fi

  # Show GPG-backed SSH keys (those with only .pub files, no private key)
  if [[ -n "$show_all" || -n "$show_gpg" ]]; then
    echo
    log "SSH Keys (GPG-backed):"
    local found_gpg=0
    for pubkey_file in "$keys_dir"/*.pub; do
      [[ -f "$pubkey_file" ]] || continue

      local key_name
      key_name=$(basename "$pubkey_file" .pub)

      # GPG-backed keys have .pub but no private key file
      if [[ ! -f "$keys_dir/$key_name" ]]; then
        # Verify it's a valid SSH public key format
        if grep -qE "^(ssh-ed25519|ssh-rsa|ecdsa-sha2)" "$pubkey_file" 2>/dev/null; then
          echo "  $key_name"
          ((found_gpg++))
        fi
      fi
    done
    if [[ $found_gpg -eq 0 ]]; then
      echo "  (none)"
    fi
  fi
}

# Agent subcommands
keycutter-agent() {
  local subcmd="$1"
  shift

  case "$subcmd" in
  show)
    keycutter-agent-show "$@"
    ;;
  keys)
    keycutter-agent-keys "$@"
    ;;
  hosts)
    keycutter-agent-hosts "$@"
    ;;
  add-key)
    keycutter-agent-add-key "$@"
    ;;
  remove-key)
    keycutter-agent-remove-key "$@"
    ;;
  *)
    log "Error: Unknown agent subcommand: $subcmd"
    usage
    exit 1
    ;;
  esac
}

keycutter-agent-show() {
  if [[ $# -lt 1 ]]; then
    log "Error: Agent name required"
    return 1
  fi

  local agent="$1"
  local agent_dir="${KEYCUTTER_CONFIG_DIR}/agents/$agent"

  if [[ ! -d "$agent_dir" ]]; then
    log "Error: Agent '$agent' not found"
    return 1
  fi

  log "Agent: $agent"

  # Show keys in agent
  log "Keys:"
  for key_link in "$agent_dir"/*; do
    if [[ -L "$key_link" && ! $(basename "$key_link") =~ ^\. ]]; then
      local key_name=$(basename "$key_link")
      echo "  $key_name"
    fi
  done

  # Show hosts using this agent
  log ""
  log "Hosts using this agent:"
  grep -h "IdentityAgent.*agents/$agent" "${HOME}/.ssh/config" "$KEYCUTTER_CONFIG" "${KEYCUTTER_CONFIG_DIR}/hosts"/* 2>/dev/null |
    grep -B5 "IdentityAgent" | grep "^Host " |
    awk '{for(i=2;i<=NF;i++) print $i}' |
    sort -u |
    while read -r host; do
      echo "  $host"
    done
}

keycutter-agent-keys() {
  if [[ $# -lt 1 ]]; then
    log "Error: Agent name required"
    return 1
  fi

  local agent="$1"
  local agent_dir="${KEYCUTTER_CONFIG_DIR}/agents/$agent"

  if [[ ! -d "$agent_dir" ]]; then
    log "Error: Agent '$agent' not found"
    return 1
  fi

  log "Keys in agent '$agent':"
  for key_link in "$agent_dir"/*; do
    if [[ -L "$key_link" && ! $(basename "$key_link") =~ ^\. ]]; then
      local key_name=$(basename "$key_link")
      echo "  $key_name"
    fi
  done
}

keycutter-agent-hosts() {
  if [[ $# -lt 1 ]]; then
    log "Error: Agent name required"
    return 1
  fi

  local agent="$1"

  log "Hosts using agent '$agent':"
  grep -h "IdentityAgent.*agents/$agent" "${HOME}/.ssh/config" "$KEYCUTTER_CONFIG" "${KEYCUTTER_CONFIG_DIR}/hosts"/* 2>/dev/null |
    grep -B5 "IdentityAgent" | grep "^Host " |
    awk '{for(i=2;i<=NF;i++) print $i}' |
    sort -u |
    while read -r host; do
      echo "  $host"
    done
}

keycutter-agent-add-key() {
  if [[ $# -lt 2 ]]; then
    log "Error: Agent name and key name required"
    return 1
  fi

  local agent="$1"
  local key="$2"
  local agent_dir="${KEYCUTTER_CONFIG_DIR}/agents/$agent"
  local key_path="${KEYCUTTER_SSH_KEY_DIR}/$key"

  if [[ ! -d "$agent_dir" ]]; then
    log "Error: Agent '$agent' not found"
    return 1
  fi

  if [[ ! -f "$key_path" ]]; then
    log "Error: Key '$key' not found"
    return 1
  fi

  # Create symlink in agent directory
  ln -sf "../../keys/$key" "$agent_dir/$key"
  log "Added key '$key' to agent '$agent'"
}

keycutter-agent-remove-key() {
  if [[ $# -lt 2 ]]; then
    log "Error: Agent name and key name required"
    return 1
  fi

  local agent="$1"
  local key="$2"
  local link_path="${KEYCUTTER_CONFIG_DIR}/agents/$agent/$key"

  if [[ -L "$link_path" ]]; then
    rm "$link_path"
    log "Removed key '$key' from agent '$agent'"
  else
    log "Error: Key '$key' not found in agent '$agent'"
    return 1
  fi
}

# Host subcommands
keycutter-host() {
  local subcmd="$1"
  shift

  case "$subcmd" in
  show)
    keycutter-host-show "$@"
    ;;
  agent)
    keycutter-host-agent "$@"
    ;;
  keys)
    keycutter-host-keys "$@"
    ;;
  config)
    keycutter-host-config "$@"
    ;;
  edit)
    keycutter-host-edit "$@"
    ;;
  *)
    log "Error: Unknown host subcommand: $subcmd"
    usage
    exit 1
    ;;
  esac
}

keycutter-host-show() {
  if [[ $# -lt 1 ]]; then
    log "Error: Host name required"
    return 1
  fi

  local host="$1"

  # Show commonly customized SSH config values
  # This list can be expanded based on what users typically care about
  local important_fields="hostname|user|port|identityfile|identityagent|forwardagent|localforward|remoteforward|dynamicforward|identitiesonly|hashknownhosts|serveralivecountmax|serveraliveinterval|proxycommand|proxyjump|requesttty|remotecommand|sendenv|tag|userknownhostsfile|stricthostkeychecking|checkhostip|controlmaster|controlpath|controlpersist"
  
  ssh -G "$host" | grep -E "^($important_fields)" | sort | while read -r line; do
    # Skip default values that are rarely customized
    case "$line" in
      "user $(whoami)"|"port 22"|"hostname $host"|"userknownhostsfile ${HOME}/.ssh/known_hosts ${HOME}/.ssh/known_hosts2")
        continue
        ;;
    esac
    echo "  $line"
  done
}

keycutter-host-agent() {
  if [[ $# -lt 1 ]]; then
    log "Error: Host name required"
    return 1
  fi

  local host="$1"
  local agent="$2"

  if [[ -z "$agent" ]]; then
    # Get current agent
    local current_agent=$(ssh -G "$host" | grep '^identityagent' | awk '{print $2}')
    if [[ -n "$current_agent" ]]; then
      echo "Agent for $host: $(basename $(dirname "$current_agent"))"
    else
      echo "No agent configured for $host"
    fi
  else
    # Set agent - would need to modify SSH config
    log "Setting agent for hosts is not yet implemented"
    return 1
  fi
}

keycutter-host-keys() {
  if [[ $# -lt 1 ]]; then
    log "Error: Host name required"
    return 1
  fi

  local host="$1"

  # List current keys
  log "Identity files for $host:"
  ssh -G "$host" | grep '^identityfile' | awk '{print $2}' | while read -r keyfile; do
    echo "  $(basename "$keyfile")"
  done
}

keycutter-host-config() {
  if [[ $# -lt 1 ]]; then
    log "Error: Host name required"
    return 1
  fi

  local host="$1"
  keycutter-config "$host"
}

keycutter-host-edit() {
  if [[ $# -lt 1 ]]; then
    log "Error: Host name required"
    echo "Usage: keycutter host edit <hostname>"
    return 1
  fi

  local hostname="$1"
  local hosts_dir="${KEYCUTTER_CONFIG_DIR}/hosts"
  local editor="${EDITOR:-vim}"
  local found_file=""

  # Search for the host in all host files
  for host_file in "$hosts_dir"/*.conf "$hosts_dir"/*; do
    if [[ -f "$host_file" && "$host_file" != *.README.md ]]; then
      if grep -q "^[[:space:]]*Host[[:space:]].*[[:space:]]${hostname}[[:space:]]*$\|^[[:space:]]*Host[[:space:]].*[[:space:]]${hostname}[[:space:]]" "$host_file" 2>/dev/null; then
        found_file="$host_file"
        break
      fi
    fi
  done

  if [[ -n "$found_file" ]]; then
    log "Opening $found_file for host: $hostname"
    "$editor" "$found_file"
  else
    log "Host '$hostname' not found in any configuration file"
    log "Available host files:"
    for f in "$hosts_dir"/*.conf "$hosts_dir"/*; do
      if [[ -f "$f" && "$f" != *.README.md ]]; then
        echo "  $(basename "$f")"
      fi
    done
    return 1
  fi
}

# Key subcommands
keycutter-key() {
  local subcmd="$1"
  shift

  case "$subcmd" in
  show)
    keycutter-key-show "$@"
    ;;
  agents)
    keycutter-key-agents "$@"
    ;;
  hosts)
    keycutter-key-hosts "$@"
    ;;
  *)
    log "Error: Unknown key subcommand: $subcmd"
    usage
    exit 1
    ;;
  esac
}

keycutter-key-show() {
  if [[ $# -lt 1 ]]; then
    log "Error: Key name required"
    return 1
  fi

  local key="$1"
  local key_path="${KEYCUTTER_SSH_KEY_DIR}/$key"

  if [[ ! -f "$key_path" ]]; then
    log "Error: Key '$key' not found"
    return 1
  fi

  log "Key: $key"

  # Show key fingerprint
  if command -v ssh-keygen &>/dev/null; then
    log "Fingerprint:"
    ssh-keygen -lf "$key_path"
  fi

  # Show which agents contain this key
  keycutter-key-agents "$key"

  # Show which hosts use this key
  keycutter-key-hosts "$key"
}

keycutter-key-agents() {
  if [[ $# -lt 1 ]]; then
    log "Error: Key name required"
    return 1
  fi

  local key="$1"

  log "Agents containing key '$key':"
  for agent_dir in "${KEYCUTTER_CONFIG_DIR}/agents"/*/; do
    if [[ -L "$agent_dir/$key" ]]; then
      echo "  $(basename "$agent_dir")"
    fi
  done
}

keycutter-key-hosts() {
  if [[ $# -lt 1 ]]; then
    log "Error: Key name required"
    return 1
  fi

  local key="$1"

  log "Hosts using key '$key':"
  # Search for hosts that have this key in their identity files
  grep -h "IdentityFile.*$key" "${HOME}/.ssh/config" "$KEYCUTTER_CONFIG" "${KEYCUTTER_CONFIG_DIR}/hosts"/* 2>/dev/null |
    grep -B5 "IdentityFile.*$key" | grep "^Host " |
    awk '{for(i=2;i<=NF;i++) print $i}' |
    sort -u |
    while read -r host; do
      echo "  $host"
    done
}

keycutter-install-touch-detector() {
  local installer_script="${KEYCUTTER_ROOT}/libexec/keycutter/install-touch-detector"
  
  if [[ ! -x "$installer_script" ]]; then
    log "Error: Touch detector installer not found at: $installer_script"
    return 1
  fi
  
  "$installer_script"
}

# Git signing subcommands

keycutter-git-signing() {
  # Show help for no args or explicit help flag
  if [[ $# -eq 0 ]] || [[ "$1" == "-h" ]] || [[ "$1" == "--help" ]] || [[ "$1" == "help" ]]; then
    echo "Usage: keycutter git-signing <subcommand>"
    echo
    echo "Configure git to sign commits with your SSH key."
    echo
    echo "Subcommands:"
    echo "  enable [--global] [key-path]   Enable commit signing with auto-detected SSH key"
    echo "  disable [--global]              Disable commit signing"
    echo "  status                          Show signing configuration"
    echo
    echo "Examples:"
    echo "  keycutter git-signing enable            # Enable for current repository"
    echo "  keycutter git-signing enable --global   # Enable globally for all repositories"
    echo "  keycutter git-signing disable           # Disable for current repository"
    echo "  keycutter git-signing status            # Show current configuration"
    echo
    [[ $# -eq 0 ]] && return 1 || return 0
  fi

  local subcmd="$1"
  shift

  case "$subcmd" in
    enable)
      git-signing-enable "$@"
      ;;
    disable)
      git-signing-disable "$@"
      ;;
    status)
      git-signing-status "$@"
      ;;
    *)
      log "Error: Unknown git-signing subcommand: $subcmd"
      echo "Available subcommands: enable, disable, status"
      return 1
      ;;
  esac
}

# GPG subcommands

keycutter-gpg() {
  if [[ $# -eq 0 ]] || [[ "$1" == "-h" ]] || [[ "$1" == "--help" ]] || [[ "$1" == "help" ]]; then
    echo "Usage: keycutter gpg <subcommand>"
    echo
    echo "Manage GPG keys with YubiKey support."
    echo
    echo "Subcommands:"
    echo "  key list [--all]               List GPG keys on current YubiKey"
    echo "  key create [--yes]             Create master key + subkeys (Sign, Encrypt, Auth)"
    echo "  key install [--master KEY_ID]  Install subkeys from master to YubiKey"
    echo "  setup                          Configure host for GPG/YubiKey operation"
    echo "  backup                         Backup master key to encrypted storage"
    echo
    echo "Examples:"
    echo "  keycutter gpg key list           # Show keys on current YubiKey"
    echo "  keycutter gpg key create         # Interactive master + subkey creation"
    echo "  keycutter gpg key create --yes   # Non-interactive with config defaults"
    echo "  keycutter gpg setup              # Configure this host for GPG/YubiKey"
    echo
    [[ $# -eq 0 ]] && return 1 || return 0
  fi

  local subcmd="$1"
  shift

  case "$subcmd" in
    key)
      keycutter-gpg-key "$@"
      ;;
    setup)
      keycutter-gpg-setup "$@"
      ;;
    backup)
      keycutter-gpg-backup "$@"
      ;;
    *)
      log "Error: Unknown gpg subcommand: $subcmd"
      echo "Available subcommands: key, setup, backup"
      return 1
      ;;
  esac
}

keycutter-gpg-key() {
  if [[ $# -eq 0 ]] || [[ "$1" == "-h" ]] || [[ "$1" == "--help" ]] || [[ "$1" == "help" ]]; then
    echo "Usage: keycutter gpg key <subcommand>"
    echo
    echo "Manage GPG keys."
    echo
    echo "Subcommands:"
    echo "  list [--all]               List GPG keys on current YubiKey"
    echo "                             With --all, also show available master keys"
    echo "  create [--yes]             Create master key + subkeys"
    echo "                             With --yes, use config file defaults"
    echo "  install [--backup FILE]    Install subkeys from backup to YubiKey"
    echo "                             Lists available backups if no file specified"
    echo "  register [--fingerprint]   Register GPG auth key as SSH key with keycutter"
    echo "                             Exports public key for SSH and saves to keys directory"
    echo
    [[ $# -eq 0 ]] && return 1 || return 0
  fi

  local subcmd="$1"
  shift

  case "$subcmd" in
    list)
      keycutter-gpg-key-list "$@"
      ;;
    create)
      keycutter-gpg-key-create "$@"
      ;;
    install)
      keycutter-gpg-key-install "$@"
      ;;
    register)
      keycutter-gpg-key-register "$@"
      ;;
    *)
      log "Error: Unknown gpg key subcommand: $subcmd"
      echo "Available subcommands: list, create, install, register"
      return 1
      ;;
  esac
}

# GPG key management functions

keycutter-gpg-key-list() {
  # List GPG keys on current YubiKey and optionally master keys from backups
  #
  # Usage: keycutter gpg key list [--all]
  #
  # Options:
  #   --all    Also show available master keys from registered backup locations
  #
  # Output:
  #   Lists GPG keys currently on the YubiKey with their key IDs and capabilities

  local show_all=false

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --all|-a)
        show_all=true
        shift
        ;;
      -h|--help)
        echo "Usage: keycutter gpg key list [--all]"
        echo
        echo "List GPG keys on current YubiKey."
        echo
        echo "Options:"
        echo "  --all, -a    Also show available master keys from backup locations"
        return 0
        ;;
      *)
        log "Error: Unknown option: $1"
        return 1
        ;;
    esac
  done

  # Source GPG library
  source "${KEYCUTTER_ROOT}/lib/gpg"

  # Check GPG is available
  if ! gpg-version-check >/dev/null 2>&1; then
    log "Error: GPG is not installed or version too old"
    return 1
  fi

  # Try to get YubiKey card status
  log "GPG Keys on YubiKey:"
  echo

  local card_status
  if ! card_status=$(gpg --card-status 2>&1); then
    if [[ "$card_status" =~ "No such device" ]] || [[ "$card_status" =~ "card error" ]]; then
      log "  No YubiKey detected"
      log "  Insert a YubiKey with OpenPGP application enabled"
    else
      log "  Error reading card: $card_status"
    fi
  else
    # Parse and display card info
    gpg-card-status-display "$card_status"
  fi

  # Show master keys from backups if --all flag is set
  if [[ "$show_all" == "true" ]]; then
    echo
    log "Master Keys from Backup Locations:"
    echo
    gpg-master-keys-list
  fi
}

keycutter-gpg-key-create() {
  # Create GPG master key and subkeys for use with YubiKey
  #
  # Usage: keycutter gpg key create [options]
  #
  # Options:
  #   --identity IDENTITY    User ID for the key (e.g., "Name <email>")
  #   --key-type TYPE        Key algorithm: ed25519 (default) or rsa4096
  #   --expiration PERIOD    Subkey expiration: 1y, 2y, etc. (default: 2y)
  #   --master-expiration P  Master key expiration: 0 (never, default), 1y, etc.
  #   --passphrase PASS      Passphrase for key protection
  #   --yes, -y              Non-interactive mode using config defaults
  #   --master-only          Create only the master key (no subkeys)
  #   --subkeys              Add subkeys to existing master (requires --fingerprint)
  #   --fingerprint FP       Fingerprint of master key to add subkeys to
  #   -h, --help             Show this help message
  #
  # This command creates a GPG master key with Sign, Encrypt, and Auth subkeys
  # in a secure ephemeral environment. The master key never touches disk
  # unencrypted - it must be backed up before the session ends.
  #
  # Modes:
  #   1. Default: Create master + all 3 subkeys in one flow
  #   2. --master-only: Create just the Certify master key
  #   3. --subkeys --fingerprint FP: Add subkeys to existing master in GNUPGHOME
  #
  # Interactive mode (default):
  #   - Prompts for identity if not provided
  #   - Prompts for passphrase
  #   - Creates master + subkeys by default
  #
  # Non-interactive mode (--yes):
  #   - Uses GPG_IDENTITY from config or environment
  #   - Requires --passphrase or GPG_PASSPHRASE environment variable

  local identity=""
  local key_type=""
  local expiration=""
  local master_expiration=""
  local passphrase=""
  local non_interactive=false
  local master_only=false
  local subkeys_only=false
  local fingerprint=""

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --identity)
        identity="$2"
        shift 2
        ;;
      --key-type)
        key_type="$2"
        shift 2
        ;;
      --expiration)
        expiration="$2"
        shift 2
        ;;
      --master-expiration)
        master_expiration="$2"
        shift 2
        ;;
      --passphrase)
        passphrase="$2"
        shift 2
        ;;
      --yes|-y)
        non_interactive=true
        shift
        ;;
      --master-only)
        master_only=true
        shift
        ;;
      --subkeys)
        subkeys_only=true
        shift
        ;;
      --fingerprint)
        fingerprint="$2"
        shift 2
        ;;
      -h|--help)
        echo "Usage: keycutter gpg key create [options]"
        echo
        echo "Create a GPG master key and subkeys for use with YubiKey"
        echo
        echo "Options:"
        echo "  --identity IDENTITY    User ID (e.g., 'Name <email@example.com>')"
        echo "  --key-type TYPE        Algorithm: ed25519 (default), rsa4096"
        echo "  --expiration PERIOD    Subkey expiration: 2y (default), 1y, etc."
        echo "  --master-expiration P  Master key expiration: 0 (never, default)"
        echo "  --passphrase PASS      Passphrase for key protection"
        echo "  --yes, -y              Non-interactive mode"
        echo "  --master-only          Create only master key (no subkeys)"
        echo "  --subkeys              Add subkeys to existing master (use with --fingerprint)"
        echo "  --fingerprint FP       Master key fingerprint (for --subkeys mode)"
        echo "  -h, --help             Show this help"
        echo
        echo "Examples:"
        echo "  keycutter gpg key create"
        echo "  keycutter gpg key create --identity 'Alice <alice@example.com>'"
        echo "  keycutter gpg key create --yes --identity 'Bob <bob@example.com>' --passphrase 'secret123'"
        echo "  keycutter gpg key create --master-only --identity 'Carol <carol@example.com>'"
        echo "  keycutter gpg key create --subkeys --fingerprint ABCD1234 --passphrase 'secret'"
        return 0
        ;;
      *)
        log "Error: Unknown option: $1"
        log "Use --help for usage information"
        return 1
        ;;
    esac
  done

  # Source GPG library
  source "${KEYCUTTER_ROOT}/lib/gpg"

  # Load config first (needed for defaults lookup)
  gpg-config-load

  # Validate conflicting options
  if [[ "$master_only" == true && "$subkeys_only" == true ]]; then
    log "Error: --master-only and --subkeys cannot be used together"
    return 1
  fi

  # Validate --subkeys mode requirements
  if [[ "$subkeys_only" == true ]]; then
    if [[ -z "$fingerprint" ]]; then
      log "Error: --subkeys requires --fingerprint"
      return 1
    fi
    if [[ -z "$passphrase" ]]; then
      passphrase="${GPG_PASSPHRASE:-}"
    fi
    if [[ -z "$passphrase" ]]; then
      log "Error: --passphrase required for --subkeys mode"
      return 1
    fi
    # GNUPGHOME must already be set and contain the master key
    if [[ -z "${GNUPGHOME:-}" ]]; then
      log "Error: GNUPGHOME must be set and contain master key for --subkeys mode"
      return 1
    fi
  fi

  # Validate parameters in non-interactive mode BEFORE checking GPG
  # This provides immediate feedback to users about missing parameters
  if [[ "$non_interactive" == true && "$subkeys_only" == false ]]; then
    if [[ -z "$identity" ]]; then
      identity=$(gpg-config-get GPG_IDENTITY "")
    fi
    if [[ -z "$identity" ]]; then
      log "Error: --identity required in non-interactive mode"
      log "Set GPG_IDENTITY in config or use --identity flag"
      return 1
    fi
    if [[ -z "$passphrase" ]]; then
      passphrase="${GPG_PASSPHRASE:-}"
    fi
    if [[ -z "$passphrase" ]]; then
      log "Error: --passphrase required in non-interactive mode"
      log "Set GPG_PASSPHRASE environment variable or use --passphrase flag"
      return 1
    fi
  fi

  # Check GPG version
  if ! gpg-version-check >/dev/null 2>&1; then
    log "Error: GPG check failed"
    return 1
  fi

  # Handle --subkeys mode (add subkeys to existing master)
  if [[ "$subkeys_only" == true ]]; then
    log "Adding subkeys to existing master key: ${fingerprint:0:16}..."
    echo

    # Build arguments for gpg-subkeys-create
    local subkey_args=(--fingerprint "$fingerprint" --passphrase "$passphrase")
    [[ -n "$key_type" ]] && subkey_args+=(--key-type "$key_type")
    [[ -n "$expiration" ]] && subkey_args+=(--expiration "$expiration")

    # Create subkeys
    if ! gpg-subkeys-create "${subkey_args[@]}"; then
      log "Error: Failed to create subkeys"
      return 1
    fi

    echo
    log "Subkeys created successfully!"
    echo

    # Show key details
    gpg --homedir "$GNUPGHOME" --list-keys --keyid-format LONG "$fingerprint"

    return 0
  fi

  # Interactive mode: prompt for identity if not provided
  if [[ -z "$identity" ]]; then
    if ! gpg-identity-prompt identity; then
      log "Cancelled"
      return 1
    fi
  fi

  # Interactive mode: prompt for passphrase if not provided
  if [[ -z "$passphrase" ]]; then
    if ! gpg-passphrase-prompt passphrase; then
      log "Cancelled"
      return 1
    fi
  fi

  # Create ephemeral GNUPGHOME
  echo
  log "Creating secure ephemeral environment..."
  local ephemeral_home
  ephemeral_home=$(gpg-home-temp-create) || {
    log "Error: Failed to create ephemeral GNUPGHOME"
    return 1
  }

  # Set up cleanup trap
  trap 'gpg-home-temp-cleanup' EXIT

  echo
  log "Creating GPG master key..."
  echo

  # Build arguments for gpg-master-key-create
  local create_args=(--identity "$identity" --passphrase "$passphrase")
  [[ -n "$key_type" ]] && create_args+=(--key-type "$key_type")
  [[ -n "$master_expiration" ]] && create_args+=(--expiration "$master_expiration")

  # Create master key
  local master_fingerprint
  master_fingerprint=$(gpg-master-key-create "${create_args[@]}") || {
    log "Error: Failed to create master key"
    return 1
  }

  echo
  log "Master key created successfully!"
  echo
  echo "  Fingerprint: $master_fingerprint"
  echo "  Identity:    $identity"
  echo

  # Create subkeys unless --master-only was specified
  if [[ "$master_only" == false ]]; then
    echo
    log "Creating subkeys (Sign, Encrypt, Auth)..."
    echo

    # Build arguments for gpg-subkeys-create
    local subkey_args=(--fingerprint "$master_fingerprint" --passphrase "$passphrase")
    [[ -n "$key_type" ]] && subkey_args+=(--key-type "$key_type")
    [[ -n "$expiration" ]] && subkey_args+=(--expiration "$expiration")

    # Create subkeys
    if ! gpg-subkeys-create "${subkey_args[@]}"; then
      log "Error: Failed to create subkeys"
      log "Master key was created but subkeys failed."
      log "You can retry with: keycutter gpg key create --subkeys --fingerprint $master_fingerprint"
      return 1
    fi

    echo
    log "All subkeys created successfully!"
    echo
  fi

  # Show key details
  gpg --homedir "$GNUPGHOME" --list-keys --keyid-format LONG "$master_fingerprint"

  echo
  log "WARNING: The keys exist only in ephemeral memory!"
  log "You MUST backup this key before exiting or it will be lost."
  echo
  log "Next steps:"
  echo "  1. Run 'keycutter gpg backup' to save encrypted backup"
  echo "  2. Run 'keycutter gpg key install' to transfer subkeys to YubiKey"
  echo

  return 0
}

keycutter-gpg-key-install() {
  # Install GPG subkeys from a master key backup to YubiKey
  #
  # Usage: keycutter gpg key install [options]
  #
  # Options:
  #   --backup FILE         Path to encrypted backup file (prompts if not specified)
  #   --backup-pass PASS    Passphrase for backup decryption (prompts if not specified)
  #   --passphrase PASS     Key passphrase for subkey operations (prompts if not specified)
  #   --admin-pin PIN       YubiKey admin PIN (default: 12345678)
  #   --force               Overwrite existing keys on YubiKey
  #   --yes, -y             Non-interactive mode (requires all passphrases)
  #   -h, --help            Show this help message
  #
  # This command:
  #   1. Lists available master key backups
  #   2. Decrypts and loads the selected backup into ephemeral GNUPGHOME
  #   3. Detects YubiKey and checks for existing keys
  #   4. Transfers Sign, Encrypt, Auth subkeys to YubiKey
  #
  # After install, the YubiKey will hold your subkeys and can be used for:
  #   - Git commit signing
  #   - SSH authentication
  #   - File encryption/decryption

  local backup_file=""
  local backup_pass=""
  local passphrase=""
  local admin_pin="12345678"
  local force=false
  local non_interactive=false

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --backup)
        backup_file="$2"
        shift 2
        ;;
      --backup-pass)
        backup_pass="$2"
        shift 2
        ;;
      --passphrase)
        passphrase="$2"
        shift 2
        ;;
      --admin-pin)
        admin_pin="$2"
        shift 2
        ;;
      --force)
        force=true
        shift
        ;;
      --yes|-y)
        non_interactive=true
        shift
        ;;
      -h|--help)
        echo "Usage: keycutter gpg key install [options]"
        echo
        echo "Install GPG subkeys from a master key backup to YubiKey"
        echo
        echo "Options:"
        echo "  --backup FILE         Path to encrypted backup file"
        echo "  --backup-pass PASS    Passphrase for backup decryption"
        echo "  --passphrase PASS     Key passphrase for subkey operations"
        echo "  --admin-pin PIN       YubiKey admin PIN (default: factory default)"
        echo "  --force               Overwrite existing keys on YubiKey"
        echo "  --yes, -y             Non-interactive mode"
        echo "  -h, --help            Show this help"
        echo
        echo "Examples:"
        echo "  keycutter gpg key install"
        echo "  keycutter gpg key install --backup ~/gpg-backups/gpg-backup-2025-01-01-ABCD1234.tar.gz.gpg"
        echo "  keycutter gpg key install --yes --backup FILE --backup-pass 'pass1' --passphrase 'pass2'"
        echo
        echo "This command will:"
        echo "  1. List available master key backups"
        echo "  2. Decrypt and load the selected backup"
        echo "  3. Transfer subkeys to your YubiKey"
        echo
        echo "After install, your YubiKey can be used for signing, encryption, and SSH."
        return 0
        ;;
      *)
        log "Error: Unknown option: $1"
        log "Use --help for usage information"
        return 1
        ;;
    esac
  done

  # Source GPG library
  source "${KEYCUTTER_ROOT}/lib/gpg"

  # Load config
  gpg-config-load

  # Check GPG is available
  if ! gpg-version-check >/dev/null 2>&1; then
    log "Error: GPG is not installed or version too old"
    return 1
  fi

  # If no backup file specified, list available backups
  if [[ -z "$backup_file" ]]; then
    echo
    log "Available GPG key backups:"
    echo

    # Get list of backups
    local backup_dir
    backup_dir=$(gpg-config-get GPG_BACKUP_DIR "")
    backup_dir="${backup_dir/#\~/$HOME}"

    if [[ -z "$backup_dir" ]] || [[ ! -d "$backup_dir" ]]; then
      log "Error: No backup location configured or directory not found"
      log "Create a backup first with: keycutter gpg backup"
      return 1
    fi

    # Find backup files
    local -a backup_files=()
    local backup_count=0

    for f in "$backup_dir"/gpg-backup-*.tar.gz.gpg; do
      if [[ -f "$f" ]]; then
        backup_count=$((backup_count + 1))
        backup_files+=("$f")

        # Extract info from filename
        local backup_name
        backup_name=$(basename "$f")
        backup_name="${backup_name%.tar.gz.gpg}"
        local fingerprint="${backup_name##*-}"
        local backup_date
        backup_date=$(echo "$backup_name" | grep -oE '[0-9]{4}-[0-9]{2}-[0-9]{2}' || echo "unknown")

        echo "  [$backup_count] $(basename "$f")"
        echo "      Fingerprint: ...${fingerprint}"
        echo "      Created: $backup_date"
        echo
      fi
    done

    if [[ $backup_count -eq 0 ]]; then
      log "Error: No backup files found in: $backup_dir"
      log "Create a backup with: keycutter gpg key create && keycutter gpg backup"
      return 1
    fi

    if [[ $backup_count -eq 1 ]]; then
      backup_file="${backup_files[0]}"
      log "Using only available backup: $(basename "$backup_file")"
    else
      if [[ "$non_interactive" == true ]]; then
        log "Error: Multiple backups found. Use --backup to specify which backup to use."
        return 1
      fi

      # Prompt for selection
      local selection
      read -rp "Select backup [1-$backup_count]: " selection

      if [[ ! "$selection" =~ ^[0-9]+$ ]] || [[ "$selection" -lt 1 ]] || [[ "$selection" -gt $backup_count ]]; then
        log "Error: Invalid selection"
        return 1
      fi

      backup_file="${backup_files[$((selection - 1))]}"
    fi
  fi

  # Verify backup file exists
  if [[ ! -f "$backup_file" ]]; then
    log "Error: Backup file not found: $backup_file"
    return 1
  fi

  # Get backup passphrase
  if [[ -z "$backup_pass" ]]; then
    if [[ "$non_interactive" == true ]]; then
      log "Error: --backup-pass required in non-interactive mode"
      return 1
    fi

    echo
    log "Enter the passphrase to decrypt the backup:"
    read -rsp "Backup passphrase: " backup_pass
    echo
  fi

  # Get key passphrase
  if [[ -z "$passphrase" ]]; then
    if [[ "$non_interactive" == true ]]; then
      log "Error: --passphrase required in non-interactive mode"
      return 1
    fi

    echo
    log "Enter the passphrase for the GPG key:"
    read -rsp "Key passphrase: " passphrase
    echo
  fi

  # Create ephemeral GNUPGHOME for key operations
  echo
  log "Creating secure ephemeral environment..."

  local temp_home
  if ! temp_home=$(gpg-home-temp-create); then
    log "Error: Failed to create ephemeral GNUPGHOME"
    return 1
  fi

  # Set up cleanup trap
  trap 'gpg-home-temp-cleanup' EXIT

  # Restore the backup
  echo
  log "Restoring master key from backup..."

  local fingerprint
  if ! fingerprint=$(gpg-backup-restore --backup-file "$backup_file" --backup-pass "$backup_pass"); then
    log "Error: Failed to restore backup"
    return 1
  fi

  if [[ -z "$fingerprint" ]]; then
    log "Error: No key fingerprint returned from restore"
    return 1
  fi

  log "Restored key: ${fingerprint:0:16}..."

  # Verify we have 3 subkeys
  local subkey_count
  subkey_count=$(gpg --homedir "$GNUPGHOME" --list-secret-keys --with-colons "$fingerprint" 2>/dev/null | grep -c "^ssb:")

  if [[ $subkey_count -lt 3 ]]; then
    log "Error: Expected 3 subkeys (Sign, Encrypt, Auth), found $subkey_count"
    log "The backup may be incomplete or missing subkeys"
    return 1
  fi

  log "Found $subkey_count subkeys ready for transfer"

  # Detect YubiKey
  echo
  log "Detecting YubiKey..."

  if ! gpg-yubikey-detect --quiet &>/dev/null; then
    log "Error: No YubiKey detected"
    echo
    echo "Please insert your YubiKey and try again."
    echo "To check YubiKey status: ykman list"
    return 1
  fi

  local serial
  serial=$(gpg-yubikey-detect --quiet 2>/dev/null)
  log "YubiKey detected: $serial"

  # Check if YubiKey already has keys
  local card_status
  card_status=$(gpg-card-has-keys 2>/dev/null) || card_status="empty"

  if [[ "$card_status" != "empty" && "$force" != "true" ]]; then
    log "Error: YubiKey already has GPG keys installed"
    echo
    echo "Current status: $card_status"
    echo
    echo "Options:"
    echo "  1. Use --force to overwrite existing keys"
    echo "  2. Reset the card first: keycutter gpg card reset"
    echo "  3. Use a different YubiKey"
    return 1
  fi

  if [[ "$card_status" != "empty" && "$force" == "true" ]]; then
    log "Warning: Overwriting existing keys on YubiKey"
  fi

  # Transfer subkeys to YubiKey
  echo
  log "Transferring subkeys to YubiKey..."
  log "This is a ONE-WAY operation - keys cannot be extracted from YubiKey"
  echo

  if [[ "$non_interactive" != true && "$force" != true ]]; then
    read -rp "Continue? [y/N] " confirm
    if [[ ! "$confirm" =~ ^[Yy] ]]; then
      log "Transfer cancelled"
      return 1
    fi
  fi

  local transfer_args=(
    --fingerprint "$fingerprint"
    --passphrase "$passphrase"
    --admin-pin "$admin_pin"
  )

  if [[ "$force" == true ]]; then
    transfer_args+=(--force)
  fi

  if ! gpg-key-to-yubikey "${transfer_args[@]}"; then
    log "Error: Failed to transfer subkeys to YubiKey"
    return 1
  fi

  # Clean up ephemeral home (will be done by trap, but be explicit)
  echo
  log "Cleaning up ephemeral environment..."

  # Verify final state
  gpg-scdaemon-restart &>/dev/null
  sleep 1

  local final_status
  final_status=$(gpg-card-has-keys 2>/dev/null) || final_status="unknown"

  echo
  log "Installation complete!"
  echo
  echo "  YubiKey Serial: $serial"
  echo "  Key Fingerprint: ${fingerprint:0:16}..."
  echo "  Card Status: $final_status"
  echo
  log "Your YubiKey is now ready for:"
  echo "  - Git commit signing"
  echo "  - SSH authentication (via gpg-agent)"
  echo "  - File encryption/decryption"
  echo
  log "To configure host for GPG/YubiKey: keycutter gpg setup"

  return 0
}

keycutter-gpg-key-register() {
  # Register GPG authentication key as SSH key with keycutter
  #
  # Usage: keycutter gpg key register [options]
  #
  # Options:
  #   --fingerprint FP     GPG key fingerprint (uses YubiKey if not specified)
  #   --name NAME          Key name/keytag (auto-generated if not specified)
  #   --enable-ssh         Also enable GPG SSH support if not already configured
  #   --yes, -y            Non-interactive mode
  #   -h, --help           Show this help message
  #
  # This command exports the GPG authentication subkey as an SSH public key
  # and registers it with keycutter's key management, enabling:
  #   - keycutter keys --all to show GPG-backed SSH keys
  #   - Using GPG auth key for SSH via gpg-agent
  #
  # The key is saved as a .pub file in the keycutter keys directory.

  local fingerprint=""
  local key_name=""
  local enable_ssh=false
  local non_interactive=false

  # Show help
  if [[ "$1" == "-h" ]] || [[ "$1" == "--help" ]]; then
    echo "Usage: keycutter gpg key register [options]"
    echo
    echo "Register GPG authentication key as SSH key with keycutter."
    echo
    echo "Options:"
    echo "  --fingerprint FP     GPG key fingerprint (uses YubiKey if not specified)"
    echo "  --name NAME          Key name/keytag (auto-generated from key UID)"
    echo "  --enable-ssh         Also enable GPG SSH support if not configured"
    echo "  --yes, -y            Non-interactive mode"
    echo "  -h, --help           Show this help message"
    echo
    echo "Examples:"
    echo "  keycutter gpg key register"
    echo "  keycutter gpg key register --fingerprint ABC123"
    echo "  keycutter gpg key register --name github.com_alice@laptop"
    echo
    return 0
  fi

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --fingerprint)
        fingerprint="$2"
        shift 2
        ;;
      --name)
        key_name="$2"
        shift 2
        ;;
      --enable-ssh)
        enable_ssh=true
        shift
        ;;
      --yes|-y)
        non_interactive=true
        shift
        ;;
      *)
        log "Error: Unknown option: $1"
        return 1
        ;;
    esac
  done

  log "Registering GPG authentication key with keycutter..."
  echo

  # Check if gpg-agent SSH support should be enabled
  if [[ "$enable_ssh" == true ]]; then
    if ! gpg-ssh-agent-check &>/dev/null; then
      log "Enabling SSH support in gpg-agent..."
      gpg-setup-gpg-agent-conf --enable-ssh
      gpgconf --kill gpg-agent
      gpgconf --launch gpg-agent
    fi
  fi

  # Build arguments for gpg-ssh-key-register
  local register_args=()

  if [[ -n "$fingerprint" ]]; then
    register_args+=(--fingerprint "$fingerprint")
  fi

  if [[ -n "$key_name" ]]; then
    register_args+=(--name "$key_name")
  fi

  # Register the key
  local output_file
  if ! output_file=$(gpg-ssh-key-register "${register_args[@]}"); then
    log "Error: Failed to register GPG SSH key"
    return 1
  fi

  echo
  log "GPG SSH key registered successfully!"
  echo
  echo "  Public key: $output_file"
  echo
  echo "To view all keys including GPG-backed:"
  echo "  keycutter keys --all"
  echo
  echo "To use this key for SSH, ensure:"
  echo "  1. gpg-agent has SSH support: keycutter gpg setup --enable-ssh"
  echo "  2. SSH_AUTH_SOCK points to gpg-agent socket"
  echo "  3. YubiKey is inserted when connecting"
  echo

  return 0
}

keycutter-gpg-setup() {
  # Configure host for GPG/YubiKey usage
  #
  # Usage: keycutter gpg setup [options]
  #
  # Options:
  #   --enable-ssh          Enable SSH support in gpg-agent
  #   --skip-packages       Skip package installation
  #   --skip-config         Skip GPG configuration
  #   --skip-launchagent    Skip macOS LaunchAgent setup (macOS only)
  #   --yes, -y             Non-interactive mode
  #   -h, --help            Show this help message
  #
  # This command configures the host for GPG and YubiKey usage:
  #   1. Checks and installs required packages (gnupg, pinentry, ykman, pcscd)
  #   2. Configures gpg-agent with pinentry and optional SSH support
  #   3. Installs hardened gpg.conf from keycutter templates
  #   4. On macOS, installs LaunchAgents for gpg-agent
  #   5. Tests the configuration
  #   6. Shows shell configuration recommendations
  #
  # Supported platforms: macOS, Ubuntu, Debian, Fedora, RHEL, WSL

  local enable_ssh=false
  local skip_packages=false
  local skip_config=false
  local skip_launchagent=false
  local skip_wsl_relay=false
  local non_interactive=false

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --enable-ssh)
        enable_ssh=true
        shift
        ;;
      --skip-packages)
        skip_packages=true
        shift
        ;;
      --skip-config)
        skip_config=true
        shift
        ;;
      --skip-launchagent)
        skip_launchagent=true
        shift
        ;;
      --skip-wsl-relay)
        skip_wsl_relay=true
        shift
        ;;
      --yes|-y)
        non_interactive=true
        shift
        ;;
      -h|--help)
        echo "Usage: keycutter gpg setup [options]"
        echo
        echo "Configure host for GPG/YubiKey usage."
        echo
        echo "Options:"
        echo "  --enable-ssh          Enable SSH support in gpg-agent"
        echo "  --skip-packages       Skip package installation"
        echo "  --skip-config         Skip GPG configuration"
        echo "  --skip-launchagent    Skip macOS LaunchAgent setup (macOS only)"
        echo "  --skip-wsl-relay      Skip WSL relay setup (WSL only)"
        echo "  --yes, -y             Non-interactive mode"
        echo "  -h, --help            Show this help message"
        echo
        echo "This command:"
        echo "  1. Checks and installs required packages"
        echo "  2. Configures gpg-agent with pinentry"
        echo "  3. Installs hardened gpg.conf"
        echo "  4. On macOS, installs LaunchAgents for gpg-agent"
        echo "  5. On WSL, sets up GPG relay to Windows"
        echo "  6. Tests the configuration"
        echo "  7. Shows shell configuration recommendations"
        echo
        echo "Supported platforms: macOS, Ubuntu, Debian, Fedora, RHEL, WSL"
        return 0
        ;;
      *)
        log "Error: Unknown option: $1"
        echo "Use --help for usage information"
        return 1
        ;;
    esac
  done

  # Source GPG library for setup functions
  source "${KEYCUTTER_ROOT}/lib/gpg"

  # Detect OS
  local os
  os=$(gpg-setup-detect-os)

  # Detect WSL
  local wsl_version=""
  if wsl_version=$(gpg-wsl-detect 2>/dev/null); then
    log "Starting GPG setup for $os ($wsl_version)..."
    log "WSL detected - will configure GPG relay to Windows"
  else
    log "Starting GPG setup for $os..."
  fi
  echo

  # Step 1: Check and install packages
  if [[ "$skip_packages" != "true" ]]; then
    log "Step 1: Checking required packages..."

    local missing
    missing=$(gpg-setup-check-packages --os "$os" 2>/dev/null) || true

    if [[ -n "$missing" ]]; then
      log "Missing packages: $(echo "$missing" | tr '\n' ' ')"

      if [[ "$non_interactive" == "true" ]]; then
        gpg-setup-install-packages --os "$os" --yes || {
          log "Error: Package installation failed"
          return 1
        }
      else
        gpg-setup-install-packages --os "$os" || {
          log "Warning: Package installation skipped or failed"
          # Continue anyway - user might have packages installed differently
        }
      fi
    else
      log "All required packages are installed"
    fi
    echo
  fi

  # Step 2: Configure GPG
  if [[ "$skip_config" != "true" ]]; then
    log "Step 2: Configuring GPG..."

    # Configure gpg-agent
    local agent_args=(--backup)
    if [[ "$enable_ssh" == "true" ]]; then
      agent_args+=(--enable-ssh)
    fi

    gpg-setup-gpg-agent-conf "${agent_args[@]}" || {
      log "Error: Failed to configure gpg-agent"
      return 1
    }

    # Install gpg.conf
    gpg-setup-gpg-conf --backup || {
      log "Error: Failed to install gpg.conf"
      return 1
    }

    # Restart gpg-agent to pick up new config
    log "Restarting gpg-agent..."
    gpg-agent-restart "${GNUPGHOME:-$HOME/.gnupg}" >/dev/null 2>&1 || true

    echo
  fi

  # Step 3: macOS LaunchAgents
  if [[ "$os" == "macos" ]] && [[ "$skip_launchagent" != "true" ]]; then
    log "Step 3: Installing macOS LaunchAgents..."
    gpg-setup-macos-launchagent || {
      log "Warning: Failed to install LaunchAgents"
    }
    echo
  fi

  # Step 3b: WSL GPG Relay Setup
  if [[ -n "$wsl_version" ]] && [[ "$skip_wsl_relay" != "true" ]]; then
    log "Setting up WSL GPG relay to Windows..."
    echo

    local wsl_args=()
    if [[ "$enable_ssh" == "true" ]]; then
      wsl_args+=(--enable-ssh)
    fi
    if [[ "$non_interactive" == "true" ]]; then
      wsl_args+=(--yes)
    fi

    gpg-wsl-setup "${wsl_args[@]}" || {
      log "Warning: WSL GPG relay setup failed"
      log "You may need to configure this manually"
      log "See: keycutter gpg setup --help for troubleshooting"
    }

    # In WSL, skip the standard config steps as WSL relay handles GPG
    # Show WSL-specific shell config and skip standard test/config
    echo
    log "GPG setup for WSL complete!"
    echo
    echo "Next steps:"
    echo "  1. Add the shell configuration above to your ~/.bashrc or ~/.zshrc"
    echo "  2. Restart your shell or run: source ~/.bashrc"
    echo "  3. Ensure Windows GPG/Gpg4win is installed and gpg-agent is running"
    echo "  4. Insert your YubiKey and test with: gpg --card-status"
    echo
    echo "If gpg --card-status fails:"
    echo "  - In Windows, run: gpg-connect-agent /bye"
    echo "  - Check relay status: gpg_relay_status"
    echo "  - Restart relay: gpg_relay_restart"
    echo

    return 0
  fi

  # Step 4: Start pcscd if on Linux (not WSL - WSL uses Windows pcscd)
  if [[ "$os" != "macos" ]] && [[ -z "$wsl_version" ]]; then
    log "Ensuring pcscd service is running..."
    gpg-pcscd-ensure || {
      log "Warning: Could not start pcscd service"
    }
  fi

  # Step 5: Test configuration
  log "Testing configuration..."
  echo
  gpg-setup-test || {
    log "Warning: Some tests failed - see above for details"
  }

  # Step 6: Show shell configuration
  log "Shell configuration recommendations:"
  gpg-setup-shell-config --os "$os"

  # Summary
  echo
  log "GPG setup complete!"
  echo
  echo "Next steps:"
  echo "  1. Add the shell configuration above to your ~/.bashrc or ~/.zshrc"
  echo "  2. Restart your shell or run: source ~/.bashrc"
  if [[ "$enable_ssh" == "true" ]]; then
    echo "  3. Uncomment the SSH_AUTH_SOCK line to use GPG for SSH authentication"
  fi
  echo "  4. Create GPG keys: keycutter gpg key create"
  echo "  5. Install keys to YubiKey: keycutter gpg key install"
  echo

  return 0
}

keycutter-gpg-backup() {
  # Create encrypted backup of GPG master key
  #
  # Usage: keycutter gpg backup [options]
  #
  # Options:
  #   --fingerprint FP      Fingerprint of key to backup (prompts if not specified)
  #   --output-dir DIR      Directory for backup (prompts if not specified)
  #   --passphrase PASS     Key passphrase for export (prompts if not specified)
  #   --backup-pass PASS    Passphrase for backup encryption (prompts if not specified)
  #   --yes, -y             Non-interactive mode (requires all passphrases)
  #   -h, --help            Show this help message
  #
  # This command creates an encrypted backup of a GPG master key and its subkeys.
  # The backup includes:
  #   - Master key and subkeys (armor format)
  #   - Public key for distribution
  #   - Revocation certificate
  #   - Trust database
  #   - README with restore instructions
  #
  # All files are bundled into an AES256-encrypted archive.
  #
  # Environment:
  #   GNUPGHOME must be set and contain the key to backup.
  #   Typically used after 'keycutter gpg key create' in the same session.

  local fingerprint=""
  local output_dir=""
  local passphrase=""
  local backup_pass=""
  local non_interactive=false

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --fingerprint)
        fingerprint="$2"
        shift 2
        ;;
      --output-dir)
        output_dir="$2"
        shift 2
        ;;
      --passphrase)
        passphrase="$2"
        shift 2
        ;;
      --backup-pass)
        backup_pass="$2"
        shift 2
        ;;
      --yes|-y)
        non_interactive=true
        shift
        ;;
      -h|--help)
        echo "Usage: keycutter gpg backup [options]"
        echo
        echo "Create an encrypted backup of a GPG master key"
        echo
        echo "Options:"
        echo "  --fingerprint FP      Key fingerprint to backup"
        echo "  --output-dir DIR      Directory for backup storage"
        echo "  --passphrase PASS     Key passphrase for export"
        echo "  --backup-pass PASS    Passphrase for backup encryption"
        echo "  --yes, -y             Non-interactive mode"
        echo "  -h, --help            Show this help"
        echo
        echo "Examples:"
        echo "  keycutter gpg backup"
        echo "  keycutter gpg backup --fingerprint ABCD1234 --output-dir ~/gpg-backups"
        echo "  keycutter gpg backup --yes --passphrase 'keypass' --backup-pass 'backuppass'"
        echo
        echo "Environment:"
        echo "  GNUPGHOME must contain the key to backup"
        echo "  GPG_BACKUP_DIR can set default output directory"
        return 0
        ;;
      *)
        log "Error: Unknown option: $1"
        log "Use --help for usage information"
        return 1
        ;;
    esac
  done

  # Source GPG library
  source "${KEYCUTTER_ROOT}/lib/gpg"

  # Load config for defaults
  gpg-config-load

  # Verify GNUPGHOME is set
  if [[ -z "${GNUPGHOME:-}" ]]; then
    log "Error: GNUPGHOME is not set"
    log "The GPG backup command requires keys to be in an ephemeral GNUPGHOME."
    log "Typically this is used immediately after 'keycutter gpg key create'."
    return 1
  fi

  if [[ ! -d "$GNUPGHOME" ]]; then
    log "Error: GNUPGHOME directory does not exist: $GNUPGHOME"
    return 1
  fi

  # Check GPG is available
  if ! gpg-version-check >/dev/null 2>&1; then
    log "Error: GPG is not installed or version too old"
    return 1
  fi

  # Get list of secret keys in GNUPGHOME
  local secret_keys
  secret_keys=$(gpg --homedir "$GNUPGHOME" --list-secret-keys --with-colons 2>/dev/null | awk -F: '/^sec:/ { print $5 }')

  if [[ -z "$secret_keys" ]]; then
    log "Error: No secret keys found in GNUPGHOME"
    log "GNUPGHOME: $GNUPGHOME"
    return 1
  fi

  # If fingerprint not specified, list keys and prompt
  if [[ -z "$fingerprint" ]]; then
    echo
    log "Available keys in GNUPGHOME:"
    echo

    local key_count=0
    local key_list=()
    local keyid uid

    while IFS= read -r keyid; do
      [[ -z "$keyid" ]] && continue
      key_count=$((key_count + 1))
      key_list+=("$keyid")

      uid=$(gpg --homedir "$GNUPGHOME" --list-keys --with-colons "$keyid" 2>/dev/null | awk -F: '/^uid:/ { print $10; exit }')
      echo "  [$key_count] $keyid"
      [[ -n "$uid" ]] && echo "      $uid"
    done <<< "$secret_keys"

    echo

    if [[ $key_count -eq 0 ]]; then
      log "Error: No keys found"
      return 1
    fi

    if [[ $key_count -eq 1 ]]; then
      fingerprint="${key_list[0]}"
      log "Using only available key: ${fingerprint:0:16}..."
    else
      if [[ "$non_interactive" == true ]]; then
        log "Error: Multiple keys found. Use --fingerprint to specify which key to backup."
        return 1
      fi

      # Prompt for selection
      local selection
      read -rp "Select key to backup [1-$key_count]: " selection

      if [[ ! "$selection" =~ ^[0-9]+$ ]] || [[ "$selection" -lt 1 ]] || [[ "$selection" -gt $key_count ]]; then
        log "Error: Invalid selection"
        return 1
      fi

      fingerprint="${key_list[$((selection - 1))]}"
    fi
  fi

  # Get full fingerprint if short key ID provided
  if [[ ${#fingerprint} -lt 40 ]]; then
    local full_fp
    full_fp=$(gpg --homedir "$GNUPGHOME" --list-keys --with-colons "$fingerprint" 2>/dev/null | awk -F: '/^fpr:/ { print $10; exit }')
    if [[ -n "$full_fp" ]]; then
      fingerprint="$full_fp"
    fi
  fi

  # Get output directory
  if [[ -z "$output_dir" ]]; then
    output_dir=$(gpg-config-get GPG_BACKUP_DIR "")
    output_dir="${output_dir/#\~/$HOME}"
  fi

  if [[ -z "$output_dir" ]]; then
    if [[ "$non_interactive" == true ]]; then
      log "Error: --output-dir required in non-interactive mode"
      log "Set GPG_BACKUP_DIR in config or use --output-dir flag"
      return 1
    fi

    # Prompt for output directory
    local default_dir="${HOME}/gpg-backups"
    read -rp "Backup directory [$default_dir]: " output_dir
    output_dir="${output_dir:-$default_dir}"
  fi

  # Expand tilde
  output_dir="${output_dir/#\~/$HOME}"

  # Get key passphrase
  if [[ -z "$passphrase" ]]; then
    passphrase="${GPG_PASSPHRASE:-}"
  fi

  if [[ -z "$passphrase" ]]; then
    if [[ "$non_interactive" == true ]]; then
      log "Error: --passphrase required in non-interactive mode"
      return 1
    fi

    # Prompt for key passphrase
    echo
    log "Enter the passphrase for the GPG key:"
    read -rsp "Key passphrase: " passphrase
    echo
  fi

  # Get backup encryption passphrase
  if [[ -z "$backup_pass" ]]; then
    if [[ "$non_interactive" == true ]]; then
      log "Error: --backup-pass required in non-interactive mode"
      return 1
    fi

    # Prompt for backup passphrase
    echo
    log "Enter a passphrase to encrypt the backup archive:"
    log "(This can be different from your key passphrase)"
    read -rsp "Backup passphrase: " backup_pass
    echo
    read -rsp "Confirm backup passphrase: " backup_pass_confirm
    echo

    if [[ "$backup_pass" != "$backup_pass_confirm" ]]; then
      log "Error: Passphrases do not match"
      return 1
    fi
  fi

  # Create the backup
  echo
  log "Creating encrypted backup..."
  echo

  local backup_path
  if ! backup_path=$(gpg-key-backup \
    --fingerprint "$fingerprint" \
    --output-dir "$output_dir" \
    --passphrase "$passphrase" \
    --backup-pass "$backup_pass"); then
    log "Error: Backup failed"
    return 1
  fi

  echo
  log "Backup created successfully!"
  echo
  echo "  Location: $backup_path"
  echo
  log "IMPORTANT: Store this backup securely!"
  log "You will need both the backup file AND the backup passphrase to restore."
  echo

  # Register backup location in config (create user config if it doesn't exist)
  local user_config="${XDG_CONFIG_HOME:-$HOME/.config}/keycutter/gpg.conf"
  local config_dir
  config_dir=$(dirname "$user_config")

  if [[ ! -d "$config_dir" ]]; then
    mkdir -p "$config_dir"
    chmod 700 "$config_dir"
  fi

  # Check if GPG_BACKUP_DIR is already set in user config
  if [[ -f "$user_config" ]] && grep -q "^GPG_BACKUP_DIR=" "$user_config" 2>/dev/null; then
    # Already configured
    :
  else
    # Add GPG_BACKUP_DIR to user config
    echo "GPG_BACKUP_DIR=\"$output_dir\"" >> "$user_config"
    log "Registered backup location in config: $user_config"
  fi

  return 0
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  if [[ $# -eq 0 || "$1" == "-h" || "$1" == "--help" ]]; then
    usage
    exit 1
  fi

  cmd="$1"
  shift

  case "$cmd" in
  create | authorized-keys | push-keys | check-requirements | config | agents | hosts | keys | ssh-known-hosts)
    "keycutter-$cmd" "$@"
    ;;
  git-signing)
    "keycutter-git-signing" "$@"
    ;;
  gpg)
    "keycutter-gpg" "$@"
    ;;
  update)
    # Handle update subcommands
    if [[ $# -eq 0 ]]; then
      # No subcommand - run full update
      keycutter-update
    else
      subcmd="$1"
      shift
      case "$subcmd" in
        git)
          keycutter-update-git "$@"
          ;;
        config)
          keycutter-update-ssh-config "$@"
          ;;
        requirements)
          check_requirements "$@"
          ;;
        touch-detector)
          keycutter-update-touch-detector "$@"
          ;;
        *)
          log "Error: Unknown update subcommand: $subcmd"
          echo "Available subcommands: git, config, requirements, touch-detector"
          exit 1
          ;;
      esac
    fi
    ;;
  install-touch-detector)
    keycutter-install-touch-detector "$@"
    ;;
  agent | host | key)
    "keycutter-$cmd" "$@"
    ;;
  *)
    log "Error: Unknown command: $cmd"
    usage
    exit 1
    ;;
  esac
fi
