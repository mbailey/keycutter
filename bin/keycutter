#!/usr/bin/env bash
# set -eu -o pipefail

# [preview] keycutter - Create FIDO SSH keys for authentication and commit signing.

# KEYCUTTER_ROOT="$(readlink -f "$(dirname -- "${BASH_SOURCE[0]:-${0:A}}")/../")"
SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]:-${0:A}}")")" && pwd)"
KEYCUTTER_ROOT="$(cd -- "$SCRIPT_DIR/../" && pwd)"
source "${KEYCUTTER_ROOT}/lib/functions"

[ -t 0 ] || exec </dev/tty # reattach keyboard to STDIN

# If run on ORIGIN (not connected by SSH), default KEYCUTTER_ORIGIN to local hostname.
# Track whether KEYCUTTER_ORIGIN was explicitly set
KEYCUTTER_ORIGIN_EXPLICIT=${KEYCUTTER_ORIGIN:+true}
[[ -z $SSH_CONNECTION ]] && : ${KEYCUTTER_ORIGIN:="$(hostname -s)"}

# Set any undefined environment variables to default values
: ${KEYCUTTER_CONFIG:="${HOME}/.ssh/keycutter/keycutter.conf"}
: ${KEYCUTTER_CONFIG_DIR:="$(dirname "${KEYCUTTER_CONFIG}")"}
: ${KEYCUTTER_SSH_KEY_DIR:="${KEYCUTTER_CONFIG_DIR}/keys"}

: ${KEYCUTTER_SSH_KEY_TYPE_SK:="ed25519-sk"} # was ecdsa-sk
: ${KEYCUTTER_SSH_KEY_TYPE_NON_SK:="ed25519"}
: ${KEYCUTTER_SSH_KEY_TYPES:="ecdsa-sk ed25519-sk rsa ecdsa ed25519"}

# Prerequisites:
#
# - Bash >= 4.0
# - Git >= 2.34.0 # XXX Still needed?
# - GitHub CLI >= 2.0 (Greater than 2.4.0+dfsg1-2 on Ubuntu)
# - OpenSSH >= 8.2p1
# - YubiKey Manager
#
# WSL (Windows Subsystem for Linux) Setup:
#
#   WSL does not support USB devices natively, so we need to use Windows OpenSSH to access the YubiKey.
#   This requires a recent version of OpenSSH for Windows and a helper program to access the YubiKey.
#
#   Download and install a recent version of OpenSSH for Windows. This will give you 'ssh-sk-helper.exe'
#   1. Download and install a recent OpenSSH for Windows:
#        OpenSSH for Windows: https://github.com/PowerShell/Win32-OpenSSH/releases
#   2. Tell WSL OpenSSH to ask Windows for help:
#
#        echo 'export SSH_SK_HELPER="/mnt/c/Program Files/OpenSSH/ssh-sk-helper.exe"' >> ~/.bashrc
#
# Recommendations:
#
#   1. Use separate Github account per security domain (personal, work, public).
#      This will give you more freedom to login to GitHub on a device you trust
#      with that account without crossing security boundaries.
#
#   2. Only use GitHub CLI from a device you trust with that GitHub account.
#      E.g. Don't login to your personal GitHub account from a managed laptop.
#

usage() {
  echo "Usage:"
  echo "       $(basename "$0") <command> [arguments]"
  echo
  echo "Commands:"
  echo "       create <ssh-keytag> [--resident] [--type <value>] Create a new SSH key"
  echo "       check-requirements                                Check if all required software is installed"
  echo "       authorized-keys <hostname>                        Show public keys that would be offered to host"
  echo "       update                                            Update keycutter from git and refresh config"
  echo "       config <hostname>                                 Show config relevant to host"
  echo "       agents                                            List all agents"
  echo "       hosts                                             List all hosts"
  echo "       keys                                              List all keys"
  echo "       devices                                           List available security devices"
  echo "       yubikeys                                          List YubiKeys and FIDO tokens (TSV format)"
  echo "       yubikeys2                                         List YubiKeys using ykman (simpler format)"
  echo "       yubikey name <serial> <name>                      Set name for a YubiKey"
  echo
  echo "Agent commands:"
  echo "       agent show <agent>                                Show agent details"
  echo "       agent keys <agent>                                List keys in agent"
  echo "       agent hosts <agent>                               List hosts using agent"
  echo "       agent add-key <agent> <key>                       Add key to agent"
  echo "       agent remove-key <agent> <key>                    Remove key from agent"
  echo
  echo "Host commands:"
  echo "       host show <host>                                  Show host config"
  echo "       host agent <host> [agent]                         Get/set agent for host"
  echo "       host key <host> [key]                             Get/set key for host"
  echo "       host config <host>                                Show SSH config for host"
  echo
  echo "Key commands:"
  echo "       key show <key>                                    Show key details"
  echo "       key agents <key>                                  List agents containing key"
  echo "       key hosts <key>                                   List hosts using key"
  echo
  echo "For create command:"
  echo "  ssh-keytag Required. Identifier for key (e.g. github.com_alex@laptop-personal)"
  echo "  --resident Optional. Create resident FIDO SSH key (default is non-resident)"
  echo "  --type     Optional. Which cryptographic key to use (ecdsa-sk, ed25519-sk, rsa, ecdsa, ed25519)"
  echo "                       Default is ed25519-sk"
  echo
  echo "For config command:"
  echo "  hostname   Required. The SSH hostname to analyze (e.g. github.com, server.example.com)"
  echo
  echo "SSH Keytag format: service_user@device"
  echo "  - service : Service this key is used with (e.g. 'github.com', 'aws', 'digitalocean')"
  echo "  - user    : Service User this SSH Key authenticates as (e.g. 'alex')"
  echo "  - device  : Device this ssh key resides on (e.g. 'yubikey1', 'work-laptop', 'zfold5')"
}

keycutter-create() {

  if [[ $# -lt 1 ]]; then
    usage
    exit 1
  fi

  # Set default values, override with command line options
  local ssh_key_resident=""
  local ssh_key_type="$KEYCUTTER_SSH_KEY_TYPE_SK"
  local ssh_keytag=""

  local KEYCUTTER_CONFIG_DIR="$(dirname "${KEYCUTTER_CONFIG}")"

  while (("$#")); do
    case "$1" in
    --resident)
      ssh_key_resident="yes"
      shift
      ;;
    --type)
      ssh_key_type="$2"
      shift 2
      ;;
    -h | --help)
      usage
      exit 0
      ;;
    *)
      if [[ -z $ssh_keytag ]]; then
        ssh_keytag="$1"
      else
        log "Error: Invalid option $1"
        usage
        exit 1
      fi
      shift
      ;;
    esac
  done

  if [[ -z "$ssh_keytag" ]]; then
    usage
    exit 1
  fi

  # Check if the ssh_keytag ends with @$KEYCUTTER_ORIGIN
  if [[ ! "$ssh_keytag" =~ @${KEYCUTTER_ORIGIN}$ ]]; then
    local ssh_keytag_proposed="${ssh_keytag/@*/}@${KEYCUTTER_ORIGIN}"
    log "Info: Using the SSH Keytag convention allows the magic to happen"
    if [[ -z $KEYCUTTER_ORIGIN_EXPLICIT ]]; then
      log "Tip: Use an alias instead of hostname by setting KEYCUTTER_ORIGIN env var."
    fi
    log "See also: https://github.com/mbailey/keycutter/blob/master/docs/ssh-keytags.md"
    log ""
    prompt "Append the current device to the SSH Keytag? (${ssh_keytag_proposed}). (Y/n) "
    read -n 1 -r
    echo
    if [[ $REPLY =~ ^[Nn]$ ]]; then
      log "Proceeding with original ssh_keytag: $ssh_keytag"
    else
      ssh_keytag="${ssh_keytag_proposed}"
      log "Updated ssh_keytag to: $ssh_keytag"
    fi
  fi

  local ssh_key_path="${KEYCUTTER_CONFIG_DIR}/keys/${ssh_keytag}" # Path SSH key will be written to

  # Ensure config dirs exists wth correct perms
  dir-ensure "$KEYCUTTER_CONFIG_DIR" 0700
  dir-ensure "$(dirname "$ssh_key_path")" 0700

  # Create SSH Key for $ssh_keytag
  log "Generating SSH key: $ssh_key_path"
  case "$ssh_key_type" in
  ecdsa-sk | ed25519-sk)
    ssh-keygen -t "$ssh_key_type" -f "$ssh_key_path" -C "$ssh_keytag" ${ssh_key_resident:+-O resident}
    ;;
  rsa)
    ssh-keygen -t "$ssh_key_type" -b 4096 -f "$ssh_key_path" -C "$ssh_keytag"
    ;;
  ecdsa | ed25519)
    ssh-keygen -t "$ssh_key_type" -f "$ssh_key_path" -C "$ssh_keytag"
    ;;
  *)
    log "Error: Unsupported key type: $ssh_key_type"
    return 1
    ;;
  esac
  local case_exit_code=$?
  if [[ case_exit_code -ne 0 ]]; then
    log "WARNING No key was created"
    return $case_exit_code
  fi

  chmod 0600 "${ssh_key_path}.pub"

  # If the SSH Keytag includes github.com
  local service="$(_ssh-keytag-service "$ssh_keytag")"
  if [[ $service =~ github.com ]]; then
    # Optionally add SSH key to GitHub for auth and commit/tag signing: $ssh_key_path
    github-ssh-key-add "$ssh_key_path" "$ssh_keytag"
    local demo_message="\nYou can SSH to GitHub by running:\n\n ssh -T $(_ssh-keytag-service-identity "$ssh_key_path")\n"
    # Option to access GitHub when firewall blocks outbound port 22
    prompt "Symlink key to enable ssh.github.com:443? [Y/n] "
    read -n 1 -r
    echo
    if ! [[ $REPLY =~ ^[Nn]$ ]]; then
      log "Creating symlink: ln -sf $ssh_key_path ${ssh_key_path/github.com/ssh.github.com}"
      ln -sf "$ssh_key_path" "${ssh_key_path/github.com/ssh.github.com}"
    fi
  else
    log "DEBUG Skipping GitHub specific setup - SSH Keytag identity part doesn't contain 'github.com'."
  fi

  log "Success! Setup complete for key: $ssh_keytag"

  if [[ -n ${demo_message:-} ]]; then
    echo -e "$demo_message" # Only for GitHub keys
  fi
}

keycutter-authorized-keys() {
  ssh-authorized-keys "$@"
}

keycutter-list() {
  # ssh-keys-fido
  github-ssh-keys
}

keycutter-update() {
  keycutter-update-git
  check_requirements
  keycutter-update-ssh-config
}

keycutter-update-git() {
  log "Updating Keycutter from git..."

  # Check if we're in a git repository
  if ! git -C "${KEYCUTTER_ROOT}" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    log "Error: ${KEYCUTTER_ROOT} is not a git repository."
    return 1
  fi

  # Change to the KEYCUTTER_ROOT directory
  cd "${KEYCUTTER_ROOT}" || {
    log "Error: Unable to change to directory ${KEYCUTTER_ROOT}"
    return 1
  }

  # Get the current branch name
  local current_branch=$(git symbolic-ref --short HEAD)
  if [ -z "$current_branch" ]; then
    log "Error: Unable to determine current branch."
    return 1
  fi

  # Check if we're on the master branch
  if [[ "$current_branch" != "master" ]]; then
    log "Not on master branch. Current branch is $current_branch. Skipping update."
    return 0
  fi

  # Fetch the latest changes
  if ! git fetch origin; then
    log "Error: Failed to fetch updates from remote repository."
    return 1
  fi

  # Check if there are any changes to pull
  local behind_by=$(git rev-list HEAD..origin/"$current_branch" --count 2>/dev/null)
  if [ $? -ne 0 ]; then
    log "Error: Unable to determine if there are updates available."
    return 1
  fi

  if [ -z "$behind_by" ] || [ "$behind_by" -eq 0 ]; then
    log "Keycutter is already up to date."
    return 0
  fi

  # Pull the latest changes
  if ! git pull origin "$current_branch"; then
    log "Error: Failed to pull updates from remote repository."
    return 1
  fi

  log "Keycutter git update complete."
}

keycutter-update-ssh-config() {

  local src_dir="${KEYCUTTER_ROOT}/ssh_config"
  local dest_dir="${KEYCUTTER_CONFIG_DIR}"

  # Create the destination directory structure
  dir-ensure "$dest_dir"
  dir-ensure "$dest_dir/agents"
  dir-ensure "$dest_dir/hosts"
  dir-ensure "$dest_dir/keys"
  dir-ensure "$dest_dir/scripts"

  # Apply the template for the main config file
  apply-template "$src_dir/keycutter.conf" "$dest_dir/keycutter.conf"

  # Apply template for each script in the scripts directory
  for script in "$src_dir/scripts"/*; do
    if [[ -f "$script" ]]; then
      apply-template "$script" "$dest_dir/scripts/$(basename "$script")"
    fi
  done

  # Add Include directive to the main SSH config file
  prepend-line-if-missing "${HOME}/.ssh/config" "Include ${KEYCUTTER_CONFIG#${HOME}/.ssh/}"

  log "Keycutter SSH update complete."
}

keycutter-check-requirements() {
  check_requirements
}

keycutter-config() {
  if [[ $# -lt 1 ]]; then
    log "Error: Hostname is required for config command"
    usage
    return 1
  fi

  local hostname="$1"
  local libexec_path="${KEYCUTTER_ROOT}/libexec/keycutter/ssh-config-impact"

  if [[ ! -x "$libexec_path" ]]; then
    log "Error: Required script not found or not executable: $libexec_path"
    return 1
  fi

  "$libexec_path" "$hostname"
}

keycutter-agents() {
  local agents_dir="${KEYCUTTER_CONFIG_DIR}/agents"

  if [[ ! -d "$agents_dir" ]]; then
    log "No agents directory found at $agents_dir"
    return 1
  fi

  log "SSH Agent Profiles:"
  for agent_path in "$agents_dir"/*/; do
    if [[ -d "$agent_path" ]]; then
      local agent_name=$(basename "$agent_path")
      echo "  $agent_name"
    fi
  done
}

keycutter-hosts() {
  local ssh_config="${HOME}/.ssh/config"
  local hosts_dir="${KEYCUTTER_CONFIG_DIR}/hosts"

  log "Configured hosts:"

  # Extract Host patterns from SSH config
  if [[ -f "$ssh_config" ]]; then
    grep -h "^Host " "$ssh_config" "$KEYCUTTER_CONFIG" "$hosts_dir"/* 2>/dev/null |
      awk '{for(i=2;i<=NF;i++) print $i}' |
      grep -v "\*" |
      sort -u |
      while read -r host; do
        echo "  $host"
      done
  fi
}

keycutter-keys() {
  local keys_dir="${KEYCUTTER_SSH_KEY_DIR}"

  if [[ ! -d "$keys_dir" ]]; then
    log "No keys directory found at $keys_dir"
    return 1
  fi

  log "SSH Keys:"
  for key_file in "$keys_dir"/*; do
    if [[ -f "$key_file" && ! "$key_file" =~ \.pub$ && ! $(basename "$key_file") =~ ^\. ]]; then
      local key_name=$(basename "$key_file")
      echo "  $key_name"
    fi
  done
}

keycutter-devices() {
  log "Available security devices:"

  # Check for YubiKey Manager
  if command -v ykman &>/dev/null; then
    log ""
    log "YubiKeys (via ykman):"
    ykman list | while read -r device; do
      echo "  $device"
    done
  fi

  # Check for SSH FIDO devices
  #  if command -v ssh-keygen &>/dev/null; then
  #    log ""
  #    log "FIDO devices available to SSH:"
  #    # Try to probe for FIDO devices by attempting to generate a temporary key
  #    local temp_key=$(mktemp)
  #    if ssh-keygen -t ecdsa-sk -f "$temp_key" -N "" -C "probe" >/dev/null 2>&1; then
  #      echo "  FIDO device detected (accessible via SSH)"
  #      rm -f "$temp_key" "$temp_key.pub"
  #    else
  #      echo "  No FIDO devices detected or accessible"
  #    fi
  #  fi

  # Check for fido2-token
  if command -v fido2-token &>/dev/null; then
    log ""
    log "FIDO2 devices (via fido2-token):"
    fido2-token -L | while read -r device; do
      echo "  $device"
    done
  fi

  # Check USB devices
  if command -v lsusb &>/dev/null; then
    log ""
    log "USB security devices:"
    lsusb | grep -iE "(yubico|yubikey|fido|security key|titan)" | while read -r device; do
      echo "  $device"
    done
  fi

  # Check for hidraw devices (FIDO devices use HID)
  if [[ -d /dev ]]; then
    local hidraw_count=$(ls /dev/hidraw* 2>/dev/null | wc -l)
    if [[ $hidraw_count -gt 0 ]]; then
      log ""
      log "HID devices (potential FIDO devices): $hidraw_count found"
      ls -la /dev/hidraw* | while read -r device; do
        echo "  $device"
      done
    fi
  fi
}

keycutter-yubikeys() {
  # Check for fido2-token
  if ! command -v fido2-token &>/dev/null; then
    log "Error: fido2-token not found. Install libfido2 package."
    return 1
  fi

  # USB vendor/product ID to make/model mapping
  declare -A vendor_map=(
    ["1050:0402"]="Yubico|YubiKey 4"
    ["1050:0406"]="Yubico|YubiKey 4 Nano"
    ["1050:0407"]="Yubico|YubiKey 5 NFC"
    ["1050:0410"]="Yubico|YubiKey 5 Nano"
    ["1050:0421"]="Yubico|YubiKey 5C NFC"
    ["1050:0422"]="Yubico|YubiKey 5C Nano"
    ["1050:0423"]="Yubico|YubiKey 5Ci"
    ["18d1:5026"]="Google|Titan Security Key"
    ["096e:0858"]="Feitian|ePass FIDO"
    ["1ea8:c003"]="Thetis|FIDO2 Key"
    ["0483:a2ca"]="SoloKeys|Solo 2"
  )

  # Load device aliases if config exists
  local alias_file="${KEYCUTTER_CONFIG_DIR}/device-aliases"
  declare -A device_aliases
  if [[ -f "$alias_file" ]]; then
    while IFS=$'\t' read -r serial alias; do
      device_aliases["$serial"]="$alias"
    done <"$alias_file"
  fi

  # Get list of FIDO devices
  local fido_devices=$(fido2-token -L 2>/dev/null)
  
  # Process each FIDO device and include header
  (
    # Print header with a marker for skim-stdin to filter
    echo -e "#SERIAL\tNAME\tDEVICE\tMAKE\tMODEL\tVERSION\tCAPABILITIES\tAAGUID"
    
    # Check if any devices were found
    if [[ -z "$fido_devices" ]]; then
      echo -e "NO_DEVICES_FOUND\tNo YubiKeys or FIDO tokens detected\t-\t-\t-\t-\t-\t-"
      return 0
    fi
    
    # Create an array to track seen serial numbers
    declare -A seen_serials
    
    # First pass: collect all device info
    declare -a device_info_array
    
    echo "$fido_devices" | while read -r device_line; do
      # Extract the device path from the line (split on colon)
      local device=$(echo "$device_line" | cut -d':' -f1)
      # Get device info
      local info=$(fido2-token -I "$device" 2>/dev/null)
      if [[ $? -ne 0 ]]; then
        continue
      fi

      # Debug output is disabled for clean TSV output

      # Extract fields
      local serial=$(echo "$info" | grep "^serial:" | awk '{print $2}')
      local aaguid=$(echo "$info" | grep "^aaguid:" | awk '{print $2}')
      local version=$(echo "$info" | grep "^version strings:" | cut -d: -f2- | tr -d ' ' | tr ',' '|')
      local caps=$(echo "$info" | grep "^caps:" | cut -d: -f2- | sed 's/0x[0-9a-f]* (//' | sed 's/)//')
      local vendorid=$(echo "$info" | grep "^vendorId:" | awk '{print $2}')
      local productid=$(echo "$info" | grep "^productId:" | awk '{print $2}')

      # Extract device path and vendor/product info from the original line
      local vendor_product=$(echo "$device_line" | grep -o "vendor=[^,)]*" | cut -d= -f2)
      local product_id=$(echo "$device_line" | grep -o "product=[^,)]*" | cut -d= -f2)
      
      # Try to get YubiKey serial number using ykman if available
      if command -v ykman &>/dev/null && [[ "$device_line" == *"Yubico"* ]]; then
        # Extract the device path to identify the specific YubiKey
        local device_path="${device##*/}"
        
        # Get list of connected YubiKeys
        local ykman_list=$(ykman list 2>/dev/null)
        
        # Debug output when DEBUG is set
        if [[ -n "$DEBUG" ]]; then
          log "DEBUG: device_path = $device_path"
          log "DEBUG: ykman list output:"
          echo "$ykman_list" | while read -r line; do
            log "DEBUG:   $line"
          done
        fi
        
        # Since we can't directly match the hidraw device with ykman output,
        # we'll use a different approach:
        
        # 1. For YubiKeys, if there's only one YubiKey connected, use its serial
        local yk_count=$(echo "$ykman_list" | grep -c "YubiKey")
        
        if [[ $yk_count -eq 1 ]]; then
          # Only one YubiKey, safe to use its serial
          local ykman_serial=$(echo "$ykman_list" | grep "YubiKey" | grep -o "Serial: [0-9]*" | awk '{print $2}')
          if [[ -n "$ykman_serial" ]]; then
            serial="$ykman_serial"
            [[ -n "$DEBUG" ]] && log "DEBUG: Found single YubiKey with serial: $ykman_serial"
          fi
        else
          # Multiple YubiKeys or none - try to match by AAGUID if available
          if [[ -n "$aaguid" ]]; then
            # Try to use info command on each YubiKey to find matching AAGUID
            echo "$ykman_list" | grep "YubiKey" | while read -r yk_line; do
              if [[ "$yk_line" =~ Serial:\ ([0-9]+) ]]; then
                local this_serial="${BASH_REMATCH[1]}"
                [[ -n "$DEBUG" ]] && log "DEBUG: Checking YubiKey with serial: $this_serial"
                
                # Try to get FIDO info for this YubiKey
                local fido_info=$(ykman -d "$this_serial" fido info 2>/dev/null)
                if [[ -n "$fido_info" && "$fido_info" == *"$aaguid"* ]]; then
                  serial="$this_serial"
                  [[ -n "$DEBUG" ]] && log "DEBUG: Matched YubiKey by AAGUID: $this_serial"
                  break
                fi
              fi
            done
          fi
          
          # If still no match, try by vendor/product ID as last resort
          if [[ -z "$serial" || "$serial" == *"aaguid:"* ]] && [[ -n "$vendorid" && -n "$productid" ]]; then
            local vid_pid=$(printf "%04x:%04x" "$vendorid" "$productid")
            [[ -n "$DEBUG" ]] && log "DEBUG: Trying to match by VID:PID = $vid_pid"
            
            # Look for YubiKey with matching vendor/product ID
            local matched_line=$(echo "$ykman_list" | grep -i "YubiKey" | head -1)
            if [[ -n "$matched_line" ]]; then
              local ykman_serial=$(echo "$matched_line" | grep -o "Serial: [0-9]*" | awk '{print $2}')
              if [[ -n "$ykman_serial" ]]; then
                serial="$ykman_serial"
                [[ -n "$DEBUG" ]] && log "DEBUG: Using first YubiKey serial as fallback: $ykman_serial"
              fi
            else
              [[ -n "$DEBUG" ]] && log "DEBUG: No matching YubiKey found by VID:PID"
            fi
          fi
        fi
      fi
      
      # If still no serial, create a device identifier using multiple pieces of information
      if [[ -z "$serial" ]]; then
        if [[ -n "$aaguid" ]]; then
          # Use AAGUID + device path as a more specific identifier
          serial="aaguid:${aaguid}:${device##*/}"
        elif [[ -n "$vendor_product" && -n "$product_id" ]]; then
          # Use vendor:product + device path if no AAGUID
          serial="usb:${vendor_product}:${product_id}:${device##*/}"
        else
          # Last resort - just use device path
          serial="dev:${device##*/}"
        fi
      fi
      
      # Default values
      serial=${serial:-"NO_SERIAL"}
      local name="NO_NAME_SET"
      local make="Unknown"
      local model="Unknown"
      
      # Try to get the YubiKey name from ykman if it's a YubiKey with a serial number
      if command -v ykman &>/dev/null && [[ "$serial" =~ ^[0-9]+$ ]]; then
        local ykman_name=$(ykman -d "$serial" config get-name 2>/dev/null)
        if [[ -n "$ykman_name" && "$ykman_name" != "None" ]]; then
          name="$ykman_name"
        fi
      fi
      
      # Fall back to local alias file if no name from ykman
      if [[ "$name" == "NO_NAME_SET" ]]; then
        name="${device_aliases[$serial]:-NO_NAME_SET}"
      fi

      # Lookup make/model from USB IDs
      if [[ -n "$vendorid" && -n "$productid" ]]; then
        # Remove 0x prefix and convert to lowercase
        vendorid=$(printf "%04x" "$vendorid")
        productid=$(printf "%04x" "$productid")
        local usb_id="${vendorid}:${productid}"

        if [[ -n "${vendor_map[$usb_id]}" ]]; then
          IFS='|' read -r make model <<<"${vendor_map[$usb_id]}"
        fi
      fi

      # Truncate fields to keep under 80 chars
      version=${version:0:20}
      caps=${caps:0:20}

      # Store the device info in the array
      device_info_array+=("${serial}|${name}|${device}|${make}|${model}|${version}|${caps}|${aaguid:-N/A}")
    done
    
    # Second pass: deduplicate by serial number and output
    for info in "${device_info_array[@]}"; do
      IFS='|' read -r serial name device make model version caps aaguid <<< "$info"
      
      # Skip if we've already seen this serial number
      if [[ -n "${seen_serials[$serial]}" ]]; then
        [[ -n "$DEBUG" ]] && log "DEBUG: Skipping duplicate serial: $serial (device: $device)"
        continue
      fi
      
      # Mark this serial as seen
      seen_serials["$serial"]=1
      
      # Output TSV line
      echo -e "${serial}\t${name}\t${device}\t${make}\t${model}\t${version}\t${caps}\t${aaguid}"
    done
  ) | columnise
}

# Agent subcommands
keycutter-agent() {
  local subcmd="$1"
  shift

  case "$subcmd" in
  show)
    keycutter-agent-show "$@"
    ;;
  keys)
    keycutter-agent-keys "$@"
    ;;
  hosts)
    keycutter-agent-hosts "$@"
    ;;
  add-key)
    keycutter-agent-add-key "$@"
    ;;
  remove-key)
    keycutter-agent-remove-key "$@"
    ;;
  *)
    log "Error: Unknown agent subcommand: $subcmd"
    usage
    exit 1
    ;;
  esac
}

keycutter-agent-show() {
  if [[ $# -lt 1 ]]; then
    log "Error: Agent name required"
    return 1
  fi

  local agent="$1"
  local agent_dir="${KEYCUTTER_CONFIG_DIR}/agents/$agent"
  local keys_dir="${agent_dir}/keys"

  if [[ ! -d "$agent_dir" ]]; then
    log "Error: Agent '$agent' not found"
    return 1
  fi

  log "Agent: $agent"

  # Show keys in agent
  log "Keys:"
  if [[ -d "$keys_dir" ]]; then
    for key_link in "$keys_dir"/*; do
      if [[ -L "$key_link" && ! $(basename "$key_link") =~ ^\. ]]; then
        local key_name=$(basename "$key_link")
        echo "  $key_name"
      fi
    done
  fi

  # Also check for keys directly in agent directory for compatibility
  for key_link in "$agent_dir"/*; do
    if [[ -L "$key_link" && ! $(basename "$key_link") =~ ^\. && "$key_link" != */keys ]]; then
      local key_name=$(basename "$key_link")
      echo "  $key_name"
    fi
  done

  # Show hosts using this agent
  log ""
  log "Hosts using this agent:"
  grep -h "IdentityAgent.*agents/$agent" "${HOME}/.ssh/config" "$KEYCUTTER_CONFIG" "${KEYCUTTER_CONFIG_DIR}/hosts"/* 2>/dev/null |
    grep -B5 "IdentityAgent" | grep "^Host " |
    awk '{for(i=2;i<=NF;i++) print $i}' |
    sort -u |
    while read -r host; do
      echo "  $host"
    done
}

keycutter-agent-keys() {
  if [[ $# -lt 1 ]]; then
    log "Error: Agent name required"
    return 1
  fi

  local agent="$1"
  local agent_dir="${KEYCUTTER_CONFIG_DIR}/agents/$agent"
  local keys_dir="${agent_dir}/keys"

  if [[ ! -d "$agent_dir" ]]; then
    log "Error: Agent '$agent' not found"
    return 1
  fi

  log "Keys in agent '$agent':"
  # Check keys subdirectory first
  if [[ -d "$keys_dir" ]]; then
    for key_link in "$keys_dir"/*; do
      if [[ -L "$key_link" && ! $(basename "$key_link") =~ ^\. ]]; then
        local key_name=$(basename "$key_link")
        echo "  $key_name"
      fi
    done
  fi

  # Also check for keys directly in agent directory for compatibility
  for key_link in "$agent_dir"/*; do
    if [[ -L "$key_link" && ! $(basename "$key_link") =~ ^\. && "$key_link" != */keys ]]; then
      local key_name=$(basename "$key_link")
      echo "  $key_name"
    fi
  done
}

keycutter-agent-hosts() {
  if [[ $# -lt 1 ]]; then
    log "Error: Agent name required"
    return 1
  fi

  local agent="$1"

  log "Hosts using agent '$agent':"
  grep -h "IdentityAgent.*agents/$agent" "${HOME}/.ssh/config" "$KEYCUTTER_CONFIG" "${KEYCUTTER_CONFIG_DIR}/hosts"/* 2>/dev/null |
    grep -B5 "IdentityAgent" | grep "^Host " |
    awk '{for(i=2;i<=NF;i++) print $i}' |
    sort -u |
    while read -r host; do
      echo "  $host"
    done
}

keycutter-agent-add-key() {
  if [[ $# -lt 2 ]]; then
    log "Error: Agent name and key name required"
    return 1
  fi

  local agent="$1"
  local key="$2"
  local agent_dir="${KEYCUTTER_CONFIG_DIR}/agents/$agent"
  local keys_dir="${agent_dir}/keys"
  local key_path="${KEYCUTTER_SSH_KEY_DIR}/$key"

  if [[ ! -d "$agent_dir" ]]; then
    log "Error: Agent '$agent' not found"
    return 1
  fi

  if [[ ! -f "$key_path" ]]; then
    log "Error: Key '$key' not found"
    return 1
  fi

  # Create keys subdirectory if it doesn't exist
  [[ ! -d "$keys_dir" ]] && mkdir -p "$keys_dir"

  # Create symlink in keys subdirectory
  ln -sf "../../../keys/$key" "$keys_dir/$key"
  log "Added key '$key' to agent '$agent'"
}

keycutter-agent-remove-key() {
  if [[ $# -lt 2 ]]; then
    log "Error: Agent name and key name required"
    return 1
  fi

  local agent="$1"
  local key="$2"
  local keys_dir="${KEYCUTTER_CONFIG_DIR}/agents/$agent/keys"
  local link_path="${keys_dir}/$key"
  local alt_link_path="${KEYCUTTER_CONFIG_DIR}/agents/$agent/$key"

  # Check both locations for the key
  if [[ -L "$link_path" ]]; then
    rm "$link_path"
    log "Removed key '$key' from agent '$agent'"
  elif [[ -L "$alt_link_path" ]]; then
    rm "$alt_link_path"
    log "Removed key '$key' from agent '$agent'"
  else
    log "Error: Key '$key' not found in agent '$agent'"
    return 1
  fi
}

# Host subcommands
keycutter-host() {
  local subcmd="$1"
  shift

  case "$subcmd" in
  show)
    keycutter-host-show "$@"
    ;;
  agent)
    keycutter-host-agent "$@"
    ;;
  key)
    keycutter-host-key "$@"
    ;;
  config)
    keycutter-host-config "$@"
    ;;
  *)
    log "Error: Unknown host subcommand: $subcmd"
    usage
    exit 1
    ;;
  esac
}

keycutter-host-show() {
  if [[ $# -lt 1 ]]; then
    log "Error: Host name required"
    return 1
  fi

  local host="$1"
  log "Host: $host"

  # Extract SSH config for this host
  ssh -G "$host" | grep -E '^(hostname|user|port|identityfile|identityagent|forwardagent)' | while read -r line; do
    echo "  $line"
  done
}

keycutter-host-agent() {
  if [[ $# -lt 1 ]]; then
    log "Error: Host name required"
    return 1
  fi

  local host="$1"
  local agent="$2"

  if [[ -z "$agent" ]]; then
    # Get current agent
    local current_agent=$(ssh -G "$host" | grep '^identityagent' | awk '{print $2}')
    if [[ -n "$current_agent" ]]; then
      echo "Agent for $host: $(basename $(dirname "$current_agent"))"
    else
      echo "No agent configured for $host"
    fi
  else
    # Set agent - would need to modify SSH config
    log "Setting agent for hosts is not yet implemented"
    return 1
  fi
}

keycutter-host-key() {
  if [[ $# -lt 1 ]]; then
    log "Error: Host name required"
    return 1
  fi

  local host="$1"
  local key="$2"

  if [[ -z "$key" ]]; then
    # Get current keys
    log "Identity files for $host:"
    ssh -G "$host" | grep '^identityfile' | awk '{print $2}' | while read -r keyfile; do
      echo "  $(basename "$keyfile")"
    done
  else
    # Set key - would need to modify SSH config
    log "Setting keys for hosts is not yet implemented"
    return 1
  fi
}

keycutter-host-config() {
  if [[ $# -lt 1 ]]; then
    log "Error: Host name required"
    return 1
  fi

  local host="$1"
  keycutter-config "$host"
}

# Key subcommands
keycutter-key() {
  local subcmd="$1"
  shift

  case "$subcmd" in
  show)
    keycutter-key-show "$@"
    ;;
  agents)
    keycutter-key-agents "$@"
    ;;
  hosts)
    keycutter-key-hosts "$@"
    ;;
  *)
    log "Error: Unknown key subcommand: $subcmd"
    usage
    exit 1
    ;;
  esac
}

keycutter-key-show() {
  if [[ $# -lt 1 ]]; then
    log "Error: Key name required"
    return 1
  fi

  local key="$1"
  local key_path="${KEYCUTTER_SSH_KEY_DIR}/$key"

  if [[ ! -f "$key_path" ]]; then
    log "Error: Key '$key' not found"
    return 1
  fi

  log "Key: $key"

  # Show key fingerprint
  if command -v ssh-keygen &>/dev/null; then
    log "Fingerprint:"
    ssh-keygen -lf "$key_path"
  fi

  # Show which agents contain this key
  keycutter-key-agents "$key"

  # Show which hosts use this key
  keycutter-key-hosts "$key"
}

keycutter-key-agents() {
  if [[ $# -lt 1 ]]; then
    log "Error: Key name required"
    return 1
  fi

  local key="$1"

  log "Agents containing key '$key':"
  for agent_dir in "${KEYCUTTER_CONFIG_DIR}/agents"/*/; do
    # Check in keys subdirectory first
    if [[ -L "$agent_dir/keys/$key" ]]; then
      echo "  $(basename "$agent_dir")"
    # Also check in agent directory directly
    elif [[ -L "$agent_dir/$key" ]]; then
      echo "  $(basename "$agent_dir")"
    fi
  done
}

keycutter-key-hosts() {
  if [[ $# -lt 1 ]]; then
    log "Error: Key name required"
    return 1
  fi

  local key="$1"

  log "Hosts using key '$key':"
  # Search for hosts that have this key in their identity files
  grep -h "IdentityFile.*$key" "${HOME}/.ssh/config" "$KEYCUTTER_CONFIG" "${KEYCUTTER_CONFIG_DIR}/hosts"/* 2>/dev/null |
    grep -B5 "IdentityFile.*$key" | grep "^Host " |
    awk '{for(i=2;i<=NF;i++) print $i}' |
    sort -u |
    while read -r host; do
      echo "  $host"
    done
}

# Simple YubiKey listing function using ykman
keycutter-yubikeys2() {
  # Check if ykman is available
  if ! command -v ykman &>/dev/null; then
    log "Error: ykman not found. Install YubiKey Manager."
    return 1
  fi

  # Debug output
  if [[ -n "$DEBUG" ]]; then
    log "DEBUG: Running command: ykman list"
  fi

  # Get list of YubiKeys
  local ykman_list=$(ykman list 2>/dev/null)
  local ykman_exit=$?
  
  # Debug output for command result
  if [[ -n "$DEBUG" ]]; then
    log "DEBUG: ykman list exit code: $ykman_exit"
    log "DEBUG: ykman list output:"
    if [[ -n "$ykman_list" ]]; then
      echo "$ykman_list" | while read -r line; do
        log "DEBUG:   $line"
      done
    else
      log "DEBUG:   (no output)"
    fi
  fi
  
  if [[ -z "$ykman_list" ]]; then
    log "No YubiKeys detected."
    return 0
  fi
  
  # Print header
  echo -e "#SERIAL\tNAME\tTYPE\tFIRMWARE\tENABLED_APPS"
  
  # Process each YubiKey
  echo "$ykman_list" | while read -r yk_line; do
    # Extract serial number if present
    local serial="N/A"
    if [[ "$yk_line" =~ Serial:\ ([0-9]+) ]]; then
      serial="${BASH_REMATCH[1]}"
    elif [[ "$yk_line" =~ Security\ Key ]]; then
      # For Security Keys without serial, create a unique identifier based on device type and firmware
      if [[ "$yk_line" =~ Security\ Key\ ([^\ ]+)\ ([^\ ]+)\ \(([0-9\.]+)\) ]]; then
        local model="${BASH_REMATCH[1]} ${BASH_REMATCH[2]}"
        local fw="${BASH_REMATCH[3]}"
        serial="SecurityKey-${model// /-}-${fw}"
      else
        # Fallback if regex doesn't match
        serial="SecurityKey-$(echo "$yk_line" | md5sum | cut -c1-8)"
      fi
      
      # Try to get a more unique identifier using USB info
      if command -v lsusb &>/dev/null; then
        [[ -n "$DEBUG" ]] && log "DEBUG: Trying to get USB info for Security Key"
        # Get USB device info
        local usb_info=$(lsusb | grep -i "yubico" | head -1)
        if [[ -n "$usb_info" ]]; then
          # Extract bus and device numbers
          if [[ "$usb_info" =~ Bus\ ([0-9]+)\ Device\ ([0-9]+) ]]; then
            local bus="${BASH_REMATCH[1]}"
            local device="${BASH_REMATCH[2]}"
            [[ -n "$DEBUG" ]] && log "DEBUG: Found USB device at Bus $bus Device $device"
            
            # Try to get more detailed info from sysfs
            if [[ -d "/sys/bus/usb/devices/$bus-$device" ]]; then
              local device_path="/sys/bus/usb/devices/$bus-$device"
              local serial_from_usb=$(cat "$device_path/serial" 2>/dev/null)
              
              if [[ -n "$serial_from_usb" ]]; then
                [[ -n "$DEBUG" ]] && log "DEBUG: Found USB serial: $serial_from_usb"
                serial="$serial_from_usb"
              else
                # If no serial, use a combination of vendor, product, and physical location
                local vendor=$(cat "$device_path/idVendor" 2>/dev/null)
                local product=$(cat "$device_path/idProduct" 2>/dev/null)
                if [[ -n "$vendor" && -n "$product" ]]; then
                  serial="USB-${vendor}:${product}-${bus}:${device}"
                  [[ -n "$DEBUG" ]] && log "DEBUG: Created USB identifier: $serial"
                fi
              fi
            fi
          fi
        fi
      fi
    fi
    
    # Extract YubiKey type
    local yk_type=$(echo "$yk_line" | cut -d' ' -f1-3)
    
    # Extract firmware version
    local firmware="N/A"
    if [[ "$yk_line" =~ \(([0-9]+\.[0-9]+\.[0-9]+)\) ]]; then
      firmware="${BASH_REMATCH[1]}"
    fi
    
    # Extract enabled applications
    local apps="N/A"
    if [[ "$yk_line" =~ \[([^\]]+)\] ]]; then
      apps="${BASH_REMATCH[1]}"
    fi
    
    # Get YubiKey name if available
    local name="NO_NAME_SET"
    if [[ "$serial" != "N/A" ]]; then
      if [[ -n "$DEBUG" ]]; then
        log "DEBUG: Running command: ykman -d $serial config get-name"
      fi
      
      local ykman_name=$(ykman -d "$serial" config get-name 2>/dev/null)
      local name_exit=$?
      
      if [[ -n "$DEBUG" ]]; then
        log "DEBUG: ykman get-name exit code: $name_exit"
        log "DEBUG: ykman get-name output: $ykman_name"
      fi
      
      if [[ -n "$ykman_name" && "$ykman_name" != "None" ]]; then
        name="$ykman_name"
      fi
    fi
    
    # Debug output for extracted data
    if [[ -n "$DEBUG" ]]; then
      log "DEBUG: Extracted data for YubiKey:"
      log "DEBUG:   Serial: $serial"
      log "DEBUG:   Name: $name"
      log "DEBUG:   Type: $yk_type"
      log "DEBUG:   Firmware: $firmware"
      log "DEBUG:   Apps: $apps"
    fi
    
    # Output TSV line
    echo -e "${serial}\t${name}\t${yk_type}\t${firmware}\t${apps}"
  done | columnise
}

# YubiKey subcommands
keycutter-yubikey() {
  local subcmd="$1"
  shift

  case "$subcmd" in
  alias|name)
    keycutter-yubikey-name "$@"
    ;;
  *)
    log "Error: Unknown yubikey subcommand: $subcmd"
    usage
    exit 1
    ;;
  esac
}

keycutter-yubikey-name() {
  if [[ $# -lt 2 ]]; then
    log "Error: Serial number and name required"
    echo "Usage: keycutter yubikey name <serial> <name>"
    return 1
  fi

  local serial="$1"
  local name="$2"
  local alias_file="${KEYCUTTER_CONFIG_DIR}/device-aliases"

  # Check if ykman is available and if the serial looks like a numeric YubiKey serial
  if command -v ykman &>/dev/null && [[ "$serial" =~ ^[0-9]+$ ]]; then
    # Try to set the name using ykman
    if ykman -d "$serial" config set-name "$name" 2>/dev/null; then
      log "Set YubiKey $serial name to '$name' using ykman"
      return 0
    else
      log "Warning: Could not set YubiKey name using ykman, falling back to local alias file"
    fi
  elif [[ "$serial" =~ ^SecurityKey || "$serial" =~ ^USB- ]]; then
    log "Note: Security Keys without serial numbers can only use local name storage"
  else
    log "Warning: ykman not available or non-standard serial format, using local alias file"
  fi

  # Fallback to local alias file
  # Create the config directory if it doesn't exist
  dir-ensure "$KEYCUTTER_CONFIG_DIR" 0700

  # Check if the serial already has a name in the alias file
  if [[ -f "$alias_file" ]]; then
    if grep -q "^$serial" "$alias_file"; then
      # Update existing name
      sed -i "s/^$serial\t.*/$serial\t$name/" "$alias_file"
      log "Updated name for YubiKey $serial to '$name' in local file"
    else
      # Add new name
      echo -e "$serial\t$name" >> "$alias_file"
      log "Added name '$name' for YubiKey $serial to local file"
    fi
  else
    # Create new file with the name
    echo -e "$serial\t$name" > "$alias_file"
    log "Created device aliases file and added name '$name' for YubiKey $serial"
  fi
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  if [[ $# -eq 0 || "$1" == "-h" || "$1" == "--help" ]]; then
    usage
    exit 1
  fi

  cmd="$1"
  shift

  case "$cmd" in
  create | authorized-keys | update | check-requirements | config | agents | hosts | keys | devices | yubikeys | yubikeys2)
    "keycutter-$cmd" "$@"
    ;;
  agent | host | key | yubikey)
    "keycutter-$cmd" "$@"
    ;;
  *)
    log "Error: Unknown command: $cmd"
    usage
    exit 1
    ;;
  esac
fi
