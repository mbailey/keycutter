#!/usr/bin/env bash
# keycutter/lib/gpg - Functions for GPG key management with YubiKey support
#
# Configuration:
# - gpg-config-load(): Load GPG configuration with precedence handling
# - gpg-config-get(): Get a specific configuration value
# - gpg-config-dump(): Dump all loaded configuration (for debugging)
#
# Version and Environment:
# - gpg-version-check(): Verify GPG version meets requirements
# - gpg-home-temp-create(): Create ephemeral GNUPGHOME for secure key operations
# - gpg-home-temp-cleanup(): Clean up ephemeral GNUPGHOME
# - gpg-agent-restart(): Restart gpg-agent with proper configuration
# - gpg-agent-ensure(): Ensure gpg-agent is running
#
# Key Creation:
# - gpg-master-key-create(): Create master (Certify) key in ephemeral GNUPGHOME
# - gpg-subkeys-create(): Create Sign, Encrypt, Auth subkeys for master key
# - gpg-identity-prompt(): Interactive prompt for user identity
# - gpg-passphrase-prompt(): Interactive prompt for passphrase with confirmation
#
# Key Listing:
# - gpg-card-status-display(): Parse and display GPG card status
# - gpg-master-keys-list(): List master keys from backup locations
#
# Backup:
# - gpg-key-backup(): Create encrypted backup of master key and subkeys
# - gpg-backup-readme-generate(): Generate README with restore instructions
# - gpg-backup-list(): List available backups from registered locations
# - gpg-backup-restore(): Restore keys from encrypted backup to GNUPGHOME
#
# YubiKey Detection and Service Management:
# - gpg-pcscd-ensure(): Ensure pcscd service is running
# - gpg-scdaemon-restart(): Restart scdaemon for smartcard refresh
# - gpg-yubikey-detect(): Detect YubiKey with retry logic
# - gpg-yubikey-openpgp-enabled(): Check if OpenPGP is enabled on YubiKey
# - gpg-card-has-keys(): Check if YubiKey has GPG keys installed
#
# PIN Management:
# - gpg-pin-generate(): Generate secure random PIN
# - gpg-pin-change-admin(): Change YubiKey admin PIN
# - gpg-pin-change-user(): Change YubiKey user PIN
# - gpg-card-reset(): Reset OpenPGP application on YubiKey
#
# Subkey Transfer:
# - gpg-key-to-yubikey(): Transfer subkeys (Sign, Encrypt, Auth) to YubiKey
#
# Multiple YubiKey Support:
# - gpg-yubikey-registry-path(): Get path to YubiKey registry file
# - gpg-yubikey-registry-init(): Initialize registry file
# - gpg-yubikey-registry-add(): Register a YubiKey installation
# - gpg-yubikey-registry-list(): List registered installations
# - gpg-yubikey-registry-check(): Check if YubiKey is registered
# - gpg-yubikey-registry-remove(): Remove YubiKey from registry
# - gpg-yubikeys-list-available(): List currently connected YubiKeys

KEYCUTTER_ROOT="$(readlink -f "$(dirname -- "${BASH_SOURCE[0]:-${0:A}}")/../")"
source "${KEYCUTTER_ROOT}/lib/utils"

# Minimum GPG version required for modern key types and features
GPG_MIN_VERSION="2.2.0"

# Track ephemeral home for cleanup
_GPG_EPHEMERAL_HOME=""

# Configuration storage (associative array)
declare -gA _GPG_CONFIG

gpg-config-load() {
    # Load GPG configuration from defaults and environment
    #
    # Configuration precedence (highest to lowest):
    #   1. CLI arguments (passed as name=value pairs)
    #   2. Environment variables (GPG_* prefix)
    #   3. User config file (~/.config/keycutter/gpg.conf)
    #   4. Default values (config/gpg/defaults)
    #
    # Arguments:
    #   $@ - Optional CLI overrides as name=value pairs
    #
    # Returns:
    #   0 on success
    #   1 if defaults file is missing
    #
    # Example:
    #   gpg-config-load GPG_KEY_TYPE=rsa4096 GPG_EXPIRATION=1y

    local defaults_file="${KEYCUTTER_ROOT}/config/gpg/defaults"
    local user_config="${XDG_CONFIG_HOME:-$HOME/.config}/keycutter/gpg.conf"

    # Reset config
    _GPG_CONFIG=()

    # 1. Load defaults (lowest precedence)
    if [[ -f "$defaults_file" ]]; then
        local line key value
        while IFS= read -r line || [[ -n "$line" ]]; do
            # Skip comments and empty lines
            [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue

            # Parse key=value (handling quoted values)
            if [[ "$line" =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
                key="${BASH_REMATCH[1]}"
                value="${BASH_REMATCH[2]}"
                # Remove surrounding quotes if present
                value="${value#\"}"
                value="${value%\"}"
                _GPG_CONFIG["$key"]="$value"
            fi
        done < "$defaults_file"
    else
        log "Warning: GPG defaults file not found: $defaults_file"
    fi

    # 2. Load user config file (if exists)
    if [[ -f "$user_config" ]]; then
        local line key value
        while IFS= read -r line || [[ -n "$line" ]]; do
            [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
            if [[ "$line" =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
                key="${BASH_REMATCH[1]}"
                value="${BASH_REMATCH[2]}"
                value="${value#\"}"
                value="${value%\"}"
                _GPG_CONFIG["$key"]="$value"
            fi
        done < "$user_config"
    fi

    # 3. Apply environment variable overrides
    local var
    for var in GPG_KEY_TYPE GPG_EXPIRATION GPG_MASTER_EXPIRATION GPG_IDENTITY \
               GPG_COMMENT GPG_CIPHER_PREFS GPG_DIGEST_PREFS GPG_COMPRESS_PREFS \
               GPG_DEFAULT_PREFS GPG_CERT_DIGEST GPG_BACKUP_DIR GPG_BACKUP_FORMAT \
               GPG_KEYSERVER YUBIKEY_TOUCH_POLICY YUBIKEY_PIN_RETRIES \
               YUBIKEY_ADMIN_PIN_RETRIES; do
        if [[ -n "${!var:-}" ]]; then
            _GPG_CONFIG["$var"]="${!var}"
        fi
    done

    # 4. Apply CLI argument overrides (highest precedence)
    local arg key value
    for arg in "$@"; do
        if [[ "$arg" =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
            key="${BASH_REMATCH[1]}"
            value="${BASH_REMATCH[2]}"
            _GPG_CONFIG["$key"]="$value"
        fi
    done

    return 0
}

gpg-config-get() {
    # Get a configuration value
    #
    # Arguments:
    #   $1 - Configuration key (e.g., GPG_KEY_TYPE)
    #   $2 - Default value if not set (optional)
    #
    # Returns:
    #   0 if key exists
    #   1 if key doesn't exist and no default provided
    #
    # Output:
    #   Prints the configuration value

    local key="$1"
    local default="${2:-}"

    if [[ -v "_GPG_CONFIG[$key]" ]]; then
        echo "${_GPG_CONFIG[$key]}"
        return 0
    elif [[ -n "$default" ]]; then
        echo "$default"
        return 0
    else
        return 1
    fi
}

gpg-config-dump() {
    # Dump all loaded configuration (for debugging)
    #
    # Returns:
    #   0 always
    #
    # Output:
    #   Prints all configuration key=value pairs

    local key
    for key in "${!_GPG_CONFIG[@]}"; do
        echo "${key}=${_GPG_CONFIG[$key]}"
    done | sort
}

gpg-version-check() {
    # Check if GPG is installed and meets minimum version requirement
    #
    # Arguments:
    #   $1 - Required version (optional, defaults to GPG_MIN_VERSION)
    #
    # Returns:
    #   0 if version requirement met
    #   1 if GPG not found or version too old
    #
    # Output:
    #   Prints GPG version on success, error message on failure

    local required_version="${1:-$GPG_MIN_VERSION}"

    if ! command -v gpg &>/dev/null; then
        log "Error: GPG is not installed"
        echo "Please install GnuPG 2.x:"
        echo "  macOS:  brew install gnupg"
        echo "  Ubuntu: sudo apt install gnupg2"
        echo "  Fedora: sudo dnf install gnupg2"
        return 1
    fi

    local gpg_version
    gpg_version=$(gpg --version | head -n1 | awk '{print $3}')

    if [[ $(check_version "$gpg_version" "$required_version") == "false" ]]; then
        log "Error: GPG version $gpg_version is too old (require >= $required_version)"
        return 1
    fi

    echo "$gpg_version"
    return 0
}

gpg-home-temp-create() {
    # Create a secure ephemeral GNUPGHOME directory
    #
    # This is critical for key generation security - the master key
    # should never touch persistent disk storage unencrypted.
    #
    # Arguments:
    #   $1 - Base directory (optional, defaults to system temp)
    #
    # Returns:
    #   0 on success, 1 on failure
    #
    # Output:
    #   Prints path to ephemeral GNUPGHOME
    #
    # Side effects:
    #   Sets GNUPGHOME environment variable
    #   Creates cleanup trap on EXIT

    local base_dir="${1:-}"
    local temp_home

    # Use ramfs/tmpfs if available for extra security
    if [[ -z "$base_dir" ]]; then
        if [[ -d /dev/shm ]]; then
            base_dir="/dev/shm"
        elif [[ "$OSTYPE" == "darwin"* ]]; then
            # macOS doesn't have /dev/shm, use secure temp
            base_dir="${TMPDIR:-/tmp}"
        else
            base_dir="/tmp"
        fi
    fi

    # Create unique temporary directory with restrictive permissions
    temp_home=$(mktemp -d "${base_dir}/gnupg.XXXXXXXXXX") || {
        log "Error: Failed to create temporary GNUPGHOME"
        return 1
    }

    chmod 700 "$temp_home" || {
        log "Error: Failed to set permissions on GNUPGHOME"
        rm -rf "$temp_home"
        return 1
    }

    # Store for cleanup
    _GPG_EPHEMERAL_HOME="$temp_home"

    # Export GNUPGHOME
    export GNUPGHOME="$temp_home"

    # Set up cleanup trap (additive, won't replace existing traps)
    trap 'gpg-home-temp-cleanup' EXIT

    log "Create ephemeral GNUPGHOME: $temp_home"
    echo "$temp_home"
    return 0
}

gpg-home-temp-cleanup() {
    # Securely clean up ephemeral GNUPGHOME
    #
    # This function securely removes the ephemeral GPG home directory.
    # On Linux with secure-delete available, uses srm for secure removal.
    #
    # Returns:
    #   0 on success or if nothing to clean
    #   1 on failure

    if [[ -z "$_GPG_EPHEMERAL_HOME" ]] || [[ ! -d "$_GPG_EPHEMERAL_HOME" ]]; then
        return 0
    fi

    # Kill any gpg-agent using this home
    if [[ -n "${GNUPGHOME:-}" ]] && [[ "$GNUPGHOME" == "$_GPG_EPHEMERAL_HOME" ]]; then
        gpgconf --homedir "$_GPG_EPHEMERAL_HOME" --kill gpg-agent 2>/dev/null || true
    fi

    # Secure removal if available, otherwise regular rm
    if command -v srm &>/dev/null; then
        log "Securely removing ephemeral GNUPGHOME"
        srm -rf "$_GPG_EPHEMERAL_HOME" 2>/dev/null || rm -rf "$_GPG_EPHEMERAL_HOME"
    else
        log "Removing ephemeral GNUPGHOME"
        rm -rf "$_GPG_EPHEMERAL_HOME"
    fi

    _GPG_EPHEMERAL_HOME=""
    unset GNUPGHOME

    return 0
}

gpg-agent-restart() {
    # Restart gpg-agent with proper configuration
    #
    # Arguments:
    #   $1 - GNUPGHOME to use (optional, uses current GNUPGHOME or default)
    #
    # Returns:
    #   0 on success
    #   1 on failure

    local gpg_home="${1:-${GNUPGHOME:-$HOME/.gnupg}}"

    log "Restarting gpg-agent"

    # Kill existing agent
    gpgconf --homedir "$gpg_home" --kill gpg-agent 2>/dev/null || true

    # Brief pause for socket cleanup
    sleep 0.5

    # Restart agent
    if ! gpg-connect-agent --homedir "$gpg_home" /bye &>/dev/null; then
        # Try alternative method
        gpg --homedir "$gpg_home" --list-keys &>/dev/null || {
            log "Error: Failed to restart gpg-agent"
            return 1
        }
    fi

    log "Success: gpg-agent restarted"
    return 0
}

gpg-agent-ensure() {
    # Ensure gpg-agent is running with proper configuration
    #
    # Arguments:
    #   $1 - GNUPGHOME to use (optional, uses current GNUPGHOME or default)
    #
    # Returns:
    #   0 on success
    #   1 on failure

    local gpg_home="${1:-${GNUPGHOME:-$HOME/.gnupg}}"

    # Check if agent is responding
    if gpg-connect-agent --homedir "$gpg_home" /bye &>/dev/null; then
        return 0
    fi

    # Agent not running, start it
    gpg-agent-restart "$gpg_home"
}

# =============================================================================
# Key Creation Functions
# =============================================================================

gpg-master-key-create() {
    # Create a GPG master (Certify) key in ephemeral GNUPGHOME
    #
    # This function creates a master key that will be used to certify subkeys.
    # The key is created in an ephemeral GNUPGHOME for security - it should
    # never touch persistent disk storage unencrypted.
    #
    # Arguments:
    #   --identity    User ID for the key (e.g., "Name <email@example.com>")
    #   --key-type    Algorithm: ed25519 (default) or rsa4096
    #   --expiration  Expiration period: 0 (never), 1y, 2y, etc. (default: 0)
    #   --passphrase  Passphrase for the key (will prompt if not provided)
    #
    # Returns:
    #   0 on success
    #   1 on failure
    #
    # Output:
    #   Prints the key fingerprint on success
    #
    # Environment:
    #   GNUPGHOME must be set to ephemeral directory (use gpg-home-temp-create)
    #
    # Example:
    #   gpg-home-temp-create
    #   gpg-master-key-create --identity "Test User <test@example.com>"

    local identity=""
    local key_type=""
    local expiration=""
    local passphrase=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --identity)
                identity="$2"
                shift 2
                ;;
            --key-type)
                key_type="$2"
                shift 2
                ;;
            --expiration)
                expiration="$2"
                shift 2
                ;;
            --passphrase)
                passphrase="$2"
                shift 2
                ;;
            *)
                log "Error: Unknown option: $1"
                return 1
                ;;
        esac
    done

    # Load config for defaults
    gpg-config-load

    # Use provided values or fall back to config
    key_type="${key_type:-$(gpg-config-get GPG_KEY_TYPE ed25519)}"
    expiration="${expiration:-$(gpg-config-get GPG_MASTER_EXPIRATION 0)}"

    # Validate required parameters
    if [[ -z "$identity" ]]; then
        log "Error: --identity is required"
        log "Example: --identity 'Your Name <your@email.com>'"
        return 1
    fi

    # Validate GNUPGHOME is set and is ephemeral
    if [[ -z "${GNUPGHOME:-}" ]]; then
        log "Error: GNUPGHOME not set. Use gpg-home-temp-create first."
        return 1
    fi

    if [[ ! -d "$GNUPGHOME" ]]; then
        log "Error: GNUPGHOME directory does not exist: $GNUPGHOME"
        return 1
    fi

    # Validate key type
    case "$key_type" in
        ed25519|rsa4096|rsa3072)
            ;;
        *)
            log "Error: Invalid key type: $key_type"
            log "Supported types: ed25519, rsa4096, rsa3072"
            return 1
            ;;
    esac

    # Copy GPG configuration to ephemeral home
    local gpg_conf="${KEYCUTTER_ROOT}/config/gpg/gpg.conf"
    if [[ -f "$gpg_conf" ]]; then
        cp "$gpg_conf" "$GNUPGHOME/gpg.conf"
    fi

    # Configure gpg-agent for pinentry-loopback
    cat > "$GNUPGHOME/gpg-agent.conf" <<EOF
allow-loopback-pinentry
EOF

    # Restart agent with new config
    gpg-agent-restart "$GNUPGHOME" >/dev/null 2>&1

    log "Creating master key for: $identity"
    log "Key type: $key_type, Expiration: ${expiration:-never}"

    # Build the gpg command
    local gpg_cmd=(
        gpg
        --homedir "$GNUPGHOME"
        --batch
        --expert
    )

    # Add passphrase handling
    if [[ -n "$passphrase" ]]; then
        gpg_cmd+=(--pinentry-mode loopback --passphrase "$passphrase")
    fi

    # Generate the master key (Certify only)
    if ! "${gpg_cmd[@]}" --quick-generate-key "$identity" "$key_type" cert "$expiration" 2>&1; then
        log "Error: Failed to create master key"
        return 1
    fi

    # Get the key fingerprint
    local fingerprint
    fingerprint=$(gpg --homedir "$GNUPGHOME" --list-keys --with-colons "$identity" 2>/dev/null | awk -F: '/^fpr:/ { print $10; exit }')

    if [[ -z "$fingerprint" ]]; then
        log "Error: Failed to retrieve key fingerprint"
        return 1
    fi

    log "Success: Master key created"
    echo "$fingerprint"
    return 0
}

gpg-subkeys-create() {
    # Create subkeys (Sign, Encrypt, Auth) for an existing master key
    #
    # This function generates the three operational subkeys that will be
    # transferred to YubiKey. The master key (Certify only) remains secure
    # in the ephemeral GNUPGHOME or backup storage.
    #
    # Arguments:
    #   --fingerprint  Master key fingerprint (required)
    #   --key-type     Algorithm: ed25519 (default) or rsa4096
    #   --expiration   Expiration period: 2y (default), 1y, etc.
    #   --passphrase   Passphrase for the master key (required)
    #
    # Returns:
    #   0 on success (all 3 subkeys created)
    #   1 on failure
    #
    # Output:
    #   Prints subkey fingerprints on success
    #
    # Environment:
    #   GNUPGHOME must be set and contain the master key
    #
    # Example:
    #   gpg-subkeys-create --fingerprint "$FP" --passphrase "$PASS"

    local fingerprint=""
    local key_type=""
    local expiration=""
    local passphrase=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --fingerprint)
                fingerprint="$2"
                shift 2
                ;;
            --key-type)
                key_type="$2"
                shift 2
                ;;
            --expiration)
                expiration="$2"
                shift 2
                ;;
            --passphrase)
                passphrase="$2"
                shift 2
                ;;
            *)
                log "Error: Unknown option: $1"
                return 1
                ;;
        esac
    done

    # Load config for defaults
    gpg-config-load

    # Use provided values or fall back to config
    key_type="${key_type:-$(gpg-config-get GPG_KEY_TYPE ed25519)}"
    expiration="${expiration:-$(gpg-config-get GPG_EXPIRATION 2y)}"

    # Validate required parameters
    if [[ -z "$fingerprint" ]]; then
        log "Error: --fingerprint is required"
        return 1
    fi

    if [[ -z "$passphrase" ]]; then
        log "Error: --passphrase is required for batch subkey creation"
        return 1
    fi

    # Validate GNUPGHOME is set
    if [[ -z "${GNUPGHOME:-}" ]]; then
        log "Error: GNUPGHOME not set"
        return 1
    fi

    if [[ ! -d "$GNUPGHOME" ]]; then
        log "Error: GNUPGHOME directory does not exist: $GNUPGHOME"
        return 1
    fi

    # Validate key type
    case "$key_type" in
        ed25519|rsa4096|rsa3072)
            ;;
        *)
            log "Error: Invalid key type: $key_type"
            log "Supported types: ed25519, rsa4096, rsa3072"
            return 1
            ;;
    esac

    # Verify master key exists in GNUPGHOME
    if ! gpg --homedir "$GNUPGHOME" --list-keys "$fingerprint" &>/dev/null; then
        log "Error: Master key not found: $fingerprint"
        return 1
    fi

    log "Creating subkeys for master key: ${fingerprint:0:16}..."
    log "Key type: $key_type, Expiration: $expiration"

    # Subkey capabilities to create
    local subkeys=("sign" "encrypt" "auth")
    local created_count=0

    for subkey in "${subkeys[@]}"; do
        log "Creating $subkey subkey..."

        if gpg --homedir "$GNUPGHOME" \
               --batch \
               --pinentry-mode loopback \
               --passphrase "$passphrase" \
               --quick-add-key "$fingerprint" "$key_type" "$subkey" "$expiration" 2>&1; then
            log "Success: $subkey subkey created"
            created_count=$((created_count + 1))
        else
            log "Error: Failed to create $subkey subkey"
            return 1
        fi
    done

    # Verify all subkeys were created
    if [[ $created_count -ne 3 ]]; then
        log "Error: Expected 3 subkeys, created $created_count"
        return 1
    fi

    # List the subkeys we created
    local subkey_info
    subkey_info=$(gpg --homedir "$GNUPGHOME" --list-keys --with-colons "$fingerprint" 2>/dev/null | \
        awk -F: '/^sub:/ { print $5 }')

    log "Success: All subkeys created"
    echo "$subkey_info"
    return 0
}

gpg-identity-prompt() {
    # Interactively prompt for GPG identity components
    #
    # Arguments:
    #   $1 - Variable name to store result
    #
    # Returns:
    #   0 on success
    #   1 on user cancellation or invalid input
    #
    # Output:
    #   Sets the named variable to "Real Name <email@example.com>" format

    local result_var="$1"
    local name email identity

    echo
    echo "Enter your identity for the GPG key:"
    echo

    read -rp "  Real Name: " name
    if [[ -z "$name" ]]; then
        log "Error: Name is required"
        return 1
    fi

    read -rp "  Email: " email
    if [[ -z "$email" ]]; then
        log "Error: Email is required"
        return 1
    fi

    # Validate email format (basic check)
    if [[ ! "$email" =~ ^[^@]+@[^@]+\.[^@]+$ ]]; then
        log "Error: Invalid email format"
        return 1
    fi

    identity="$name <$email>"

    echo
    echo "  Identity: $identity"
    echo

    read -rp "  Is this correct? [Y/n] " confirm
    if [[ "$confirm" =~ ^[Nn] ]]; then
        return 1
    fi

    # Set the result variable
    printf -v "$result_var" '%s' "$identity"
    return 0
}

gpg-passphrase-prompt() {
    # Interactively prompt for GPG passphrase with confirmation
    #
    # Arguments:
    #   $1 - Variable name to store result
    #
    # Returns:
    #   0 on success
    #   1 on user cancellation or mismatch

    local result_var="$1"
    local pass1 pass2

    echo
    echo "Enter a strong passphrase to protect your GPG master key."
    echo "This passphrase protects your master key backup."
    echo

    read -rsp "  Passphrase: " pass1
    echo

    if [[ -z "$pass1" ]]; then
        log "Error: Passphrase cannot be empty"
        return 1
    fi

    # Check minimum length
    if [[ ${#pass1} -lt 8 ]]; then
        log "Error: Passphrase must be at least 8 characters"
        return 1
    fi

    read -rsp "  Confirm passphrase: " pass2
    echo

    if [[ "$pass1" != "$pass2" ]]; then
        log "Error: Passphrases do not match"
        return 1
    fi

    # Set the result variable
    printf -v "$result_var" '%s' "$pass1"
    return 0
}

# =============================================================================
# Key Listing Functions
# =============================================================================

gpg-card-status-display() {
    # Parse and display GPG card status in a clean format
    #
    # Arguments:
    #   $1 - Card status output from 'gpg --card-status'
    #
    # Output:
    #   Formatted display of card information and keys

    local card_status="$1"
    local reader serial_number card_holder
    local sig_key enc_key auth_key
    local general_key_info

    # Extract card info
    reader=$(echo "$card_status" | grep "^Reader" | sed 's/Reader[^:]*: *//')
    serial_number=$(echo "$card_status" | grep "^Serial number" | awk '{print $NF}')
    card_holder=$(echo "$card_status" | grep "^Name of cardholder" | sed 's/Name of cardholder: *//')

    # Extract key information
    sig_key=$(echo "$card_status" | grep "^Signature key" | sed 's/Signature key[^:]*: *//')
    enc_key=$(echo "$card_status" | grep "^Encryption key" | sed 's/Encryption key[^:]*: *//')
    auth_key=$(echo "$card_status" | grep "^Authentication key" | sed 's/Authentication key[^:]*: *//')

    # Check for general key info (indicates keys are properly linked)
    general_key_info=$(echo "$card_status" | grep "^General key info")

    # Display card information
    if [[ -n "$reader" ]]; then
        echo "  Reader:        $reader"
    fi
    if [[ -n "$serial_number" ]]; then
        echo "  Serial:        $serial_number"
    fi
    if [[ -n "$card_holder" && "$card_holder" != " " ]]; then
        echo "  Cardholder:    $card_holder"
    fi

    echo

    # Display keys with their status
    if [[ -n "$sig_key" && "$sig_key" != "[none]" ]]; then
        echo "  [S] Signature:     ${sig_key:0:16}..."
    else
        echo "  [S] Signature:     (not set)"
    fi

    if [[ -n "$enc_key" && "$enc_key" != "[none]" ]]; then
        echo "  [E] Encryption:    ${enc_key:0:16}..."
    else
        echo "  [E] Encryption:    (not set)"
    fi

    if [[ -n "$auth_key" && "$auth_key" != "[none]" ]]; then
        echo "  [A] Authentication: ${auth_key:0:16}..."
    else
        echo "  [A] Authentication: (not set)"
    fi

    # Show key status hint
    if [[ -z "$general_key_info" ]] && [[ "$sig_key" != "[none]" || "$enc_key" != "[none]" || "$auth_key" != "[none]" ]]; then
        echo
        echo "  Note: Keys present but not linked to local keyring."
        echo "  Run 'gpg --card-status' to fetch public keys."
    fi
}

# =============================================================================
# Backup Functions
# =============================================================================

gpg-key-backup() {
    # Create encrypted backup of GPG master key and subkeys
    #
    # This function exports the master key, subkeys, and public key in ASCII
    # armor format, then creates an encrypted archive for secure storage.
    #
    # Arguments:
    #   --fingerprint  Key fingerprint to backup (required)
    #   --output-dir   Directory to store backup (default: from config or prompted)
    #   --passphrase   Key passphrase for export (will prompt if not provided)
    #   --backup-pass  Passphrase for backup encryption (will prompt if not provided)
    #
    # Returns:
    #   0 on success
    #   1 on failure
    #
    # Output:
    #   Prints path to encrypted backup on success
    #
    # Environment:
    #   GNUPGHOME must be set and contain the key to backup
    #
    # Example:
    #   gpg-key-backup --fingerprint "ABCD1234..." --output-dir ~/gpg-backups

    local fingerprint=""
    local output_dir=""
    local passphrase=""
    local backup_pass=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --fingerprint)
                fingerprint="$2"
                shift 2
                ;;
            --output-dir)
                output_dir="$2"
                shift 2
                ;;
            --passphrase)
                passphrase="$2"
                shift 2
                ;;
            --backup-pass)
                backup_pass="$2"
                shift 2
                ;;
            *)
                log "Error: Unknown option: $1"
                return 1
                ;;
        esac
    done

    # Load config for defaults
    gpg-config-load

    # Get output directory from config if not provided
    if [[ -z "$output_dir" ]]; then
        output_dir=$(gpg-config-get GPG_BACKUP_DIR "")
        output_dir="${output_dir/#\~/$HOME}"
    fi

    # Validate required parameters
    if [[ -z "$fingerprint" ]]; then
        log "Error: --fingerprint is required"
        return 1
    fi

    if [[ -z "$output_dir" ]]; then
        log "Error: --output-dir is required (or set GPG_BACKUP_DIR in config)"
        return 1
    fi

    # Validate GNUPGHOME
    if [[ -z "${GNUPGHOME:-}" ]]; then
        log "Error: GNUPGHOME not set"
        return 1
    fi

    if [[ ! -d "$GNUPGHOME" ]]; then
        log "Error: GNUPGHOME directory does not exist: $GNUPGHOME"
        return 1
    fi

    # Verify key exists
    if ! gpg --homedir "$GNUPGHOME" --list-secret-keys "$fingerprint" &>/dev/null; then
        log "Error: Key not found: $fingerprint"
        return 1
    fi

    # Get key UID for directory naming
    local uid
    uid=$(gpg --homedir "$GNUPGHOME" --list-keys --with-colons "$fingerprint" 2>/dev/null | \
        awk -F: '/^uid:/ {print $10; exit}')

    # Create backup directory with date and short fingerprint
    local date_stamp
    date_stamp=$(date +%Y-%m-%d)
    local short_fp="${fingerprint: -8}"
    local backup_name="gpg-backup-${date_stamp}-${short_fp}"
    local backup_dir="${output_dir}/${backup_name}"

    # Create output and backup directories
    mkdir -p "$output_dir" || {
        log "Error: Failed to create output directory: $output_dir"
        return 1
    }

    mkdir -p "$backup_dir" || {
        log "Error: Failed to create backup directory: $backup_dir"
        return 1
    }
    chmod 700 "$backup_dir"

    log "Creating backup for key: ${fingerprint:0:16}..."
    log "Backup directory: $backup_dir"

    # Export files with proper permissions
    local export_cmd_base=(
        gpg --homedir "$GNUPGHOME" --armor
    )

    if [[ -n "$passphrase" ]]; then
        export_cmd_base+=(--batch --pinentry-mode loopback --passphrase "$passphrase")
    fi

    # 1. Export master secret key
    log "Exporting master key..."
    if ! "${export_cmd_base[@]}" --export-secret-keys "$fingerprint" > "$backup_dir/master-key.asc" 2>/dev/null; then
        log "Error: Failed to export master key"
        rm -rf "$backup_dir"
        return 1
    fi
    chmod 600 "$backup_dir/master-key.asc"

    # 2. Export secret subkeys only (for separate backup)
    log "Exporting subkeys..."
    if ! "${export_cmd_base[@]}" --export-secret-subkeys "$fingerprint" > "$backup_dir/subkeys.asc" 2>/dev/null; then
        log "Warning: No subkeys to export (may be master-only key)"
        rm -f "$backup_dir/subkeys.asc"
    else
        chmod 600 "$backup_dir/subkeys.asc"
    fi

    # 3. Export public key
    log "Exporting public key..."
    if ! gpg --homedir "$GNUPGHOME" --armor --export "$fingerprint" > "$backup_dir/public-key.asc" 2>/dev/null; then
        log "Error: Failed to export public key"
        rm -rf "$backup_dir"
        return 1
    fi

    # 4. Generate revocation certificate
    log "Generating revocation certificate..."
    local revoke_cmd=(gpg --homedir "$GNUPGHOME" --armor --output "$backup_dir/revocation-cert.asc")
    if [[ -n "$passphrase" ]]; then
        revoke_cmd+=(--batch --pinentry-mode loopback --passphrase "$passphrase")
    fi
    revoke_cmd+=(--gen-revoke "$fingerprint")

    # Generate revoke cert (requires answering 'y' and providing reason)
    if [[ -n "$passphrase" ]]; then
        echo -e "y\n0\n\ny\n" | "${revoke_cmd[@]}" 2>/dev/null || {
            log "Warning: Failed to generate revocation certificate"
            rm -f "$backup_dir/revocation-cert.asc"
        }
    else
        log "Skipping revocation cert generation (requires passphrase in batch mode)"
    fi

    if [[ -f "$backup_dir/revocation-cert.asc" ]]; then
        chmod 600 "$backup_dir/revocation-cert.asc"
    fi

    # 5. Export ownertrust
    log "Exporting trust database..."
    gpg --homedir "$GNUPGHOME" --export-ownertrust > "$backup_dir/ownertrust.txt" 2>/dev/null || true

    # 6. Generate README with restore instructions
    log "Generating restore instructions..."
    gpg-backup-readme-generate "$backup_dir" "$fingerprint" "$uid"

    # 7. Create encrypted archive
    log "Creating encrypted backup archive..."
    local encrypted_backup="${output_dir}/${backup_name}.tar.gz.gpg"

    local encrypt_cmd=(gpg --symmetric --cipher-algo AES256 --armor)
    if [[ -n "$backup_pass" ]]; then
        encrypt_cmd+=(--batch --pinentry-mode loopback --passphrase "$backup_pass")
    fi

    if ! tar -czf - -C "$output_dir" "$backup_name" | "${encrypt_cmd[@]}" > "$encrypted_backup" 2>/dev/null; then
        log "Error: Failed to create encrypted backup"
        rm -rf "$backup_dir"
        return 1
    fi
    chmod 600 "$encrypted_backup"

    # 8. Clean up unencrypted backup directory
    log "Cleaning up unencrypted files..."
    rm -rf "$backup_dir"

    log "Success: Backup created"
    echo "$encrypted_backup"
    return 0
}

gpg-backup-readme-generate() {
    # Generate README file with restore instructions
    #
    # Arguments:
    #   $1 - Backup directory path
    #   $2 - Key fingerprint
    #   $3 - User ID (optional)
    #
    # Returns:
    #   0 always

    local backup_dir="$1"
    local fingerprint="$2"
    local uid="${3:-}"
    local date_stamp
    date_stamp=$(date +%Y-%m-%d)

    cat > "$backup_dir/README.md" <<EOF
# GPG Key Backup

**Created:** ${date_stamp}
**Fingerprint:** ${fingerprint}
**User ID:** ${uid:-Unknown}

## Contents

- \`master-key.asc\` - Master (Certify) key and subkeys - **KEEP SECURE!**
- \`subkeys.asc\` - Secret subkeys only (Sign, Encrypt, Auth)
- \`public-key.asc\` - Public key for distribution
- \`revocation-cert.asc\` - Revocation certificate - **KEEP SECURE!**
- \`ownertrust.txt\` - GPG trust database
- \`README.md\` - This file

## Restore Instructions

### Full Restore (Master Key + Subkeys)

Use this when you need full access to your master key (e.g., for signing other keys,
creating new subkeys, or extending expiration).

\`\`\`bash
# 1. Create a secure ephemeral environment
export GNUPGHOME=\$(mktemp -d)
chmod 700 \$GNUPGHOME

# 2. Import the master key
gpg --import master-key.asc

# 3. Import trust settings
gpg --import-ownertrust ownertrust.txt

# 4. Verify import
gpg --list-secret-keys
\`\`\`

### Subkeys-Only Restore (Daily Use)

Use this to restore just the subkeys to your regular keyring.
The master key stays safely in backup.

\`\`\`bash
# 1. Import subkeys only
gpg --import subkeys.asc

# 2. Import trust settings
gpg --import-ownertrust ownertrust.txt

# 3. Verify import (should show 'sec#' for master - stub only)
gpg --list-secret-keys
\`\`\`

### Transfer to YubiKey

After restoring the master key, you can transfer subkeys to a YubiKey:

\`\`\`bash
keycutter gpg key install --fingerprint ${fingerprint}
\`\`\`

### Publish Public Key

To publish your public key to a keyserver:

\`\`\`bash
gpg --send-keys ${fingerprint}
\`\`\`

Or distribute \`public-key.asc\` directly.

## Security Notes

- **Master key** should only be accessed in air-gapped or ephemeral environments
- **Revocation certificate** can revoke your key - keep it separate and secure
- Store multiple copies in geographically separate secure locations
- Consider storing on encrypted USB drives or in secure cloud storage

## Decrypting This Backup

If you received this as an encrypted \`.tar.gz.gpg\` file:

\`\`\`bash
# Decrypt and extract
gpg --decrypt backup.tar.gz.gpg | tar -xzf -
\`\`\`

---
*Generated by keycutter gpg backup*
EOF

    return 0
}

gpg-master-keys-list() {
    # List available master keys from registered backup locations
    #
    # Searches for GPG key backups in registered locations and displays
    # information about available master keys.
    #
    # Returns:
    #   0 if keys found
    #   1 if no backup locations configured or no keys found

    # Load config to get backup locations
    gpg-config-load

    local backup_dir
    backup_dir=$(gpg-config-get GPG_BACKUP_DIR "")

    if [[ -z "$backup_dir" ]]; then
        echo "  No backup location configured."
        echo "  Set GPG_BACKUP_DIR in config or use 'keycutter gpg backup' to create backups."
        return 1
    fi

    # Expand path
    backup_dir="${backup_dir/#\~/$HOME}"

    if [[ ! -d "$backup_dir" ]]; then
        echo "  Backup directory not found: $backup_dir"
        return 1
    fi

    # Search for key files
    local found_keys=0
    local key_file keyid uid

    # Look for common backup patterns: *.asc, *.gpg, private-key*.asc
    for key_file in "$backup_dir"/*.asc "$backup_dir"/*.gpg "$backup_dir"/*/secret-key*.asc "$backup_dir"/*/master*.asc; do
        if [[ -f "$key_file" ]]; then
            # Extract key info using gpg --show-keys
            keyid=$(gpg --show-keys --with-colons "$key_file" 2>/dev/null | awk -F: '/^sec:/ {print $5; exit}')
            uid=$(gpg --show-keys --with-colons "$key_file" 2>/dev/null | awk -F: '/^uid:/ {print $10; exit}')

            if [[ -n "$keyid" ]]; then
                found_keys=$((found_keys + 1))
                echo "  $keyid"
                if [[ -n "$uid" ]]; then
                    echo "    └─ $uid"
                fi
                echo "    └─ $(basename "$key_file")"
                echo
            fi
        fi
    done

    if [[ $found_keys -eq 0 ]]; then
        echo "  No master keys found in: $backup_dir"
        return 1
    fi

    echo "  Found $found_keys master key(s)"
    return 0
}

# =============================================================================
# YubiKey Detection and Service Management (gpg-010)
# =============================================================================

gpg-pcscd-ensure() {
    # Ensure pcscd service is running (required for smartcard access)
    #
    # This function checks if pcscd is running and starts it if needed.
    # On macOS, pcscd is typically managed by the system.
    # On Linux, it may need to be started via systemctl or service.
    #
    # Returns:
    #   0 if pcscd is running or successfully started
    #   1 if pcscd cannot be started

    # Check if pcscd is needed - skip on macOS where it's automatic
    if [[ "$OSTYPE" == "darwin"* ]]; then
        # macOS handles smartcard daemon automatically
        return 0
    fi

    # On Linux, check and start pcscd if needed
    if command -v systemctl &>/dev/null; then
        if ! systemctl is-active --quiet pcscd; then
            log "Starting pcscd service..."
            if ! sudo systemctl start pcscd; then
                log "Error: Failed to start pcscd service"
                echo "Try: sudo systemctl start pcscd"
                return 1
            fi
            sleep 1
        fi
    elif command -v service &>/dev/null; then
        if ! service pcscd status &>/dev/null; then
            log "Starting pcscd service..."
            if ! sudo service pcscd start; then
                log "Error: Failed to start pcscd service"
                return 1
            fi
            sleep 1
        fi
    fi

    return 0
}

gpg-scdaemon-restart() {
    # Restart scdaemon to refresh smartcard connection
    #
    # scdaemon is the GPG smartcard daemon that communicates with the YubiKey.
    # Sometimes it needs to be restarted after the YubiKey is inserted or
    # after configuration changes.
    #
    # Returns:
    #   0 on success
    #   1 on failure

    local gpg_home="${GNUPGHOME:-$HOME/.gnupg}"

    log "Restarting scdaemon..."

    # Kill existing scdaemon
    gpgconf --kill scdaemon 2>/dev/null || true

    # Brief pause for cleanup
    sleep 0.5

    # Restart via gpg-connect-agent
    if ! gpg-connect-agent "SCD RESTART" /bye &>/dev/null; then
        # Try alternative method - just trigger card access
        gpg --card-status &>/dev/null || true
    fi

    sleep 0.5
    return 0
}

gpg-yubikey-detect() {
    # Detect YubiKey with OpenPGP application
    #
    # This function attempts to detect a YubiKey with OpenPGP support.
    # It uses retry logic since the YubiKey may take a moment to be recognized
    # after insertion.
    #
    # Arguments:
    #   --retries N   Number of retry attempts (default: 3)
    #   --delay N     Delay between retries in seconds (default: 2)
    #   --quiet       Suppress status messages
    #
    # Returns:
    #   0 if YubiKey with OpenPGP detected
    #   1 if no YubiKey found
    #
    # Output:
    #   Prints serial number on success (unless --quiet)

    local retries=3
    local delay=2
    local quiet=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --retries)
                retries="$2"
                shift 2
                ;;
            --delay)
                delay="$2"
                shift 2
                ;;
            --quiet)
                quiet=true
                shift
                ;;
            *)
                log "Error: Unknown option: $1"
                return 1
                ;;
        esac
    done

    # Ensure pcscd is running
    gpg-pcscd-ensure || return 1

    local attempt=1
    local card_status serial_number

    while [[ $attempt -le $retries ]]; do
        # Try to get card status
        if card_status=$(gpg --card-status 2>&1); then
            # Extract serial number
            serial_number=$(echo "$card_status" | grep "^Serial number" | awk '{print $NF}')

            if [[ -n "$serial_number" ]]; then
                if [[ "$quiet" != "true" ]]; then
                    log "YubiKey detected: $serial_number"
                fi
                echo "$serial_number"
                return 0
            fi
        fi

        # Not found yet
        if [[ "$quiet" != "true" && $attempt -lt $retries ]]; then
            log "Attempt $attempt/$retries: YubiKey not detected, retrying in ${delay}s..."
        fi

        if [[ $attempt -lt $retries ]]; then
            sleep "$delay"
            # Restart scdaemon between attempts
            gpg-scdaemon-restart &>/dev/null
        fi

        attempt=$((attempt + 1))
    done

    if [[ "$quiet" != "true" ]]; then
        log "Error: YubiKey with OpenPGP not detected"
        echo "Troubleshooting:"
        echo "  - Ensure YubiKey is inserted"
        echo "  - Try removing and reinserting the YubiKey"
        echo "  - Check: ykman list"
        echo "  - Check: gpg --card-status"
    fi
    return 1
}

gpg-yubikey-openpgp-enabled() {
    # Check if OpenPGP application is enabled on YubiKey
    #
    # Requires ykman (YubiKey Manager) to be installed.
    #
    # Returns:
    #   0 if OpenPGP is enabled
    #   1 if OpenPGP is disabled or ykman not available

    if ! command -v ykman &>/dev/null; then
        log "Warning: ykman not installed, cannot check OpenPGP status"
        # Fall back to gpg --card-status test
        if gpg --card-status &>/dev/null; then
            return 0
        fi
        return 1
    fi

    if ykman info 2>/dev/null | grep -q "OpenPGP.*Enabled"; then
        return 0
    else
        log "OpenPGP application is not enabled on YubiKey"
        echo "Enable with: ykman config usb --enable OPENPGP"
        return 1
    fi
}

gpg-card-has-keys() {
    # Check if the YubiKey already has GPG keys installed
    #
    # Returns:
    #   0 if keys are present
    #   1 if no keys or card not accessible
    #
    # Output:
    #   Prints "empty", "partial", or "full" to indicate key status

    local card_status
    card_status=$(gpg --card-status 2>&1) || return 1

    local sig_key enc_key auth_key
    sig_key=$(echo "$card_status" | grep "^Signature key" | grep -v "\[none\]")
    enc_key=$(echo "$card_status" | grep "^Encryption key" | grep -v "\[none\]")
    auth_key=$(echo "$card_status" | grep "^Authentication key" | grep -v "\[none\]")

    local key_count=0
    [[ -n "$sig_key" ]] && key_count=$((key_count + 1))
    [[ -n "$enc_key" ]] && key_count=$((key_count + 1))
    [[ -n "$auth_key" ]] && key_count=$((key_count + 1))

    if [[ $key_count -eq 0 ]]; then
        echo "empty"
        return 1
    elif [[ $key_count -eq 3 ]]; then
        echo "full"
        return 0
    else
        echo "partial"
        return 0
    fi
}

# =============================================================================
# PIN Management Functions (gpg-010)
# =============================================================================

gpg-pin-generate() {
    # Generate a secure random PIN
    #
    # Arguments:
    #   --length N    PIN length (default: 8 for admin, 6 for user)
    #   --type TYPE   "admin" (8 digits) or "user" (6 digits)
    #
    # Returns:
    #   0 on success
    #
    # Output:
    #   Prints the generated PIN

    local length=""
    local pin_type="user"

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --length)
                length="$2"
                shift 2
                ;;
            --type)
                pin_type="$2"
                shift 2
                ;;
            *)
                log "Error: Unknown option: $1"
                return 1
                ;;
        esac
    done

    # Set default length based on type
    if [[ -z "$length" ]]; then
        case "$pin_type" in
            admin) length=8 ;;
            user)  length=6 ;;
            *)
                log "Error: Unknown PIN type: $pin_type"
                return 1
                ;;
        esac
    fi

    # Generate random PIN using /dev/urandom
    local pin
    pin=$(LC_ALL=C tr -dc '0-9' < /dev/urandom | fold -w"$length" | head -1)

    echo "$pin"
    return 0
}

gpg-pin-change-admin() {
    # Change the YubiKey admin PIN
    #
    # The admin PIN is used for administrative operations like transferring
    # keys to the card. Default factory admin PIN is 12345678.
    #
    # Arguments:
    #   --old-pin PIN     Current admin PIN (default: 12345678)
    #   --new-pin PIN     New admin PIN (will prompt if not provided)
    #
    # Returns:
    #   0 on success
    #   1 on failure
    #
    # Note: Admin PIN must be 8-127 characters.
    #       3 incorrect attempts will DESTROY data on YubiKey!

    local old_pin="12345678"  # Factory default
    local new_pin=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --old-pin)
                old_pin="$2"
                shift 2
                ;;
            --new-pin)
                new_pin="$2"
                shift 2
                ;;
            *)
                log "Error: Unknown option: $1"
                return 1
                ;;
        esac
    done

    # Validate new PIN length
    if [[ -n "$new_pin" && ${#new_pin} -lt 8 ]]; then
        log "Error: Admin PIN must be at least 8 characters"
        return 1
    fi

    # Prompt for new PIN if not provided
    if [[ -z "$new_pin" ]]; then
        echo
        echo "Enter new admin PIN (minimum 8 characters):"
        read -rsp "  New admin PIN: " new_pin
        echo
        if [[ ${#new_pin} -lt 8 ]]; then
            log "Error: Admin PIN must be at least 8 characters"
            return 1
        fi
        local confirm_pin
        read -rsp "  Confirm PIN: " confirm_pin
        echo
        if [[ "$new_pin" != "$confirm_pin" ]]; then
            log "Error: PINs do not match"
            return 1
        fi
    fi

    log "Changing admin PIN..."

    # Use gpg --change-pin with command-fd for non-interactive operation
    # Menu option 3 = Change Admin PIN
    if echo -e "3\n${old_pin}\n${new_pin}\n${new_pin}\nq\n" | \
       gpg --command-fd=0 --pinentry-mode=loopback --change-pin 2>&1; then
        log "Success: Admin PIN changed"
        return 0
    else
        log "Error: Failed to change admin PIN"
        echo "Note: 3 incorrect admin PIN attempts will destroy data on YubiKey"
        return 1
    fi
}

gpg-pin-change-user() {
    # Change the YubiKey user PIN
    #
    # The user PIN is used for signing and decryption operations.
    # Default factory user PIN is 123456.
    #
    # Arguments:
    #   --old-pin PIN     Current user PIN (default: 123456)
    #   --new-pin PIN     New user PIN (will prompt if not provided)
    #
    # Returns:
    #   0 on success
    #   1 on failure
    #
    # Note: User PIN must be 6-127 characters.
    #       3 incorrect attempts will require admin PIN to unblock.

    local old_pin="123456"  # Factory default
    local new_pin=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --old-pin)
                old_pin="$2"
                shift 2
                ;;
            --new-pin)
                new_pin="$2"
                shift 2
                ;;
            *)
                log "Error: Unknown option: $1"
                return 1
                ;;
        esac
    done

    # Validate new PIN length
    if [[ -n "$new_pin" && ${#new_pin} -lt 6 ]]; then
        log "Error: User PIN must be at least 6 characters"
        return 1
    fi

    # Prompt for new PIN if not provided
    if [[ -z "$new_pin" ]]; then
        echo
        echo "Enter new user PIN (minimum 6 characters):"
        read -rsp "  New user PIN: " new_pin
        echo
        if [[ ${#new_pin} -lt 6 ]]; then
            log "Error: User PIN must be at least 6 characters"
            return 1
        fi
        local confirm_pin
        read -rsp "  Confirm PIN: " confirm_pin
        echo
        if [[ "$new_pin" != "$confirm_pin" ]]; then
            log "Error: PINs do not match"
            return 1
        fi
    fi

    log "Changing user PIN..."

    # Use gpg --change-pin with command-fd for non-interactive operation
    # Menu option 1 = Change User PIN
    if echo -e "1\n${old_pin}\n${new_pin}\n${new_pin}\nq\n" | \
       gpg --command-fd=0 --pinentry-mode=loopback --change-pin 2>&1; then
        log "Success: User PIN changed"
        return 0
    else
        log "Error: Failed to change user PIN"
        echo "Note: 3 incorrect user PIN attempts will require admin PIN to unblock"
        return 1
    fi
}

# =============================================================================
# Subkey Transfer to YubiKey (gpg-011)
# =============================================================================

gpg-key-to-yubikey() {
    # Transfer GPG subkeys to YubiKey
    #
    # This function transfers the Sign, Encrypt, and Auth subkeys from the
    # current GNUPGHOME to a YubiKey. After transfer, the local keys become
    # stubs pointing to the hardware device.
    #
    # Arguments:
    #   --fingerprint FP    Master key fingerprint (required)
    #   --passphrase PASS   Key passphrase (required)
    #   --admin-pin PIN     YubiKey admin PIN (default: 12345678)
    #   --force             Overwrite existing keys on YubiKey
    #
    # Returns:
    #   0 on success (all 3 subkeys transferred)
    #   1 on failure
    #
    # Environment:
    #   GNUPGHOME must be set and contain the keys to transfer
    #
    # Note:
    #   - This is a ONE-WAY operation - keys cannot be extracted from YubiKey
    #   - The local keyring will contain stubs after transfer
    #   - Ensure you have a backup before proceeding!
    #
    # Example:
    #   gpg-key-to-yubikey --fingerprint "$FP" --passphrase "$PASS"

    local fingerprint=""
    local passphrase=""
    local admin_pin="12345678"  # Factory default
    local force=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --fingerprint)
                fingerprint="$2"
                shift 2
                ;;
            --passphrase)
                passphrase="$2"
                shift 2
                ;;
            --admin-pin)
                admin_pin="$2"
                shift 2
                ;;
            --force)
                force=true
                shift
                ;;
            *)
                log "Error: Unknown option: $1"
                return 1
                ;;
        esac
    done

    # Validate required parameters
    if [[ -z "$fingerprint" ]]; then
        log "Error: --fingerprint is required"
        return 1
    fi

    if [[ -z "$passphrase" ]]; then
        log "Error: --passphrase is required"
        return 1
    fi

    # Validate GNUPGHOME
    if [[ -z "${GNUPGHOME:-}" ]]; then
        log "Error: GNUPGHOME not set"
        return 1
    fi

    if [[ ! -d "$GNUPGHOME" ]]; then
        log "Error: GNUPGHOME directory does not exist: $GNUPGHOME"
        return 1
    fi

    # Verify key exists in GNUPGHOME
    if ! gpg --homedir "$GNUPGHOME" --list-secret-keys "$fingerprint" &>/dev/null; then
        log "Error: Key not found in GNUPGHOME: $fingerprint"
        return 1
    fi

    # Check YubiKey status
    if ! gpg-yubikey-detect --quiet &>/dev/null; then
        log "Error: No YubiKey detected"
        return 1
    fi

    # Check if YubiKey already has keys
    local card_status
    card_status=$(gpg-card-has-keys 2>/dev/null) || true

    if [[ "$card_status" == "full" && "$force" != "true" ]]; then
        log "Error: YubiKey already has GPG keys installed"
        echo "Use --force to overwrite, or reset the card first:"
        echo "  keycutter gpg card reset"
        return 1
    fi

    if [[ "$card_status" == "partial" && "$force" != "true" ]]; then
        log "Error: YubiKey has some keys installed"
        echo "Use --force to overwrite, or reset the card first:"
        echo "  keycutter gpg card reset"
        return 1
    fi

    # Count subkeys to verify we have all three
    local subkey_count
    subkey_count=$(gpg --homedir "$GNUPGHOME" --list-secret-keys --with-colons "$fingerprint" 2>/dev/null | grep -c "^ssb:")

    if [[ $subkey_count -lt 3 ]]; then
        log "Error: Expected 3 subkeys, found $subkey_count"
        echo "Create subkeys first with: keycutter gpg key create --subkeys --fingerprint $fingerprint"
        return 1
    fi

    log "Transferring subkeys to YubiKey..."
    log "Fingerprint: ${fingerprint:0:16}..."

    # Get subkey capabilities to determine transfer order
    # We need to identify which subkey is Sign [S], Encrypt [E], Auth [A]
    local subkey_info
    subkey_info=$(gpg --homedir "$GNUPGHOME" --list-secret-keys --with-colons "$fingerprint" 2>/dev/null | grep "^ssb:")

    # Parse subkeys and their capabilities
    # Format: ssb:u:256:22:KEYID:created:expires::::s::
    # The 12th field contains capabilities: s=sign, e=encrypt, a=auth
    local sign_keynum=0 encrypt_keynum=0 auth_keynum=0
    local keynum=1

    while IFS=: read -r type trust keylen algo keyid created expires _ _ _ _ caps _; do
        if [[ "$type" == "ssb" ]]; then
            case "$caps" in
                *s*) sign_keynum=$keynum ;;
                *e*) encrypt_keynum=$keynum ;;
                *a*) auth_keynum=$keynum ;;
            esac
            keynum=$((keynum + 1))
        fi
    done <<< "$subkey_info"

    # Verify we found all three
    if [[ $sign_keynum -eq 0 || $encrypt_keynum -eq 0 || $auth_keynum -eq 0 ]]; then
        log "Error: Could not identify all subkey types"
        log "Sign: $sign_keynum, Encrypt: $encrypt_keynum, Auth: $auth_keynum"
        return 1
    fi

    log "Found subkeys - Sign: key $sign_keynum, Encrypt: key $encrypt_keynum, Auth: key $auth_keynum"

    # Transfer each subkey to corresponding YubiKey slot
    # Slot 1 = Signature, Slot 2 = Encryption, Slot 3 = Authentication
    local transfers=("$sign_keynum:1:Signature" "$encrypt_keynum:2:Encryption" "$auth_keynum:3:Authentication")
    local transferred=0

    for transfer in "${transfers[@]}"; do
        local keynum="${transfer%%:*}"
        local rest="${transfer#*:}"
        local slot="${rest%%:*}"
        local name="${rest#*:}"

        log "Transferring $name subkey (key $keynum) to slot $slot..."

        # Build the command sequence for gpg --edit-key
        # Commands: key N -> keytocard -> slot -> passphrase -> admin_pin -> save
        local gpg_commands="key ${keynum}
keytocard
${slot}
${passphrase}
${admin_pin}
save
"

        # Execute transfer
        if echo -e "$gpg_commands" | \
           gpg --homedir "$GNUPGHOME" \
               --command-fd=0 \
               --pinentry-mode loopback \
               --expert \
               --edit-key "$fingerprint" 2>&1 | grep -q "Error\|failed\|No such"; then
            log "Error: Failed to transfer $name subkey"
            return 1
        fi

        log "Success: $name subkey transferred to slot $slot"
        transferred=$((transferred + 1))
    done

    if [[ $transferred -ne 3 ]]; then
        log "Error: Only $transferred of 3 subkeys transferred"
        return 1
    fi

    # Verify transfer by checking card status
    log "Verifying transfer..."
    gpg-scdaemon-restart &>/dev/null
    sleep 1

    local verify_status
    verify_status=$(gpg-card-has-keys 2>/dev/null) || true

    if [[ "$verify_status" != "full" ]]; then
        log "Warning: Card verification shows status: $verify_status"
        log "Some keys may not have transferred correctly"
    fi

    log "Success: All subkeys transferred to YubiKey"
    echo
    echo "Your subkeys are now on the YubiKey. The local keyring contains stubs."
    echo "To verify: gpg --card-status"

    return 0
}

gpg-card-reset() {
    # Reset GPG keys on YubiKey (preserves other YubiKey settings)
    #
    # This function resets only the OpenPGP application on the YubiKey,
    # removing all GPG keys but preserving other settings and applications.
    #
    # Arguments:
    #   --force   Skip confirmation prompt
    #
    # Returns:
    #   0 on success
    #   1 on failure or user cancellation
    #
    # WARNING: This will delete all GPG keys on the YubiKey!

    local force=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --force)
                force=true
                shift
                ;;
            *)
                log "Error: Unknown option: $1"
                return 1
                ;;
        esac
    done

    # Detect YubiKey first
    if ! gpg-yubikey-detect --quiet &>/dev/null; then
        log "Error: No YubiKey detected"
        return 1
    fi

    # Confirmation prompt
    if [[ "$force" != "true" ]]; then
        echo
        echo "WARNING: This will delete ALL GPG keys on the YubiKey!"
        echo "This action cannot be undone."
        echo
        read -rp "Type 'RESET' to confirm: " confirm
        if [[ "$confirm" != "RESET" ]]; then
            log "Reset cancelled"
            return 1
        fi
    fi

    log "Resetting OpenPGP application on YubiKey..."

    # Prefer ykman if available (more reliable)
    if command -v ykman &>/dev/null; then
        if ykman openpgp reset --force 2>&1; then
            log "Success: OpenPGP application reset"
            echo "Default PINs have been restored:"
            echo "  User PIN:  123456"
            echo "  Admin PIN: 12345678"
            return 0
        else
            log "Error: Failed to reset OpenPGP application"
            return 1
        fi
    fi

    # Fall back to gpg-connect-agent method
    log "Using gpg-connect-agent to reset (ykman not available)..."

    # This sequence intentionally triggers PIN lockout to force reset
    # Ref: https://github.com/drduh/YubiKey-Guide
    if gpg-connect-agent -r <<'EOF' 2>&1
/hex
scd serialno
scd apdu 00 20 00 81 08 40 40 40 40 40 40 40 40
scd apdu 00 20 00 81 08 40 40 40 40 40 40 40 40
scd apdu 00 20 00 81 08 40 40 40 40 40 40 40 40
scd apdu 00 20 00 81 08 40 40 40 40 40 40 40 40
scd apdu 00 20 00 83 08 40 40 40 40 40 40 40 40
scd apdu 00 20 00 83 08 40 40 40 40 40 40 40 40
scd apdu 00 20 00 83 08 40 40 40 40 40 40 40 40
scd apdu 00 20 00 83 08 40 40 40 40 40 40 40 40
scd apdu 00 e6 00 00
scd apdu 00 44 00 00
/echo Card has been reset
/bye
EOF
    then
        log "Success: OpenPGP application reset"
        echo "Default PINs have been restored:"
        echo "  User PIN:  123456"
        echo "  Admin PIN: 12345678"

        # Restart scdaemon to pick up changes
        gpg-scdaemon-restart

        return 0
    else
        log "Error: Failed to reset OpenPGP application"
        return 1
    fi
}

# =============================================================================
# Host Setup Functions (gpg-013)
# =============================================================================

gpg-setup-detect-os() {
    # Detect the operating system for package installation
    #
    # Returns:
    #   0 always
    #
    # Output:
    #   Prints one of: macos, ubuntu, debian, fedora, rhel, unknown

    if [[ "$OSTYPE" == "darwin"* ]]; then
        echo "macos"
    elif [[ -f /etc/os-release ]]; then
        # Source the file to get distro info
        local id
        id=$(grep "^ID=" /etc/os-release | cut -d= -f2 | tr -d '"')
        case "$id" in
            ubuntu)     echo "ubuntu" ;;
            debian)     echo "debian" ;;
            fedora)     echo "fedora" ;;
            rhel|centos|rocky|alma) echo "rhel" ;;
            *)          echo "unknown" ;;
        esac
    else
        echo "unknown"
    fi
}

gpg-setup-check-packages() {
    # Check if required GPG packages are installed
    #
    # Arguments:
    #   --os OS    Operating system (auto-detected if not provided)
    #
    # Returns:
    #   0 if all packages installed
    #   1 if some packages missing
    #
    # Output:
    #   Prints missing packages (one per line)

    local os=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --os)
                os="$2"
                shift 2
                ;;
            *)
                log "Error: Unknown option: $1"
                return 1
                ;;
        esac
    done

    # Auto-detect OS if not provided
    if [[ -z "$os" ]]; then
        os=$(gpg-setup-detect-os)
    fi

    local missing=()

    case "$os" in
        macos)
            # Check for Homebrew packages
            command -v gpg &>/dev/null || missing+=("gnupg")
            command -v ykman &>/dev/null || missing+=("ykman")
            # Check for pinentry-mac
            if [[ ! -f "/opt/homebrew/bin/pinentry-mac" ]] && \
               [[ ! -f "/usr/local/bin/pinentry-mac" ]]; then
                missing+=("pinentry-mac")
            fi
            ;;
        ubuntu|debian)
            # Check for apt packages
            command -v gpg &>/dev/null || missing+=("gnupg2")
            command -v gpg-agent &>/dev/null || missing+=("gnupg-agent")
            command -v scdaemon &>/dev/null || missing+=("scdaemon")
            command -v pcscd &>/dev/null || missing+=("pcscd")
            command -v ykman &>/dev/null || missing+=("yubikey-manager")
            # Check for pinentry
            if ! command -v pinentry &>/dev/null && \
               ! command -v pinentry-gnome3 &>/dev/null && \
               ! command -v pinentry-curses &>/dev/null; then
                missing+=("pinentry-gnome3")
            fi
            ;;
        fedora|rhel)
            # Check for dnf packages
            command -v gpg &>/dev/null || missing+=("gnupg2")
            command -v scdaemon &>/dev/null || missing+=("gnupg2-smime")
            command -v pcscd &>/dev/null || missing+=("pcsc-lite")
            command -v ykman &>/dev/null || missing+=("yubikey-manager")
            # Check for pinentry
            if ! command -v pinentry &>/dev/null && \
               ! command -v pinentry-gnome3 &>/dev/null; then
                missing+=("pinentry")
            fi
            ;;
        *)
            log "Warning: Unknown OS, cannot check packages"
            return 1
            ;;
    esac

    if [[ ${#missing[@]} -gt 0 ]]; then
        for pkg in "${missing[@]}"; do
            echo "$pkg"
        done
        return 1
    fi

    return 0
}

gpg-setup-install-packages() {
    # Install required GPG packages for the current OS
    #
    # Arguments:
    #   --os OS      Operating system (auto-detected if not provided)
    #   --yes        Skip confirmation prompts
    #
    # Returns:
    #   0 on success
    #   1 on failure

    local os=""
    local auto_confirm=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --os)
                os="$2"
                shift 2
                ;;
            --yes)
                auto_confirm=true
                shift
                ;;
            *)
                log "Error: Unknown option: $1"
                return 1
                ;;
        esac
    done

    # Auto-detect OS if not provided
    if [[ -z "$os" ]]; then
        os=$(gpg-setup-detect-os)
    fi

    # Check what's missing
    local missing
    missing=$(gpg-setup-check-packages --os "$os" 2>/dev/null) || true

    if [[ -z "$missing" ]]; then
        log "All required packages are already installed"
        return 0
    fi

    log "Missing packages: $(echo "$missing" | tr '\n' ' ')"

    # Confirm installation
    if [[ "$auto_confirm" != "true" ]]; then
        read -rp "Install missing packages? [Y/n] " confirm
        if [[ "$confirm" =~ ^[Nn] ]]; then
            log "Package installation skipped"
            return 1
        fi
    fi

    case "$os" in
        macos)
            if ! command -v brew &>/dev/null; then
                log "Error: Homebrew not installed"
                echo "Install Homebrew first: https://brew.sh"
                return 1
            fi

            log "Installing packages via Homebrew..."
            local pkg
            for pkg in $(echo "$missing"); do
                log "Installing $pkg..."
                if ! brew install "$pkg"; then
                    log "Error: Failed to install $pkg"
                    return 1
                fi
            done
            ;;

        ubuntu|debian)
            log "Installing packages via apt..."
            if ! sudo apt-get update; then
                log "Error: apt-get update failed"
                return 1
            fi
            local packages
            packages=$(echo "$missing" | tr '\n' ' ')
            if ! sudo apt-get install -y $packages; then
                log "Error: apt-get install failed"
                return 1
            fi
            ;;

        fedora|rhel)
            log "Installing packages via dnf..."
            local packages
            packages=$(echo "$missing" | tr '\n' ' ')
            if ! sudo dnf install -y $packages; then
                log "Error: dnf install failed"
                return 1
            fi
            ;;

        *)
            log "Error: Unsupported OS for automatic package installation"
            return 1
            ;;
    esac

    log "Success: Packages installed"
    return 0
}

gpg-setup-pinentry-path() {
    # Get the path to the appropriate pinentry program
    #
    # Arguments:
    #   --os OS    Operating system (auto-detected if not provided)
    #
    # Returns:
    #   0 on success
    #   1 if no pinentry found
    #
    # Output:
    #   Prints the path to pinentry program

    local os=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --os)
                os="$2"
                shift 2
                ;;
            *)
                log "Error: Unknown option: $1"
                return 1
                ;;
        esac
    done

    # Auto-detect OS if not provided
    if [[ -z "$os" ]]; then
        os=$(gpg-setup-detect-os)
    fi

    case "$os" in
        macos)
            # Prefer Apple Silicon path, fall back to Intel
            if [[ -f "/opt/homebrew/bin/pinentry-mac" ]]; then
                echo "/opt/homebrew/bin/pinentry-mac"
            elif [[ -f "/usr/local/bin/pinentry-mac" ]]; then
                echo "/usr/local/bin/pinentry-mac"
            else
                log "Error: pinentry-mac not found"
                return 1
            fi
            ;;

        ubuntu|debian|fedora|rhel)
            # Try various pinentry options in order of preference
            if command -v pinentry-gnome3 &>/dev/null; then
                command -v pinentry-gnome3
            elif command -v pinentry-gtk-2 &>/dev/null; then
                command -v pinentry-gtk-2
            elif command -v pinentry-curses &>/dev/null; then
                command -v pinentry-curses
            elif command -v pinentry &>/dev/null; then
                command -v pinentry
            else
                log "Error: No pinentry program found"
                return 1
            fi
            ;;

        *)
            # Fall back to generic pinentry search
            if command -v pinentry &>/dev/null; then
                command -v pinentry
            else
                log "Error: pinentry not found"
                return 1
            fi
            ;;
    esac

    return 0
}

gpg-setup-gpg-agent-conf() {
    # Configure gpg-agent with recommended settings
    #
    # Arguments:
    #   --enable-ssh    Enable SSH support in gpg-agent
    #   --pinentry PATH Path to pinentry program (auto-detected if not provided)
    #   --backup        Backup existing config before overwriting
    #
    # Returns:
    #   0 on success
    #   1 on failure
    #
    # Creates/updates ~/.gnupg/gpg-agent.conf with:
    #   - pinentry-program
    #   - enable-ssh-support (if --enable-ssh)
    #   - allow-loopback-pinentry (for batch operations)
    #   - default-cache-ttl and max-cache-ttl settings

    local enable_ssh=false
    local pinentry_path=""
    local backup=false
    local gpg_home="${GNUPGHOME:-$HOME/.gnupg}"

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --enable-ssh)
                enable_ssh=true
                shift
                ;;
            --pinentry)
                pinentry_path="$2"
                shift 2
                ;;
            --backup)
                backup=true
                shift
                ;;
            *)
                log "Error: Unknown option: $1"
                return 1
                ;;
        esac
    done

    # Ensure gpg home directory exists
    if [[ ! -d "$gpg_home" ]]; then
        mkdir -p "$gpg_home"
        chmod 700 "$gpg_home"
    fi

    # Auto-detect pinentry if not provided
    if [[ -z "$pinentry_path" ]]; then
        pinentry_path=$(gpg-setup-pinentry-path 2>/dev/null) || {
            log "Warning: Could not detect pinentry program"
            pinentry_path=""
        }
    fi

    local agent_conf="$gpg_home/gpg-agent.conf"

    # Backup existing config
    if [[ "$backup" == "true" ]] && [[ -f "$agent_conf" ]]; then
        local backup_file="${agent_conf}.backup.$(date +%Y%m%d%H%M%S)"
        cp "$agent_conf" "$backup_file"
        log "Backed up existing config to: $backup_file"
    fi

    log "Configuring gpg-agent..."

    # Write new configuration
    {
        echo "# gpg-agent configuration"
        echo "# Generated by keycutter gpg setup"
        echo ""

        if [[ -n "$pinentry_path" ]]; then
            echo "# Pinentry program for passphrase prompts"
            echo "pinentry-program $pinentry_path"
            echo ""
        fi

        if [[ "$enable_ssh" == "true" ]]; then
            echo "# Enable SSH key support"
            echo "enable-ssh-support"
            echo ""
        fi

        echo "# Allow passphrase input via loopback for scripted operations"
        echo "allow-loopback-pinentry"
        echo ""

        echo "# Cache settings (in seconds)"
        echo "# Note: These don't apply when using YubiKey (PIN caching is handled by the card)"
        echo "default-cache-ttl 600"
        echo "max-cache-ttl 7200"
        echo ""

        echo "# Cache settings for SSH keys"
        echo "default-cache-ttl-ssh 600"
        echo "max-cache-ttl-ssh 7200"
    } > "$agent_conf"

    chmod 600 "$agent_conf"
    log "Success: gpg-agent.conf configured at $agent_conf"

    return 0
}

gpg-setup-gpg-conf() {
    # Install hardened gpg.conf from keycutter templates
    #
    # Arguments:
    #   --backup    Backup existing config before overwriting
    #
    # Returns:
    #   0 on success
    #   1 on failure

    local backup=false
    local gpg_home="${GNUPGHOME:-$HOME/.gnupg}"

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --backup)
                backup=true
                shift
                ;;
            *)
                log "Error: Unknown option: $1"
                return 1
                ;;
        esac
    done

    # Ensure gpg home directory exists
    if [[ ! -d "$gpg_home" ]]; then
        mkdir -p "$gpg_home"
        chmod 700 "$gpg_home"
    fi

    local gpg_conf="$gpg_home/gpg.conf"
    local template="${KEYCUTTER_ROOT}/config/gpg/gpg.conf"

    if [[ ! -f "$template" ]]; then
        log "Error: GPG config template not found: $template"
        return 1
    fi

    # Backup existing config
    if [[ "$backup" == "true" ]] && [[ -f "$gpg_conf" ]]; then
        local backup_file="${gpg_conf}.backup.$(date +%Y%m%d%H%M%S)"
        cp "$gpg_conf" "$backup_file"
        log "Backed up existing config to: $backup_file"
    fi

    log "Installing hardened gpg.conf..."

    # Copy template to gpg home
    cp "$template" "$gpg_conf"
    chmod 600 "$gpg_conf"

    log "Success: gpg.conf installed at $gpg_conf"
    return 0
}

gpg-setup-test() {
    # Test that GPG setup is working correctly
    #
    # Returns:
    #   0 if all tests pass
    #   1 if any test fails
    #
    # Tests:
    #   1. GPG version check
    #   2. gpg-agent connectivity
    #   3. YubiKey detection (optional)
    #   4. SSH socket available (if SSH support enabled)

    local all_passed=true
    local gpg_home="${GNUPGHOME:-$HOME/.gnupg}"

    log "Testing GPG setup..."
    echo

    # Test 1: GPG version
    echo -n "  [1/4] GPG version: "
    local gpg_version
    if gpg_version=$(gpg-version-check 2>/dev/null); then
        echo "✓ $gpg_version"
    else
        echo "✗ GPG not found or version too old"
        all_passed=false
    fi

    # Test 2: gpg-agent connectivity
    echo -n "  [2/4] gpg-agent: "
    if gpg-connect-agent /bye &>/dev/null; then
        echo "✓ running"
    else
        echo "✗ not running"
        all_passed=false
    fi

    # Test 3: YubiKey detection (optional - don't fail if not present)
    echo -n "  [3/4] YubiKey: "
    if gpg --card-status &>/dev/null; then
        local serial
        serial=$(gpg --card-status 2>/dev/null | grep "^Serial number" | awk '{print $NF}')
        echo "✓ detected ($serial)"
    else
        echo "- not detected (optional)"
    fi

    # Test 4: SSH socket
    echo -n "  [4/4] SSH socket: "
    local ssh_socket
    ssh_socket=$(gpgconf --list-dirs agent-ssh-socket 2>/dev/null)
    if [[ -S "$ssh_socket" ]]; then
        echo "✓ $ssh_socket"
    elif [[ -n "$ssh_socket" ]]; then
        echo "- configured but not active"
    else
        echo "- not configured"
    fi

    echo

    if [[ "$all_passed" == "true" ]]; then
        log "All tests passed"
        return 0
    else
        log "Some tests failed - GPG may not work correctly"
        return 1
    fi
}

gpg-setup-macos-launchagent() {
    # Set up macOS LaunchAgents for gpg-agent
    #
    # Creates LaunchAgent plists to:
    #   1. Start gpg-agent at login
    #   2. Create SSH socket symlink for compatibility
    #
    # Arguments:
    #   --uninstall    Remove LaunchAgents instead of installing
    #
    # Returns:
    #   0 on success
    #   1 on failure

    local uninstall=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --uninstall)
                uninstall=true
                shift
                ;;
            *)
                log "Error: Unknown option: $1"
                return 1
                ;;
        esac
    done

    local launch_agents_dir="$HOME/Library/LaunchAgents"
    local agent_plist="$launch_agents_dir/gnupg.gpg-agent.plist"
    local symlink_plist="$launch_agents_dir/gnupg.gpg-agent-symlink.plist"

    if [[ "$uninstall" == "true" ]]; then
        log "Removing LaunchAgents..."
        launchctl unload "$agent_plist" 2>/dev/null || true
        launchctl unload "$symlink_plist" 2>/dev/null || true
        rm -f "$agent_plist" "$symlink_plist"
        log "Success: LaunchAgents removed"
        return 0
    fi

    # Create LaunchAgents directory if needed
    mkdir -p "$launch_agents_dir"

    log "Installing macOS LaunchAgents..."

    # LaunchAgent for gpg-agent startup
    cat > "$agent_plist" <<'EOF'
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>gnupg.gpg-agent</string>
    <key>RunAtLoad</key>
    <true/>
    <key>KeepAlive</key>
    <false/>
    <key>ProgramArguments</key>
    <array>
        <string>/bin/bash</string>
        <string>-c</string>
        <string>gpg-connect-agent /bye</string>
    </array>
</dict>
</plist>
EOF

    # LaunchAgent for SSH socket symlink (for graphical apps)
    cat > "$symlink_plist" <<EOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>gnupg.gpg-agent-symlink</string>
    <key>RunAtLoad</key>
    <true/>
    <key>KeepAlive</key>
    <false/>
    <key>ProgramArguments</key>
    <array>
        <string>/bin/bash</string>
        <string>-c</string>
        <string>/bin/ln -sf "\$(gpgconf --list-dirs agent-ssh-socket)" "\$HOME/.gnupg/S.gpg-agent.ssh"</string>
    </array>
</dict>
</plist>
EOF

    # Load the agents
    launchctl unload "$agent_plist" 2>/dev/null || true
    launchctl unload "$symlink_plist" 2>/dev/null || true
    launchctl load "$agent_plist"
    launchctl load "$symlink_plist"

    log "Success: LaunchAgents installed"
    return 0
}

gpg-setup-shell-config() {
    # Show shell configuration recommendations
    #
    # Arguments:
    #   --os OS    Operating system (auto-detected if not provided)
    #
    # Returns:
    #   0 always
    #
    # Output:
    #   Prints shell configuration commands for the user's shell

    local os=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --os)
                os="$2"
                shift 2
                ;;
            *)
                log "Error: Unknown option: $1"
                return 1
                ;;
        esac
    done

    # Auto-detect OS if not provided
    if [[ -z "$os" ]]; then
        os=$(gpg-setup-detect-os)
    fi

    echo
    echo "Add the following to your shell profile (~/.bashrc or ~/.zshrc):"
    echo

    case "$os" in
        macos)
            cat <<'EOF'
# GPG Agent configuration
export GPG_TTY=$(tty)

# Use gpg-agent for SSH (optional - uncomment if you want GPG to handle SSH keys)
# export SSH_AUTH_SOCK=$(gpgconf --list-dirs agent-ssh-socket)
EOF
            ;;

        ubuntu|debian|fedora|rhel)
            cat <<'EOF'
# GPG Agent configuration
export GPG_TTY=$(tty)

# Ensure gpg-agent is running
gpg-connect-agent updatestartuptty /bye >/dev/null 2>&1

# Use gpg-agent for SSH (optional - uncomment if you want GPG to handle SSH keys)
# export SSH_AUTH_SOCK=$(gpgconf --list-dirs agent-ssh-socket)
EOF
            ;;

        *)
            cat <<'EOF'
# GPG Agent configuration
export GPG_TTY=$(tty)
EOF
            ;;
    esac

    echo
    return 0
}

# =============================================================================
# Backup Listing and Restoration (gpg-012)
# =============================================================================

gpg-backup-list() {
    # List available GPG key backups from registered locations
    #
    # This function searches for encrypted backup files in the configured
    # backup directory and extracts key information from them.
    #
    # Arguments:
    #   --quiet    Only output backup paths (for scripting)
    #
    # Returns:
    #   0 if backups found
    #   1 if no backup location configured or no backups found
    #
    # Output:
    #   Prints list of backups with fingerprints and user IDs

    local quiet=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --quiet)
                quiet=true
                shift
                ;;
            *)
                log "Error: Unknown option: $1"
                return 1
                ;;
        esac
    done

    # Load config to get backup locations
    gpg-config-load

    local backup_dir
    backup_dir=$(gpg-config-get GPG_BACKUP_DIR "")

    if [[ -z "$backup_dir" ]]; then
        if [[ "$quiet" != "true" ]]; then
            echo "  No backup location configured."
            echo "  Set GPG_BACKUP_DIR in config or use 'keycutter gpg backup' to create backups."
        fi
        return 1
    fi

    # Expand path
    backup_dir="${backup_dir/#\~/$HOME}"

    if [[ ! -d "$backup_dir" ]]; then
        if [[ "$quiet" != "true" ]]; then
            echo "  Backup directory not found: $backup_dir"
        fi
        return 1
    fi

    # Search for encrypted backup files
    local found_backups=0
    local backup_file backup_name fingerprint uid
    local -a backup_list=()

    # Look for encrypted backup pattern: gpg-backup-*.tar.gz.gpg
    for backup_file in "$backup_dir"/gpg-backup-*.tar.gz.gpg; do
        if [[ -f "$backup_file" ]]; then
            found_backups=$((found_backups + 1))
            backup_list+=("$backup_file")

            if [[ "$quiet" != "true" ]]; then
                # Extract info from filename
                # Format: gpg-backup-YYYY-MM-DD-FINGERPRINT.tar.gz.gpg
                backup_name=$(basename "$backup_file")
                # Remove extensions to get base name
                backup_name="${backup_name%.tar.gz.gpg}"

                # Extract fingerprint (last 8 chars before extension)
                fingerprint="${backup_name##*-}"

                # Extract date
                local backup_date
                backup_date=$(echo "$backup_name" | grep -oE '[0-9]{4}-[0-9]{2}-[0-9]{2}' || echo "unknown")

                echo "  [$found_backups] $backup_file"
                echo "      Fingerprint: ...${fingerprint}"
                echo "      Created: $backup_date"
                echo
            else
                echo "$backup_file"
            fi
        fi
    done

    if [[ $found_backups -eq 0 ]]; then
        if [[ "$quiet" != "true" ]]; then
            echo "  No backup files found in: $backup_dir"
            echo "  Create a backup with: keycutter gpg backup"
        fi
        return 1
    fi

    if [[ "$quiet" != "true" ]]; then
        echo "  Found $found_backups backup(s) in: $backup_dir"
    fi
    return 0
}

gpg-backup-restore() {
    # Restore GPG keys from an encrypted backup to ephemeral GNUPGHOME
    #
    # This function decrypts a backup archive and imports the master key
    # and subkeys into the current (ephemeral) GNUPGHOME.
    #
    # Arguments:
    #   --backup-file FILE    Path to encrypted backup (required)
    #   --backup-pass PASS    Passphrase for backup decryption (will prompt if not provided)
    #
    # Returns:
    #   0 on success
    #   1 on failure
    #
    # Output:
    #   Prints the fingerprint of the restored key on success
    #
    # Environment:
    #   GNUPGHOME must be set (typically to ephemeral directory)
    #
    # Example:
    #   gpg-home-temp-create
    #   gpg-backup-restore --backup-file ~/gpg-backups/gpg-backup-2025-01-01-ABCD1234.tar.gz.gpg

    local backup_file=""
    local backup_pass=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --backup-file)
                backup_file="$2"
                shift 2
                ;;
            --backup-pass)
                backup_pass="$2"
                shift 2
                ;;
            *)
                log "Error: Unknown option: $1"
                return 1
                ;;
        esac
    done

    # Validate required parameters
    if [[ -z "$backup_file" ]]; then
        log "Error: --backup-file is required"
        return 1
    fi

    if [[ ! -f "$backup_file" ]]; then
        log "Error: Backup file not found: $backup_file"
        return 1
    fi

    # Validate GNUPGHOME
    if [[ -z "${GNUPGHOME:-}" ]]; then
        log "Error: GNUPGHOME not set. Use gpg-home-temp-create first."
        return 1
    fi

    if [[ ! -d "$GNUPGHOME" ]]; then
        log "Error: GNUPGHOME directory does not exist: $GNUPGHOME"
        return 1
    fi

    # Create temporary directory for extraction
    local temp_extract
    temp_extract=$(mktemp -d) || {
        log "Error: Failed to create temporary directory"
        return 1
    }
    chmod 700 "$temp_extract"

    # Cleanup on exit
    trap "rm -rf '$temp_extract'" RETURN

    log "Decrypting backup: $(basename "$backup_file")..."

    # Decrypt the backup
    local decrypt_cmd=(gpg --decrypt --quiet)
    if [[ -n "$backup_pass" ]]; then
        decrypt_cmd+=(--batch --pinentry-mode loopback --passphrase "$backup_pass")
    fi

    if ! "${decrypt_cmd[@]}" "$backup_file" 2>/dev/null | tar -xzf - -C "$temp_extract" 2>/dev/null; then
        log "Error: Failed to decrypt backup"
        log "Check that the backup passphrase is correct"
        return 1
    fi

    # Find the extracted backup directory
    local extracted_dir
    extracted_dir=$(find "$temp_extract" -maxdepth 1 -type d -name "gpg-backup-*" | head -1)

    if [[ -z "$extracted_dir" ]] || [[ ! -d "$extracted_dir" ]]; then
        log "Error: Could not find backup contents after extraction"
        return 1
    fi

    # Look for the master key file
    local master_key_file=""
    if [[ -f "$extracted_dir/master-key.asc" ]]; then
        master_key_file="$extracted_dir/master-key.asc"
    elif [[ -f "$extracted_dir/secret-key.asc" ]]; then
        master_key_file="$extracted_dir/secret-key.asc"
    fi

    if [[ -z "$master_key_file" ]]; then
        log "Error: No master key file found in backup"
        log "Expected: master-key.asc or secret-key.asc"
        return 1
    fi

    # Copy GPG configuration to ephemeral home if not present
    local gpg_conf="${KEYCUTTER_ROOT}/config/gpg/gpg.conf"
    if [[ -f "$gpg_conf" ]] && [[ ! -f "$GNUPGHOME/gpg.conf" ]]; then
        cp "$gpg_conf" "$GNUPGHOME/gpg.conf"
    fi

    # Configure gpg-agent for pinentry-loopback
    if [[ ! -f "$GNUPGHOME/gpg-agent.conf" ]]; then
        cat > "$GNUPGHOME/gpg-agent.conf" <<EOF
allow-loopback-pinentry
EOF
    fi

    # Restart agent with new config
    gpg-agent-restart "$GNUPGHOME" >/dev/null 2>&1

    log "Importing master key..."

    # Import the master key
    if ! gpg --homedir "$GNUPGHOME" --import "$master_key_file" 2>&1; then
        log "Error: Failed to import master key"
        return 1
    fi

    # Import ownertrust if available
    if [[ -f "$extracted_dir/ownertrust.txt" ]]; then
        log "Importing trust database..."
        gpg --homedir "$GNUPGHOME" --import-ownertrust "$extracted_dir/ownertrust.txt" 2>/dev/null || true
    fi

    # Get the imported key fingerprint
    local fingerprint
    fingerprint=$(gpg --homedir "$GNUPGHOME" --list-secret-keys --with-colons 2>/dev/null | \
        awk -F: '/^sec:/ { getline; if ($1 == "fpr") print $10; exit }')

    if [[ -z "$fingerprint" ]]; then
        # Try alternative method
        fingerprint=$(gpg --homedir "$GNUPGHOME" --list-secret-keys --with-colons 2>/dev/null | \
            awk -F: '/^fpr:/ { print $10; exit }')
    fi

    if [[ -z "$fingerprint" ]]; then
        log "Warning: Could not determine key fingerprint"
        log "Keys imported but fingerprint extraction failed"
        return 0
    fi

    # Count subkeys
    local subkey_count
    subkey_count=$(gpg --homedir "$GNUPGHOME" --list-secret-keys --with-colons "$fingerprint" 2>/dev/null | grep -c "^ssb:")

    log "Success: Key restored"
    log "Fingerprint: $fingerprint"
    log "Subkeys: $subkey_count"

    echo "$fingerprint"
    return 0
}

# =============================================================================
# WSL-SPECIFIC GPG FUNCTIONS
# =============================================================================
# These functions enable GPG/YubiKey support in Windows Subsystem for Linux
# by forwarding GPG agent socket connections to the Windows host via npiperelay.
#
# References:
#   - https://codingnest.com/how-to-use-gpg-with-yubikey-wsl/
#   - https://justyn.io/blog/using-a-yubikey-for-gpg-in-windows-10-wsl-windows-subsystem-for-linux/
#   - https://github.com/benpye/wsl-ssh-pageant (npiperelay source)
# =============================================================================

gpg-wsl-detect() {
    # Detect if running in Windows Subsystem for Linux
    #
    # Returns:
    #   0 if running in WSL (WSL1 or WSL2)
    #   1 if not running in WSL
    #
    # Output:
    #   Prints "wsl1" or "wsl2" if detected, nothing if not WSL

    # Check /proc/version for "microsoft" string (works for both WSL1 and WSL2)
    if [[ -f /proc/version ]] && grep -qi microsoft /proc/version; then
        # Distinguish WSL1 from WSL2
        if [[ -f /proc/sys/fs/binfmt_misc/WSLInterop ]]; then
            # WSL2 has this file
            echo "wsl2"
        else
            # WSL1 doesn't have this file, but check /proc/version for "microsoft"
            # WSL2 typically has "microsoft-standard" in the kernel name
            if grep -qi "microsoft-standard" /proc/version; then
                echo "wsl2"
            else
                echo "wsl1"
            fi
        fi
        return 0
    fi

    return 1
}

gpg-wsl-windows-user-profile() {
    # Get the Windows user profile path in WSL format
    #
    # Returns:
    #   0 on success
    #   1 on failure
    #
    # Output:
    #   Prints the Windows user profile path (e.g., /mnt/c/Users/username)

    local win_profile

    # Use PowerShell to get the user profile path
    win_profile=$(powershell.exe -NoProfile -Command 'Write-Host -NoNewline $env:USERPROFILE' 2>/dev/null | tr -d '\r')

    if [[ -z "$win_profile" ]]; then
        log "Error: Could not determine Windows user profile path"
        return 1
    fi

    # Convert to WSL path
    local wsl_path
    wsl_path=$(wslpath -u "$win_profile" 2>/dev/null)

    if [[ -z "$wsl_path" ]]; then
        log "Error: Could not convert Windows path to WSL path"
        return 1
    fi

    echo "$wsl_path"
    return 0
}

gpg-wsl-windows-gpg-path() {
    # Get the Windows GPG socket directory path in WSL format
    #
    # Returns:
    #   0 on success
    #   1 on failure
    #
    # Output:
    #   Prints the Windows GPG directory path (e.g., /mnt/c/Users/username/AppData/Local/gnupg)

    local user_profile
    user_profile=$(gpg-wsl-windows-user-profile) || return 1

    local gpg_path="${user_profile}/AppData/Local/gnupg"

    if [[ ! -d "$gpg_path" ]]; then
        log "Warning: Windows GPG directory does not exist: $gpg_path"
        log "Make sure GPG is installed on Windows and gpg-agent has been run"
    fi

    echo "$gpg_path"
    return 0
}

gpg-wsl-check-prerequisites() {
    # Check if WSL prerequisites for GPG relay are installed
    #
    # Arguments:
    #   --install    Install missing prerequisites
    #   --yes, -y    Non-interactive mode for installation
    #
    # Returns:
    #   0 if all prerequisites are met
    #   1 if some prerequisites are missing
    #
    # Output:
    #   Prints missing prerequisites (one per line)

    local install=false
    local non_interactive=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --install)
                install=true
                shift
                ;;
            --yes|-y)
                non_interactive=true
                shift
                ;;
            *)
                log "Error: Unknown option: $1"
                return 1
                ;;
        esac
    done

    local missing=()

    # Check for socat
    if ! command -v socat &>/dev/null; then
        missing+=("socat")
    fi

    # Check for Windows GPG installation
    local win_profile
    if win_profile=$(gpg-wsl-windows-user-profile 2>/dev/null); then
        local win_gpg_agent="${win_profile}/AppData/Local/Programs/GnuPG/bin/gpg-agent.exe"
        local win_gpg_path="${win_profile}/AppData/Local/gnupg"

        if [[ ! -f "$win_gpg_agent" ]] && [[ ! -d "$win_gpg_path" ]]; then
            log "Warning: Windows GPG not found at expected locations"
            log "Expected: $win_gpg_agent or $win_gpg_path"
            log "Make sure Gpg4win is installed on Windows"
        fi
    fi

    # Print missing prerequisites
    if [[ ${#missing[@]} -gt 0 ]]; then
        for pkg in "${missing[@]}"; do
            echo "$pkg"
        done

        if [[ "$install" == "true" ]]; then
            log "Installing missing prerequisites: ${missing[*]}"

            # Detect package manager
            if command -v apt-get &>/dev/null; then
                local cmd="sudo apt-get install -y ${missing[*]}"
                if [[ "$non_interactive" == "true" ]]; then
                    eval "$cmd"
                else
                    echo "The following packages will be installed: ${missing[*]}"
                    echo -n "Install? [y/N] "
                    read -r response
                    if [[ "$response" =~ ^[Yy] ]]; then
                        eval "$cmd"
                    else
                        return 1
                    fi
                fi
            else
                log "Error: apt-get not found. Please install manually: ${missing[*]}"
                return 1
            fi
        else
            return 1
        fi
    fi

    return 0
}

gpg-wsl-install-npiperelay() {
    # Download and install npiperelay for GPG socket forwarding
    #
    # Arguments:
    #   --force      Re-download even if already exists
    #
    # Returns:
    #   0 on success
    #   1 on failure
    #
    # Output:
    #   Path to npiperelay executable

    local force=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --force)
                force=true
                shift
                ;;
            *)
                log "Error: Unknown option: $1"
                return 1
                ;;
        esac
    done

    local win_profile
    win_profile=$(gpg-wsl-windows-user-profile) || return 1

    # Create WSL directory in Windows user profile
    local wsl_dir="${win_profile}/WSL"
    if [[ ! -d "$wsl_dir" ]]; then
        log "Creating WSL directory: $wsl_dir"
        mkdir -p "$wsl_dir"
    fi

    local npiperelay_path="${wsl_dir}/npiperelay.exe"

    # Check if already installed
    if [[ -f "$npiperelay_path" ]] && [[ "$force" != "true" ]]; then
        log "npiperelay already installed: $npiperelay_path"
        echo "$npiperelay_path"
        return 0
    fi

    # Download npiperelay
    # Using wsl-ssh-pageant which includes npiperelay functionality
    local url="https://github.com/benpye/wsl-ssh-pageant/releases/latest/download/wsl-ssh-pageant-amd64-gui.exe"

    log "Downloading npiperelay from $url..."

    if command -v curl &>/dev/null; then
        curl -L -o "$npiperelay_path" "$url" || {
            log "Error: Failed to download npiperelay"
            return 1
        }
    elif command -v wget &>/dev/null; then
        wget -O "$npiperelay_path" "$url" || {
            log "Error: Failed to download npiperelay"
            return 1
        }
    else
        log "Error: Neither curl nor wget available"
        return 1
    fi

    log "npiperelay installed: $npiperelay_path"
    echo "$npiperelay_path"
    return 0
}

gpg-wsl-mask-systemd-sockets() {
    # Disable systemd GPG agent sockets to prevent conflicts with relay
    #
    # Returns:
    #   0 always (failures are non-fatal)

    log "Disabling systemd GPG agent sockets..."

    # Mask sockets to prevent systemd from starting gpg-agent
    systemctl --user mask --now gpg-agent-browser.socket 2>/dev/null || true
    systemctl --user mask --now gpg-agent-extra.socket 2>/dev/null || true
    systemctl --user mask --now gpg-agent-ssh.socket 2>/dev/null || true
    systemctl --user mask --now gpg-agent.socket 2>/dev/null || true

    log "systemd GPG agent sockets disabled"
    return 0
}

gpg-wsl-relay-script-path() {
    # Get the path where the GPG relay script should be installed
    #
    # Output:
    #   Path to gpg-relay script

    echo "${HOME}/.config/keycutter/gpg-relay"
}

gpg-wsl-relay-install() {
    # Install the GPG relay script for socket forwarding
    #
    # Arguments:
    #   --enable-ssh    Enable SSH agent forwarding
    #   --backup        Back up existing script
    #
    # Returns:
    #   0 on success
    #   1 on failure

    local enable_ssh=false
    local backup=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --enable-ssh)
                enable_ssh=true
                shift
                ;;
            --backup)
                backup=true
                shift
                ;;
            *)
                log "Error: Unknown option: $1"
                return 1
                ;;
        esac
    done

    local script_path
    script_path=$(gpg-wsl-relay-script-path)
    local script_dir
    script_dir=$(dirname "$script_path")

    # Create directory if needed
    if [[ ! -d "$script_dir" ]]; then
        mkdir -p "$script_dir"
    fi

    # Backup existing script
    if [[ -f "$script_path" ]] && [[ "$backup" == "true" ]]; then
        local backup_path="${script_path}.backup.$(date +%Y%m%d%H%M%S)"
        cp "$script_path" "$backup_path"
        log "Backed up existing script to: $backup_path"
    fi

    # Get Windows paths
    local win_profile
    win_profile=$(gpg-wsl-windows-user-profile) || return 1

    local npiperelay_path="${win_profile}/WSL/npiperelay.exe"
    local win_gpg_path="${win_profile}/AppData/Local/gnupg"
    # Convert to Windows path format for npiperelay
    local win_gpg_path_win
    win_gpg_path_win=$(wslpath -w "$win_gpg_path" 2>/dev/null | sed 's/\\/\\\\/g')

    log "Installing GPG relay script: $script_path"

    # Generate the relay script
    cat > "$script_path" << 'RELAY_SCRIPT_HEADER'
#!/usr/bin/env bash
# GPG Relay for WSL
# Forwards GPG agent socket to Windows via npiperelay
#
# Generated by: keycutter gpg setup
#
# Usage:
#   source ~/.config/keycutter/gpg-relay
#
# This script is sourced in your shell profile (.bashrc/.zshrc)
# and automatically starts the GPG relay when needed.

GPG_RELAY_LOCKFILE="${HOME}/.gnupg/.gpg-relay.lock"
GPG_RELAY_PIDFILE="${HOME}/.gnupg/.gpg-relay.pids"
SSH_RELAY_PIDFILE="${HOME}/.gnupg/.ssh-relay.pids"

RELAY_SCRIPT_HEADER

    # Add configuration section with paths
    cat >> "$script_path" << RELAY_SCRIPT_CONFIG
# Configuration (generated by keycutter)
NPIPERELAY="${npiperelay_path}"
WIN_GPG_DIR="${win_gpg_path_win}"
RELAY_SCRIPT_CONFIG

    # Add SSH configuration if enabled
    if [[ "$enable_ssh" == "true" ]]; then
        cat >> "$script_path" << 'RELAY_SCRIPT_SSH'
SSH_ENABLED="true"
RELAY_SCRIPT_SSH
    else
        cat >> "$script_path" << 'RELAY_SCRIPT_SSH'
SSH_ENABLED=""
RELAY_SCRIPT_SSH
    fi

    # Add the main relay functions
    cat >> "$script_path" << 'RELAY_SCRIPT_BODY'

gpg_relay_cleanup_stale() {
    # Clean up stale socket files
    local socket_dir="${GNUPGHOME:-$HOME/.gnupg}"
    local xdg_socket_dir="${XDG_RUNTIME_DIR}/gnupg"

    for socket in "${socket_dir}/S.gpg-agent" "${xdg_socket_dir}/S.gpg-agent"; do
        if [[ -S "$socket" ]]; then
            if ! fuser "$socket" >/dev/null 2>&1; then
                rm -f "$socket" 2>/dev/null
            fi
        fi
    done

    if [[ -n "$SSH_ENABLED" ]]; then
        for socket in "${socket_dir}/S.gpg-agent.ssh" "${xdg_socket_dir}/S.gpg-agent.ssh"; do
            if [[ -S "$socket" ]]; then
                if ! fuser "$socket" >/dev/null 2>&1; then
                    rm -f "$socket" 2>/dev/null
                fi
            fi
        done
    fi
}

gpg_relay_check_pids() {
    # Check if relay processes are running
    local pidfile="$1"
    if [[ ! -f "$pidfile" ]]; then
        return 1
    fi

    while read -r pid; do
        if ! kill -0 "$pid" 2>/dev/null; then
            return 1
        fi
    done < "$pidfile"

    return 0
}

gpg_relay_start() {
    # Start the GPG agent relay
    local socket_dir="${GNUPGHOME:-$HOME/.gnupg}"
    local xdg_socket_dir="${XDG_RUNTIME_DIR}/gnupg"

    # Create directories if needed
    mkdir -p "$socket_dir" 2>/dev/null
    [[ -n "$XDG_RUNTIME_DIR" ]] && mkdir -p "$xdg_socket_dir" 2>/dev/null

    # Check for recent start (prevent duplicate starts)
    if [[ -f "$GPG_RELAY_LOCKFILE" ]]; then
        local lock_age=$(( $(date +%s) - $(stat -c %Y "$GPG_RELAY_LOCKFILE" 2>/dev/null || echo 0) ))
        if [[ $lock_age -lt 10 ]]; then
            return 0
        fi
    fi

    # Check if relay is already running
    if gpg_relay_check_pids "$GPG_RELAY_PIDFILE"; then
        return 0
    fi

    # Clean up stale sockets
    gpg_relay_cleanup_stale

    # Create lock file
    touch "$GPG_RELAY_LOCKFILE"

    # Kill any existing gpg-agent in WSL
    gpgconf --kill gpg-agent 2>/dev/null || true

    # Clear old PID files
    rm -f "$GPG_RELAY_PIDFILE" "$SSH_RELAY_PIDFILE"

    # Start GPG agent relay
    # Create sockets in both locations for compatibility
    if [[ -n "$XDG_RUNTIME_DIR" ]]; then
        socat UNIX-LISTEN:"${xdg_socket_dir}/S.gpg-agent,fork" \
            EXEC:"${NPIPERELAY} -ep -ei -s -a '${WIN_GPG_DIR}\\S.gpg-agent'",nofork &
        echo $! >> "$GPG_RELAY_PIDFILE"
    fi

    socat UNIX-LISTEN:"${socket_dir}/S.gpg-agent,fork" \
        EXEC:"${NPIPERELAY} -ep -ei -s -a '${WIN_GPG_DIR}\\S.gpg-agent'",nofork &
    echo $! >> "$GPG_RELAY_PIDFILE"

    # Start SSH agent relay if enabled
    if [[ -n "$SSH_ENABLED" ]]; then
        if [[ -n "$XDG_RUNTIME_DIR" ]]; then
            socat UNIX-LISTEN:"${xdg_socket_dir}/S.gpg-agent.ssh,fork" \
                EXEC:"${NPIPERELAY} -ep -ei -s -a '${WIN_GPG_DIR}\\S.gpg-agent.ssh'",nofork &
            echo $! >> "$SSH_RELAY_PIDFILE"
        fi

        socat UNIX-LISTEN:"${socket_dir}/S.gpg-agent.ssh,fork" \
            EXEC:"${NPIPERELAY} -ep -ei -s -a '${WIN_GPG_DIR}\\S.gpg-agent.ssh'",nofork &
        echo $! >> "$SSH_RELAY_PIDFILE"

        # Set SSH_AUTH_SOCK for GPG-backed SSH
        export SSH_AUTH_SOCK="${socket_dir}/S.gpg-agent.ssh"
    fi

    # Set GPG_TTY for pinentry
    export GPG_TTY=$(tty)
}

gpg_relay_stop() {
    # Stop the GPG agent relay
    for pidfile in "$GPG_RELAY_PIDFILE" "$SSH_RELAY_PIDFILE"; do
        if [[ -f "$pidfile" ]]; then
            while read -r pid; do
                kill "$pid" 2>/dev/null || true
            done < "$pidfile"
            rm -f "$pidfile"
        fi
    done

    rm -f "$GPG_RELAY_LOCKFILE"
}

gpg_relay_status() {
    # Check relay status
    if gpg_relay_check_pids "$GPG_RELAY_PIDFILE"; then
        echo "GPG relay: running"
        if [[ -n "$SSH_ENABLED" ]] && gpg_relay_check_pids "$SSH_RELAY_PIDFILE"; then
            echo "SSH relay: running"
        elif [[ -n "$SSH_ENABLED" ]]; then
            echo "SSH relay: stopped"
        fi
        return 0
    else
        echo "GPG relay: stopped"
        return 1
    fi
}

gpg_relay_restart() {
    gpg_relay_stop
    sleep 1
    gpg_relay_start
}

# Auto-start relay when this script is sourced
if grep -qi microsoft /proc/version 2>/dev/null; then
    gpg_relay_start
fi
RELAY_SCRIPT_BODY

    chmod +x "$script_path"

    log "GPG relay script installed: $script_path"
    return 0
}

gpg-wsl-shell-config() {
    # Generate shell configuration for WSL GPG relay
    #
    # Arguments:
    #   --enable-ssh    Include SSH agent configuration
    #
    # Output:
    #   Prints shell configuration lines to stdout

    local enable_ssh=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --enable-ssh)
                enable_ssh=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done

    local script_path
    script_path=$(gpg-wsl-relay-script-path)

    echo "# GPG Relay for WSL (keycutter)"
    echo "# This sources the GPG relay script which forwards"
    echo "# GPG agent socket to Windows for YubiKey access"
    echo "if [[ -f \"$script_path\" ]]; then"
    echo "    source \"$script_path\""
    echo "fi"
    echo ""
    echo "# GPG TTY for pinentry"
    echo "export GPG_TTY=\$(tty)"

    if [[ "$enable_ssh" == "true" ]]; then
        echo ""
        echo "# SSH via GPG agent (auto-set by gpg-relay when SSH is enabled)"
        echo "# export SSH_AUTH_SOCK=\"\${GNUPGHOME:-\$HOME/.gnupg}/S.gpg-agent.ssh\""
    fi
}

gpg-wsl-setup() {
    # Set up GPG agent forwarding in WSL
    #
    # This function:
    #   1. Checks prerequisites (socat, Windows GPG)
    #   2. Downloads and installs npiperelay
    #   3. Masks systemd GPG agent sockets
    #   4. Installs the GPG relay script
    #   5. Shows shell configuration
    #
    # Arguments:
    #   --enable-ssh    Enable SSH agent forwarding
    #   --yes, -y       Non-interactive mode
    #
    # Returns:
    #   0 on success
    #   1 on failure

    local enable_ssh=false
    local non_interactive=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --enable-ssh)
                enable_ssh=true
                shift
                ;;
            --yes|-y)
                non_interactive=true
                shift
                ;;
            *)
                log "Error: Unknown option: $1"
                return 1
                ;;
        esac
    done

    log "Setting up GPG relay for WSL..."
    echo

    # Step 1: Check prerequisites
    log "Step 1: Checking prerequisites..."

    local install_args=("--install")
    if [[ "$non_interactive" == "true" ]]; then
        install_args+=("--yes")
    fi

    gpg-wsl-check-prerequisites "${install_args[@]}" || {
        log "Error: Prerequisites check failed"
        return 1
    }
    echo

    # Step 2: Download npiperelay
    log "Step 2: Installing npiperelay..."
    local npiperelay_path
    npiperelay_path=$(gpg-wsl-install-npiperelay) || {
        log "Error: Failed to install npiperelay"
        return 1
    }
    echo

    # Step 3: Disable systemd sockets
    log "Step 3: Disabling systemd GPG agent sockets..."
    gpg-wsl-mask-systemd-sockets
    echo

    # Step 4: Install relay script
    log "Step 4: Installing GPG relay script..."
    local relay_args=(--backup)
    if [[ "$enable_ssh" == "true" ]]; then
        relay_args+=(--enable-ssh)
    fi

    gpg-wsl-relay-install "${relay_args[@]}" || {
        log "Error: Failed to install relay script"
        return 1
    }
    echo

    # Step 5: Show shell configuration
    log "Step 5: Shell configuration"
    echo
    echo "Add the following to your ~/.bashrc or ~/.zshrc:"
    echo
    gpg-wsl-shell-config $(if [[ "$enable_ssh" == "true" ]]; then echo "--enable-ssh"; fi)
    echo

    # Summary
    log "WSL GPG setup complete!"
    echo
    echo "Next steps:"
    echo "  1. Add the shell configuration above to your ~/.bashrc or ~/.zshrc"
    echo "  2. Restart your shell or run: source ~/.bashrc"
    echo "  3. Make sure Windows GPG is running and has access to your YubiKey"
    echo "  4. Test with: gpg --card-status"
    echo
    echo "Troubleshooting:"
    echo "  - If gpg --card-status fails, ensure Windows gpg-agent is running"
    echo "  - Run 'gpg-connect-agent /bye' in Windows to start the agent"
    echo "  - Check relay status with: gpg_relay_status"
    echo

    return 0
}

# ============================================================================
# GPG SSH Integration Functions (gpg-017)
# ============================================================================
# These functions enable using GPG authentication keys with SSH via gpg-agent.

# Get the keygrip for a GPG authentication subkey
# Usage: gpg-ssh-keygrip [--fingerprint FP]
# Returns: keygrip of the authentication subkey
gpg-ssh-keygrip() {
    local fingerprint=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --fingerprint)
                fingerprint="$2"
                shift 2
                ;;
            *)
                log "Error: Unknown option: $1"
                return 1
                ;;
        esac
    done

    # If no fingerprint specified, try to get from YubiKey
    if [[ -z "$fingerprint" ]]; then
        fingerprint=$(gpg --card-status 2>/dev/null | grep "Authentication key:" | awk -F': ' '{print $2}' | tr -d ' ')
        if [[ -z "$fingerprint" ]]; then
            log "Error: No authentication key found on YubiKey and no fingerprint specified"
            return 1
        fi
    fi

    # Get the keygrip for the auth subkey
    local keygrip
    keygrip=$(gpg --list-keys --with-keygrip "$fingerprint" 2>/dev/null | \
        grep -A1 "\[A\]" | grep "Keygrip" | awk '{print $3}')

    if [[ -z "$keygrip" ]]; then
        log "Error: Could not find keygrip for authentication key"
        return 1
    fi

    echo "$keygrip"
}

# Export GPG authentication key as SSH public key
# Usage: gpg-ssh-pubkey-export [--fingerprint FP] [--comment COMMENT]
# Outputs: SSH public key in authorized_keys format
gpg-ssh-pubkey-export() {
    local fingerprint=""
    local comment=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --fingerprint)
                fingerprint="$2"
                shift 2
                ;;
            --comment)
                comment="$2"
                shift 2
                ;;
            -*)
                log "Error: Unknown option: $1"
                return 1
                ;;
            *)
                # First positional arg is fingerprint if not specified
                if [[ -z "$fingerprint" ]]; then
                    fingerprint="$1"
                fi
                shift
                ;;
        esac
    done

    # If no fingerprint specified, try to get from YubiKey
    if [[ -z "$fingerprint" ]]; then
        fingerprint=$(gpg --card-status 2>/dev/null | grep "General key info" | grep -oE '[A-F0-9]{40}')
        if [[ -z "$fingerprint" ]]; then
            log "Error: No GPG key found on YubiKey and no fingerprint specified"
            return 1
        fi
    fi

    # Export the SSH public key using gpg --export-ssh-key
    local ssh_pubkey
    ssh_pubkey=$(gpg --export-ssh-key "$fingerprint" 2>/dev/null)

    if [[ -z "$ssh_pubkey" ]]; then
        log "Error: Failed to export SSH public key for fingerprint: $fingerprint"
        log "Make sure the key has an authentication subkey [A]"
        return 1
    fi

    # Add custom comment if provided, otherwise use the one from GPG
    if [[ -n "$comment" ]]; then
        # Replace the existing comment with the new one
        echo "$ssh_pubkey" | awk -v comment="$comment" '{$NF=comment; print}'
    else
        echo "$ssh_pubkey"
    fi
}

# Register a GPG SSH key with keycutter
# Usage: gpg-ssh-key-register [--fingerprint FP] [--name NAME] [--output-dir DIR]
# Creates a .pub file in keycutter's key directory for the GPG auth key
gpg-ssh-key-register() {
    local fingerprint=""
    local key_name=""
    local output_dir="${KEYCUTTER_SSH_KEY_DIR:-${HOME}/.ssh/keycutter/keys}"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --fingerprint)
                fingerprint="$2"
                shift 2
                ;;
            --name)
                key_name="$2"
                shift 2
                ;;
            --output-dir)
                output_dir="$2"
                shift 2
                ;;
            -*)
                log "Error: Unknown option: $1"
                return 1
                ;;
            *)
                shift
                ;;
        esac
    done

    # Get the SSH public key
    local ssh_pubkey
    if [[ -n "$fingerprint" ]]; then
        ssh_pubkey=$(gpg-ssh-pubkey-export --fingerprint "$fingerprint")
    else
        ssh_pubkey=$(gpg-ssh-pubkey-export)
    fi

    if [[ -z "$ssh_pubkey" ]]; then
        log "Error: Failed to export SSH public key"
        return 1
    fi

    # Extract email/uid from the key comment if no name specified
    if [[ -z "$key_name" ]]; then
        # Try to get identity from the key
        local uid
        if [[ -n "$fingerprint" ]]; then
            uid=$(gpg --list-keys "$fingerprint" 2>/dev/null | grep "^uid" | head -1 | sed 's/^uid\s*\[.*\]\s*//')
        else
            uid=$(echo "$ssh_pubkey" | awk '{print $NF}')
        fi

        # Extract email from uid
        local email
        email=$(echo "$uid" | grep -oE '<[^>]+>' | tr -d '<>')

        if [[ -n "$email" ]]; then
            # Create keytag from email: user@domain -> domain_user@hostname
            local user domain
            user=$(echo "$email" | cut -d@ -f1)
            domain=$(echo "$email" | cut -d@ -f2)
            key_name="${domain}_${user}@${KEYCUTTER_ORIGIN:-$(hostname -s)}"
        else
            # Fallback to GPG fingerprint
            if [[ -n "$fingerprint" ]]; then
                key_name="gpg_${fingerprint:(-8)}@${KEYCUTTER_ORIGIN:-$(hostname -s)}"
            else
                log "Error: Could not determine key name. Use --name to specify."
                return 1
            fi
        fi
    fi

    # Ensure output directory exists
    mkdir -p "$output_dir"

    # Add keytag comment to the key
    local output_file="${output_dir}/${key_name}.pub"
    local ssh_pubkey_with_comment
    ssh_pubkey_with_comment=$(echo "$ssh_pubkey" | awk -v comment="$key_name" '{$NF=comment; print}')

    echo "$ssh_pubkey_with_comment" > "$output_file"
    chmod 644 "$output_file"

    log "Registered GPG SSH key: $key_name"
    log "Public key saved to: $output_file"

    echo "$output_file"
}

# List GPG-backed SSH keys in keycutter
# Usage: gpg-ssh-keys-list [--quiet]
# Returns: List of GPG SSH public keys registered with keycutter
gpg-ssh-keys-list() {
    local quiet=""
    local keys_dir="${KEYCUTTER_SSH_KEY_DIR:-${HOME}/.ssh/keycutter/keys}"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --quiet|-q)
                quiet="true"
                shift
                ;;
            *)
                shift
                ;;
        esac
    done

    if [[ ! -d "$keys_dir" ]]; then
        [[ -z "$quiet" ]] && log "No keys directory found at $keys_dir"
        return 0
    fi

    local found_keys=0

    # Look for .pub files that contain GPG SSH key signatures
    for pubkey_file in "$keys_dir"/*.pub; do
        [[ -f "$pubkey_file" ]] || continue

        # GPG SSH keys start with specific key types
        if grep -qE "^(ssh-ed25519|ssh-rsa|ecdsa-sha2)" "$pubkey_file" 2>/dev/null; then
            local key_name
            key_name=$(basename "$pubkey_file" .pub)

            # Check if there's a corresponding private key file (FIDO2/OpenSSH)
            # GPG-backed keys won't have a private key file
            if [[ ! -f "$keys_dir/$key_name" ]]; then
                ((found_keys++))
                if [[ -z "$quiet" ]]; then
                    echo "  $key_name (GPG)"
                else
                    echo "$key_name"
                fi
            fi
        fi
    done

    if [[ $found_keys -eq 0 && -z "$quiet" ]]; then
        log "No GPG-backed SSH keys found"
    fi

    return 0
}

# Check if gpg-agent SSH support is enabled and working
# Usage: gpg-ssh-agent-check
# Returns: 0 if gpg-agent SSH is working, 1 otherwise
gpg-ssh-agent-check() {
    # Check if gpg-agent.conf has enable-ssh-support
    local gpg_home="${GNUPGHOME:-${HOME}/.gnupg}"
    local agent_conf="$gpg_home/gpg-agent.conf"

    if [[ ! -f "$agent_conf" ]]; then
        log "Warning: gpg-agent.conf not found at $agent_conf"
        return 1
    fi

    if ! grep -q "^enable-ssh-support" "$agent_conf" 2>/dev/null; then
        log "Warning: SSH support not enabled in gpg-agent.conf"
        log "Run 'keycutter gpg setup --enable-ssh' to enable it"
        return 1
    fi

    # Check if the SSH socket exists
    local ssh_socket
    ssh_socket=$(gpgconf --list-dirs agent-ssh-socket 2>/dev/null)

    if [[ -z "$ssh_socket" ]]; then
        log "Warning: Could not determine gpg-agent SSH socket path"
        return 1
    fi

    if [[ ! -S "$ssh_socket" ]]; then
        log "Warning: gpg-agent SSH socket not found at $ssh_socket"
        log "Try restarting gpg-agent: gpgconf --kill gpg-agent"
        return 1
    fi

    # Verify we can communicate with the agent
    if ! gpg-connect-agent /bye 2>/dev/null; then
        log "Warning: Could not connect to gpg-agent"
        return 1
    fi

    log "gpg-agent SSH support is enabled and working"
    log "SSH socket: $ssh_socket"
    return 0
}

# Add a GPG authentication keygrip to sshcontrol
# This tells gpg-agent which keys to expose for SSH
# Usage: gpg-ssh-sshcontrol-add [--keygrip KEYGRIP] [--fingerprint FP]
gpg-ssh-sshcontrol-add() {
    local keygrip=""
    local fingerprint=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --keygrip)
                keygrip="$2"
                shift 2
                ;;
            --fingerprint)
                fingerprint="$2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done

    # Get keygrip from fingerprint if not directly specified
    if [[ -z "$keygrip" && -n "$fingerprint" ]]; then
        keygrip=$(gpg-ssh-keygrip --fingerprint "$fingerprint")
        if [[ -z "$keygrip" ]]; then
            log "Error: Could not get keygrip for fingerprint: $fingerprint"
            return 1
        fi
    fi

    if [[ -z "$keygrip" ]]; then
        # Try to get from YubiKey
        keygrip=$(gpg-ssh-keygrip)
        if [[ -z "$keygrip" ]]; then
            log "Error: No keygrip specified and could not find authentication key"
            return 1
        fi
    fi

    local gpg_home="${GNUPGHOME:-${HOME}/.gnupg}"
    local sshcontrol="$gpg_home/sshcontrol"

    # Create sshcontrol file if it doesn't exist
    if [[ ! -f "$sshcontrol" ]]; then
        touch "$sshcontrol"
        chmod 600 "$sshcontrol"
    fi

    # Check if keygrip is already in sshcontrol
    if grep -q "^$keygrip\$" "$sshcontrol" 2>/dev/null; then
        log "Keygrip already in sshcontrol: $keygrip"
        return 0
    fi

    # Add keygrip to sshcontrol
    echo "$keygrip" >> "$sshcontrol"
    log "Added keygrip to sshcontrol: $keygrip"

    # Restart agent to pick up changes
    gpgconf --kill gpg-agent 2>/dev/null
    gpgconf --launch gpg-agent 2>/dev/null

    return 0
}

# =============================================================================
# Multiple YubiKey Support (gpg-018)
# =============================================================================
#
# These functions support installing the same GPG key to multiple YubiKeys
# and tracking which YubiKeys have which key installed.
#
# Registry file location: ~/.config/keycutter/gpg-yubikeys.json
# Format:
# {
#   "installations": [
#     {
#       "serial": "12345678",
#       "fingerprint": "ABCD1234...",
#       "installed_at": "2025-01-01T12:00:00Z",
#       "label": "Primary YubiKey"
#     }
#   ]
# }

gpg-yubikey-registry-path() {
    # Get the path to the YubiKey registry file
    #
    # Returns:
    #   Path to the registry file (creates directory if needed)

    local config_dir="${XDG_CONFIG_HOME:-$HOME/.config}/keycutter"

    # Ensure directory exists
    if [[ ! -d "$config_dir" ]]; then
        mkdir -p "$config_dir"
    fi

    echo "$config_dir/gpg-yubikeys.json"
}

gpg-yubikey-registry-init() {
    # Initialize the YubiKey registry file if it doesn't exist
    #
    # Returns:
    #   0 on success
    #   1 on failure

    local registry_file
    registry_file=$(gpg-yubikey-registry-path)

    if [[ ! -f "$registry_file" ]]; then
        echo '{"installations":[]}' > "$registry_file"
        log "Created YubiKey registry: $registry_file"
    fi

    return 0
}

gpg-yubikey-registry-add() {
    # Register a YubiKey installation in the registry
    #
    # Arguments:
    #   --serial SERIAL         YubiKey serial number (required)
    #   --fingerprint FP        GPG key fingerprint (required)
    #   --label LABEL           Optional label for the YubiKey
    #
    # Returns:
    #   0 on success
    #   1 on failure

    local serial=""
    local fingerprint=""
    local label=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --serial)
                serial="$2"
                shift 2
                ;;
            --fingerprint)
                fingerprint="$2"
                shift 2
                ;;
            --label)
                label="$2"
                shift 2
                ;;
            *)
                log "Error: Unknown option: $1"
                return 1
                ;;
        esac
    done

    if [[ -z "$serial" ]]; then
        log "Error: --serial is required"
        return 1
    fi

    if [[ -z "$fingerprint" ]]; then
        log "Error: --fingerprint is required"
        return 1
    fi

    # Initialize registry if needed
    gpg-yubikey-registry-init

    local registry_file
    registry_file=$(gpg-yubikey-registry-path)

    local timestamp
    timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    # Remove existing entry for this serial (update case)
    local temp_file="${registry_file}.tmp"

    if command -v jq &>/dev/null; then
        # Use jq for proper JSON manipulation
        jq --arg serial "$serial" \
           --arg fp "$fingerprint" \
           --arg ts "$timestamp" \
           --arg lbl "$label" \
           '.installations = [.installations[] | select(.serial != $serial)] + [{
               "serial": $serial,
               "fingerprint": $fp,
               "installed_at": $ts,
               "label": $lbl
           }]' "$registry_file" > "$temp_file" && mv "$temp_file" "$registry_file"
    else
        # Fallback: simple append without dedup (less elegant but functional)
        local new_entry="{\"serial\":\"$serial\",\"fingerprint\":\"$fingerprint\",\"installed_at\":\"$timestamp\",\"label\":\"$label\"}"

        # Read current file and add new entry
        local current
        current=$(cat "$registry_file")

        # Simple sed-based insertion (works for basic cases)
        if [[ "$current" == '{"installations":[]}' ]]; then
            echo "{\"installations\":[$new_entry]}" > "$registry_file"
        else
            # Insert before the closing ]}
            echo "${current%\]\}},${new_entry}]}" > "$registry_file"
        fi
    fi

    log "Registered YubiKey $serial with key ${fingerprint:0:16}..."
    return 0
}

gpg-yubikey-registry-list() {
    # List all registered YubiKey installations
    #
    # Arguments:
    #   --fingerprint FP    Filter by fingerprint
    #   --quiet             Output serial numbers only
    #   --json              Output as JSON
    #
    # Returns:
    #   0 if entries found
    #   1 if no entries or error

    local fingerprint=""
    local quiet=false
    local json_output=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --fingerprint)
                fingerprint="$2"
                shift 2
                ;;
            --quiet|-q)
                quiet=true
                shift
                ;;
            --json)
                json_output=true
                shift
                ;;
            *)
                log "Error: Unknown option: $1"
                return 1
                ;;
        esac
    done

    local registry_file
    registry_file=$(gpg-yubikey-registry-path)

    if [[ ! -f "$registry_file" ]]; then
        if [[ "$quiet" != true ]]; then
            log "No YubiKey installations registered"
        fi
        return 1
    fi

    if [[ "$json_output" == true ]]; then
        if [[ -n "$fingerprint" ]] && command -v jq &>/dev/null; then
            jq --arg fp "$fingerprint" '.installations | map(select(.fingerprint == $fp))' "$registry_file"
        else
            cat "$registry_file"
        fi
        return 0
    fi

    if command -v jq &>/dev/null; then
        local entries
        if [[ -n "$fingerprint" ]]; then
            entries=$(jq -r --arg fp "$fingerprint" '.installations[] | select(.fingerprint == $fp) | "\(.serial)|\(.fingerprint)|\(.installed_at)|\(.label)"' "$registry_file" 2>/dev/null)
        else
            entries=$(jq -r '.installations[] | "\(.serial)|\(.fingerprint)|\(.installed_at)|\(.label)"' "$registry_file" 2>/dev/null)
        fi

        if [[ -z "$entries" ]]; then
            if [[ "$quiet" != true ]]; then
                log "No YubiKey installations found"
            fi
            return 1
        fi

        if [[ "$quiet" == true ]]; then
            echo "$entries" | cut -d'|' -f1
        else
            echo
            echo "Registered YubiKey Installations:"
            echo
            while IFS='|' read -r serial fp installed_at label; do
                echo "  Serial:      $serial"
                echo "  Fingerprint: ${fp:0:16}..."
                echo "  Installed:   $installed_at"
                if [[ -n "$label" && "$label" != "null" ]]; then
                    echo "  Label:       $label"
                fi
                echo
            done <<< "$entries"
        fi
    else
        # Fallback without jq
        if [[ "$quiet" == true ]]; then
            grep -o '"serial":"[^"]*"' "$registry_file" | cut -d'"' -f4
        else
            cat "$registry_file"
        fi
    fi

    return 0
}

gpg-yubikey-registry-check() {
    # Check if a YubiKey is registered with a specific fingerprint
    #
    # Arguments:
    #   --serial SERIAL         YubiKey serial number (required)
    #   --fingerprint FP        GPG key fingerprint (required)
    #
    # Returns:
    #   0 if YubiKey is registered with that fingerprint
    #   1 if not registered or different fingerprint

    local serial=""
    local fingerprint=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --serial)
                serial="$2"
                shift 2
                ;;
            --fingerprint)
                fingerprint="$2"
                shift 2
                ;;
            *)
                log "Error: Unknown option: $1"
                return 1
                ;;
        esac
    done

    if [[ -z "$serial" ]]; then
        log "Error: --serial is required"
        return 1
    fi

    if [[ -z "$fingerprint" ]]; then
        log "Error: --fingerprint is required"
        return 1
    fi

    local registry_file
    registry_file=$(gpg-yubikey-registry-path)

    if [[ ! -f "$registry_file" ]]; then
        return 1
    fi

    if command -v jq &>/dev/null; then
        local match
        match=$(jq -r --arg serial "$serial" --arg fp "$fingerprint" \
            '.installations[] | select(.serial == $serial and .fingerprint == $fp) | .serial' \
            "$registry_file" 2>/dev/null)

        if [[ -n "$match" ]]; then
            return 0
        fi
    else
        # Fallback: simple grep
        if grep -q "\"serial\":\"$serial\"" "$registry_file" && \
           grep -q "\"fingerprint\":\"$fingerprint\"" "$registry_file"; then
            return 0
        fi
    fi

    return 1
}

gpg-yubikey-registry-remove() {
    # Remove a YubiKey from the registry
    #
    # Arguments:
    #   --serial SERIAL         YubiKey serial number (required)
    #
    # Returns:
    #   0 on success
    #   1 on failure

    local serial=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --serial)
                serial="$2"
                shift 2
                ;;
            *)
                log "Error: Unknown option: $1"
                return 1
                ;;
        esac
    done

    if [[ -z "$serial" ]]; then
        log "Error: --serial is required"
        return 1
    fi

    local registry_file
    registry_file=$(gpg-yubikey-registry-path)

    if [[ ! -f "$registry_file" ]]; then
        log "Error: No registry file found"
        return 1
    fi

    if command -v jq &>/dev/null; then
        local temp_file="${registry_file}.tmp"
        jq --arg serial "$serial" \
           '.installations = [.installations[] | select(.serial != $serial)]' \
           "$registry_file" > "$temp_file" && mv "$temp_file" "$registry_file"

        log "Removed YubiKey $serial from registry"
        return 0
    else
        log "Error: jq is required to remove entries"
        return 1
    fi
}

gpg-yubikeys-list-available() {
    # List all YubiKeys currently connected that have OpenPGP enabled
    #
    # This function uses ykman to enumerate all connected YubiKeys,
    # not just the one GPG happens to be talking to.
    #
    # Arguments:
    #   --quiet             Output serial numbers only
    #
    # Returns:
    #   0 if YubiKeys found
    #   1 if no YubiKeys found or error

    local quiet=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --quiet|-q)
                quiet=true
                shift
                ;;
            *)
                log "Error: Unknown option: $1"
                return 1
                ;;
        esac
    done

    # Prefer ykman for listing all YubiKeys
    if command -v ykman &>/dev/null; then
        local yubikeys
        yubikeys=$(ykman list --serials 2>/dev/null)

        if [[ -z "$yubikeys" ]]; then
            if [[ "$quiet" != true ]]; then
                log "No YubiKeys detected"
            fi
            return 1
        fi

        if [[ "$quiet" == true ]]; then
            echo "$yubikeys"
        else
            echo
            log "Connected YubiKeys:"
            echo
            while read -r serial; do
                local device_info
                device_info=$(ykman --device "$serial" info 2>/dev/null | head -5)

                local device_name
                device_name=$(echo "$device_info" | grep "Device type:" | cut -d: -f2 | xargs)

                local openpgp_status="enabled"
                if ! ykman --device "$serial" openpgp info &>/dev/null 2>&1; then
                    openpgp_status="disabled"
                fi

                echo "  Serial:   $serial"
                echo "  Type:     ${device_name:-Unknown}"
                echo "  OpenPGP:  $openpgp_status"
                echo
            done <<< "$yubikeys"
        fi

        return 0
    else
        # Fallback to GPG (only shows one YubiKey)
        if [[ "$quiet" != true ]]; then
            log "Warning: ykman not installed, can only detect one YubiKey at a time"
        fi

        local serial
        serial=$(gpg-yubikey-detect --quiet 2>/dev/null)

        if [[ -n "$serial" ]]; then
            if [[ "$quiet" == true ]]; then
                echo "$serial"
            else
                echo
                log "Connected YubiKey:"
                echo "  Serial: $serial"
                echo
            fi
            return 0
        else
            if [[ "$quiet" != true ]]; then
                log "No YubiKey detected"
            fi
            return 1
        fi
    fi
}
