#!/usr/bin/env bash
# keycutter/lib/gpg - Functions for GPG key management with YubiKey support
#
# Configuration:
# - gpg-config-load(): Load GPG configuration with precedence handling
# - gpg-config-get(): Get a specific configuration value
# - gpg-config-dump(): Dump all loaded configuration (for debugging)
#
# Version and Environment:
# - gpg-version-check(): Verify GPG version meets requirements
# - gpg-home-temp-create(): Create ephemeral GNUPGHOME for secure key operations
# - gpg-home-temp-cleanup(): Clean up ephemeral GNUPGHOME
# - gpg-agent-restart(): Restart gpg-agent with proper configuration
# - gpg-agent-ensure(): Ensure gpg-agent is running
#
# Key Creation:
# - gpg-master-key-create(): Create master (Certify) key in ephemeral GNUPGHOME
# - gpg-subkeys-create(): Create Sign, Encrypt, Auth subkeys for master key
# - gpg-identity-prompt(): Interactive prompt for user identity
# - gpg-passphrase-prompt(): Interactive prompt for passphrase with confirmation
#
# Key Listing:
# - gpg-card-status-display(): Parse and display GPG card status
# - gpg-master-keys-list(): List master keys from backup locations
#
# Backup:
# - gpg-key-backup(): Create encrypted backup of master key and subkeys
# - gpg-backup-readme-generate(): Generate README with restore instructions
# - gpg-backup-list(): List available backups from registered locations
# - gpg-backup-restore(): Restore keys from encrypted backup to GNUPGHOME
#
# YubiKey Detection and Service Management:
# - gpg-pcscd-ensure(): Ensure pcscd service is running
# - gpg-scdaemon-restart(): Restart scdaemon for smartcard refresh
# - gpg-yubikey-detect(): Detect YubiKey with retry logic
# - gpg-yubikey-openpgp-enabled(): Check if OpenPGP is enabled on YubiKey
# - gpg-card-has-keys(): Check if YubiKey has GPG keys installed
#
# PIN Management:
# - gpg-pin-generate(): Generate secure random PIN
# - gpg-pin-change-admin(): Change YubiKey admin PIN
# - gpg-pin-change-user(): Change YubiKey user PIN
# - gpg-card-reset(): Reset OpenPGP application on YubiKey
#
# Subkey Transfer:
# - gpg-key-to-yubikey(): Transfer subkeys (Sign, Encrypt, Auth) to YubiKey

KEYCUTTER_ROOT="$(readlink -f "$(dirname -- "${BASH_SOURCE[0]:-${0:A}}")/../")"
source "${KEYCUTTER_ROOT}/lib/utils"

# Minimum GPG version required for modern key types and features
GPG_MIN_VERSION="2.2.0"

# Track ephemeral home for cleanup
_GPG_EPHEMERAL_HOME=""

# Configuration storage (associative array)
declare -gA _GPG_CONFIG

gpg-config-load() {
    # Load GPG configuration from defaults and environment
    #
    # Configuration precedence (highest to lowest):
    #   1. CLI arguments (passed as name=value pairs)
    #   2. Environment variables (GPG_* prefix)
    #   3. User config file (~/.config/keycutter/gpg.conf)
    #   4. Default values (config/gpg/defaults)
    #
    # Arguments:
    #   $@ - Optional CLI overrides as name=value pairs
    #
    # Returns:
    #   0 on success
    #   1 if defaults file is missing
    #
    # Example:
    #   gpg-config-load GPG_KEY_TYPE=rsa4096 GPG_EXPIRATION=1y

    local defaults_file="${KEYCUTTER_ROOT}/config/gpg/defaults"
    local user_config="${XDG_CONFIG_HOME:-$HOME/.config}/keycutter/gpg.conf"

    # Reset config
    _GPG_CONFIG=()

    # 1. Load defaults (lowest precedence)
    if [[ -f "$defaults_file" ]]; then
        local line key value
        while IFS= read -r line || [[ -n "$line" ]]; do
            # Skip comments and empty lines
            [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue

            # Parse key=value (handling quoted values)
            if [[ "$line" =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
                key="${BASH_REMATCH[1]}"
                value="${BASH_REMATCH[2]}"
                # Remove surrounding quotes if present
                value="${value#\"}"
                value="${value%\"}"
                _GPG_CONFIG["$key"]="$value"
            fi
        done < "$defaults_file"
    else
        log "Warning: GPG defaults file not found: $defaults_file"
    fi

    # 2. Load user config file (if exists)
    if [[ -f "$user_config" ]]; then
        local line key value
        while IFS= read -r line || [[ -n "$line" ]]; do
            [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
            if [[ "$line" =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
                key="${BASH_REMATCH[1]}"
                value="${BASH_REMATCH[2]}"
                value="${value#\"}"
                value="${value%\"}"
                _GPG_CONFIG["$key"]="$value"
            fi
        done < "$user_config"
    fi

    # 3. Apply environment variable overrides
    local var
    for var in GPG_KEY_TYPE GPG_EXPIRATION GPG_MASTER_EXPIRATION GPG_IDENTITY \
               GPG_COMMENT GPG_CIPHER_PREFS GPG_DIGEST_PREFS GPG_COMPRESS_PREFS \
               GPG_DEFAULT_PREFS GPG_CERT_DIGEST GPG_BACKUP_DIR GPG_BACKUP_FORMAT \
               GPG_KEYSERVER YUBIKEY_TOUCH_POLICY YUBIKEY_PIN_RETRIES \
               YUBIKEY_ADMIN_PIN_RETRIES; do
        if [[ -n "${!var:-}" ]]; then
            _GPG_CONFIG["$var"]="${!var}"
        fi
    done

    # 4. Apply CLI argument overrides (highest precedence)
    local arg key value
    for arg in "$@"; do
        if [[ "$arg" =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
            key="${BASH_REMATCH[1]}"
            value="${BASH_REMATCH[2]}"
            _GPG_CONFIG["$key"]="$value"
        fi
    done

    return 0
}

gpg-config-get() {
    # Get a configuration value
    #
    # Arguments:
    #   $1 - Configuration key (e.g., GPG_KEY_TYPE)
    #   $2 - Default value if not set (optional)
    #
    # Returns:
    #   0 if key exists
    #   1 if key doesn't exist and no default provided
    #
    # Output:
    #   Prints the configuration value

    local key="$1"
    local default="${2:-}"

    if [[ -v "_GPG_CONFIG[$key]" ]]; then
        echo "${_GPG_CONFIG[$key]}"
        return 0
    elif [[ -n "$default" ]]; then
        echo "$default"
        return 0
    else
        return 1
    fi
}

gpg-config-dump() {
    # Dump all loaded configuration (for debugging)
    #
    # Returns:
    #   0 always
    #
    # Output:
    #   Prints all configuration key=value pairs

    local key
    for key in "${!_GPG_CONFIG[@]}"; do
        echo "${key}=${_GPG_CONFIG[$key]}"
    done | sort
}

gpg-version-check() {
    # Check if GPG is installed and meets minimum version requirement
    #
    # Arguments:
    #   $1 - Required version (optional, defaults to GPG_MIN_VERSION)
    #
    # Returns:
    #   0 if version requirement met
    #   1 if GPG not found or version too old
    #
    # Output:
    #   Prints GPG version on success, error message on failure

    local required_version="${1:-$GPG_MIN_VERSION}"

    if ! command -v gpg &>/dev/null; then
        log "Error: GPG is not installed"
        echo "Please install GnuPG 2.x:"
        echo "  macOS:  brew install gnupg"
        echo "  Ubuntu: sudo apt install gnupg2"
        echo "  Fedora: sudo dnf install gnupg2"
        return 1
    fi

    local gpg_version
    gpg_version=$(gpg --version | head -n1 | awk '{print $3}')

    if [[ $(check_version "$gpg_version" "$required_version") == "false" ]]; then
        log "Error: GPG version $gpg_version is too old (require >= $required_version)"
        return 1
    fi

    echo "$gpg_version"
    return 0
}

gpg-home-temp-create() {
    # Create a secure ephemeral GNUPGHOME directory
    #
    # This is critical for key generation security - the master key
    # should never touch persistent disk storage unencrypted.
    #
    # Arguments:
    #   $1 - Base directory (optional, defaults to system temp)
    #
    # Returns:
    #   0 on success, 1 on failure
    #
    # Output:
    #   Prints path to ephemeral GNUPGHOME
    #
    # Side effects:
    #   Sets GNUPGHOME environment variable
    #   Creates cleanup trap on EXIT

    local base_dir="${1:-}"
    local temp_home

    # Use ramfs/tmpfs if available for extra security
    if [[ -z "$base_dir" ]]; then
        if [[ -d /dev/shm ]]; then
            base_dir="/dev/shm"
        elif [[ "$OSTYPE" == "darwin"* ]]; then
            # macOS doesn't have /dev/shm, use secure temp
            base_dir="${TMPDIR:-/tmp}"
        else
            base_dir="/tmp"
        fi
    fi

    # Create unique temporary directory with restrictive permissions
    temp_home=$(mktemp -d "${base_dir}/gnupg.XXXXXXXXXX") || {
        log "Error: Failed to create temporary GNUPGHOME"
        return 1
    }

    chmod 700 "$temp_home" || {
        log "Error: Failed to set permissions on GNUPGHOME"
        rm -rf "$temp_home"
        return 1
    }

    # Store for cleanup
    _GPG_EPHEMERAL_HOME="$temp_home"

    # Export GNUPGHOME
    export GNUPGHOME="$temp_home"

    # Set up cleanup trap (additive, won't replace existing traps)
    trap 'gpg-home-temp-cleanup' EXIT

    log "Create ephemeral GNUPGHOME: $temp_home"
    echo "$temp_home"
    return 0
}

gpg-home-temp-cleanup() {
    # Securely clean up ephemeral GNUPGHOME
    #
    # This function securely removes the ephemeral GPG home directory.
    # On Linux with secure-delete available, uses srm for secure removal.
    #
    # Returns:
    #   0 on success or if nothing to clean
    #   1 on failure

    if [[ -z "$_GPG_EPHEMERAL_HOME" ]] || [[ ! -d "$_GPG_EPHEMERAL_HOME" ]]; then
        return 0
    fi

    # Kill any gpg-agent using this home
    if [[ -n "${GNUPGHOME:-}" ]] && [[ "$GNUPGHOME" == "$_GPG_EPHEMERAL_HOME" ]]; then
        gpgconf --homedir "$_GPG_EPHEMERAL_HOME" --kill gpg-agent 2>/dev/null || true
    fi

    # Secure removal if available, otherwise regular rm
    if command -v srm &>/dev/null; then
        log "Securely removing ephemeral GNUPGHOME"
        srm -rf "$_GPG_EPHEMERAL_HOME" 2>/dev/null || rm -rf "$_GPG_EPHEMERAL_HOME"
    else
        log "Removing ephemeral GNUPGHOME"
        rm -rf "$_GPG_EPHEMERAL_HOME"
    fi

    _GPG_EPHEMERAL_HOME=""
    unset GNUPGHOME

    return 0
}

gpg-agent-restart() {
    # Restart gpg-agent with proper configuration
    #
    # Arguments:
    #   $1 - GNUPGHOME to use (optional, uses current GNUPGHOME or default)
    #
    # Returns:
    #   0 on success
    #   1 on failure

    local gpg_home="${1:-${GNUPGHOME:-$HOME/.gnupg}}"

    log "Restarting gpg-agent"

    # Kill existing agent
    gpgconf --homedir "$gpg_home" --kill gpg-agent 2>/dev/null || true

    # Brief pause for socket cleanup
    sleep 0.5

    # Restart agent
    if ! gpg-connect-agent --homedir "$gpg_home" /bye &>/dev/null; then
        # Try alternative method
        gpg --homedir "$gpg_home" --list-keys &>/dev/null || {
            log "Error: Failed to restart gpg-agent"
            return 1
        }
    fi

    log "Success: gpg-agent restarted"
    return 0
}

gpg-agent-ensure() {
    # Ensure gpg-agent is running with proper configuration
    #
    # Arguments:
    #   $1 - GNUPGHOME to use (optional, uses current GNUPGHOME or default)
    #
    # Returns:
    #   0 on success
    #   1 on failure

    local gpg_home="${1:-${GNUPGHOME:-$HOME/.gnupg}}"

    # Check if agent is responding
    if gpg-connect-agent --homedir "$gpg_home" /bye &>/dev/null; then
        return 0
    fi

    # Agent not running, start it
    gpg-agent-restart "$gpg_home"
}

# =============================================================================
# Key Creation Functions
# =============================================================================

gpg-master-key-create() {
    # Create a GPG master (Certify) key in ephemeral GNUPGHOME
    #
    # This function creates a master key that will be used to certify subkeys.
    # The key is created in an ephemeral GNUPGHOME for security - it should
    # never touch persistent disk storage unencrypted.
    #
    # Arguments:
    #   --identity    User ID for the key (e.g., "Name <email@example.com>")
    #   --key-type    Algorithm: ed25519 (default) or rsa4096
    #   --expiration  Expiration period: 0 (never), 1y, 2y, etc. (default: 0)
    #   --passphrase  Passphrase for the key (will prompt if not provided)
    #
    # Returns:
    #   0 on success
    #   1 on failure
    #
    # Output:
    #   Prints the key fingerprint on success
    #
    # Environment:
    #   GNUPGHOME must be set to ephemeral directory (use gpg-home-temp-create)
    #
    # Example:
    #   gpg-home-temp-create
    #   gpg-master-key-create --identity "Test User <test@example.com>"

    local identity=""
    local key_type=""
    local expiration=""
    local passphrase=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --identity)
                identity="$2"
                shift 2
                ;;
            --key-type)
                key_type="$2"
                shift 2
                ;;
            --expiration)
                expiration="$2"
                shift 2
                ;;
            --passphrase)
                passphrase="$2"
                shift 2
                ;;
            *)
                log "Error: Unknown option: $1"
                return 1
                ;;
        esac
    done

    # Load config for defaults
    gpg-config-load

    # Use provided values or fall back to config
    key_type="${key_type:-$(gpg-config-get GPG_KEY_TYPE ed25519)}"
    expiration="${expiration:-$(gpg-config-get GPG_MASTER_EXPIRATION 0)}"

    # Validate required parameters
    if [[ -z "$identity" ]]; then
        log "Error: --identity is required"
        log "Example: --identity 'Your Name <your@email.com>'"
        return 1
    fi

    # Validate GNUPGHOME is set and is ephemeral
    if [[ -z "${GNUPGHOME:-}" ]]; then
        log "Error: GNUPGHOME not set. Use gpg-home-temp-create first."
        return 1
    fi

    if [[ ! -d "$GNUPGHOME" ]]; then
        log "Error: GNUPGHOME directory does not exist: $GNUPGHOME"
        return 1
    fi

    # Validate key type
    case "$key_type" in
        ed25519|rsa4096|rsa3072)
            ;;
        *)
            log "Error: Invalid key type: $key_type"
            log "Supported types: ed25519, rsa4096, rsa3072"
            return 1
            ;;
    esac

    # Copy GPG configuration to ephemeral home
    local gpg_conf="${KEYCUTTER_ROOT}/config/gpg/gpg.conf"
    if [[ -f "$gpg_conf" ]]; then
        cp "$gpg_conf" "$GNUPGHOME/gpg.conf"
    fi

    # Configure gpg-agent for pinentry-loopback
    cat > "$GNUPGHOME/gpg-agent.conf" <<EOF
allow-loopback-pinentry
EOF

    # Restart agent with new config
    gpg-agent-restart "$GNUPGHOME" >/dev/null 2>&1

    log "Creating master key for: $identity"
    log "Key type: $key_type, Expiration: ${expiration:-never}"

    # Build the gpg command
    local gpg_cmd=(
        gpg
        --homedir "$GNUPGHOME"
        --batch
        --expert
    )

    # Add passphrase handling
    if [[ -n "$passphrase" ]]; then
        gpg_cmd+=(--pinentry-mode loopback --passphrase "$passphrase")
    fi

    # Generate the master key (Certify only)
    if ! "${gpg_cmd[@]}" --quick-generate-key "$identity" "$key_type" cert "$expiration" 2>&1; then
        log "Error: Failed to create master key"
        return 1
    fi

    # Get the key fingerprint
    local fingerprint
    fingerprint=$(gpg --homedir "$GNUPGHOME" --list-keys --with-colons "$identity" 2>/dev/null | awk -F: '/^fpr:/ { print $10; exit }')

    if [[ -z "$fingerprint" ]]; then
        log "Error: Failed to retrieve key fingerprint"
        return 1
    fi

    log "Success: Master key created"
    echo "$fingerprint"
    return 0
}

gpg-subkeys-create() {
    # Create subkeys (Sign, Encrypt, Auth) for an existing master key
    #
    # This function generates the three operational subkeys that will be
    # transferred to YubiKey. The master key (Certify only) remains secure
    # in the ephemeral GNUPGHOME or backup storage.
    #
    # Arguments:
    #   --fingerprint  Master key fingerprint (required)
    #   --key-type     Algorithm: ed25519 (default) or rsa4096
    #   --expiration   Expiration period: 2y (default), 1y, etc.
    #   --passphrase   Passphrase for the master key (required)
    #
    # Returns:
    #   0 on success (all 3 subkeys created)
    #   1 on failure
    #
    # Output:
    #   Prints subkey fingerprints on success
    #
    # Environment:
    #   GNUPGHOME must be set and contain the master key
    #
    # Example:
    #   gpg-subkeys-create --fingerprint "$FP" --passphrase "$PASS"

    local fingerprint=""
    local key_type=""
    local expiration=""
    local passphrase=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --fingerprint)
                fingerprint="$2"
                shift 2
                ;;
            --key-type)
                key_type="$2"
                shift 2
                ;;
            --expiration)
                expiration="$2"
                shift 2
                ;;
            --passphrase)
                passphrase="$2"
                shift 2
                ;;
            *)
                log "Error: Unknown option: $1"
                return 1
                ;;
        esac
    done

    # Load config for defaults
    gpg-config-load

    # Use provided values or fall back to config
    key_type="${key_type:-$(gpg-config-get GPG_KEY_TYPE ed25519)}"
    expiration="${expiration:-$(gpg-config-get GPG_EXPIRATION 2y)}"

    # Validate required parameters
    if [[ -z "$fingerprint" ]]; then
        log "Error: --fingerprint is required"
        return 1
    fi

    if [[ -z "$passphrase" ]]; then
        log "Error: --passphrase is required for batch subkey creation"
        return 1
    fi

    # Validate GNUPGHOME is set
    if [[ -z "${GNUPGHOME:-}" ]]; then
        log "Error: GNUPGHOME not set"
        return 1
    fi

    if [[ ! -d "$GNUPGHOME" ]]; then
        log "Error: GNUPGHOME directory does not exist: $GNUPGHOME"
        return 1
    fi

    # Validate key type
    case "$key_type" in
        ed25519|rsa4096|rsa3072)
            ;;
        *)
            log "Error: Invalid key type: $key_type"
            log "Supported types: ed25519, rsa4096, rsa3072"
            return 1
            ;;
    esac

    # Verify master key exists in GNUPGHOME
    if ! gpg --homedir "$GNUPGHOME" --list-keys "$fingerprint" &>/dev/null; then
        log "Error: Master key not found: $fingerprint"
        return 1
    fi

    log "Creating subkeys for master key: ${fingerprint:0:16}..."
    log "Key type: $key_type, Expiration: $expiration"

    # Subkey capabilities to create
    local subkeys=("sign" "encrypt" "auth")
    local created_count=0

    for subkey in "${subkeys[@]}"; do
        log "Creating $subkey subkey..."

        if gpg --homedir "$GNUPGHOME" \
               --batch \
               --pinentry-mode loopback \
               --passphrase "$passphrase" \
               --quick-add-key "$fingerprint" "$key_type" "$subkey" "$expiration" 2>&1; then
            log "Success: $subkey subkey created"
            created_count=$((created_count + 1))
        else
            log "Error: Failed to create $subkey subkey"
            return 1
        fi
    done

    # Verify all subkeys were created
    if [[ $created_count -ne 3 ]]; then
        log "Error: Expected 3 subkeys, created $created_count"
        return 1
    fi

    # List the subkeys we created
    local subkey_info
    subkey_info=$(gpg --homedir "$GNUPGHOME" --list-keys --with-colons "$fingerprint" 2>/dev/null | \
        awk -F: '/^sub:/ { print $5 }')

    log "Success: All subkeys created"
    echo "$subkey_info"
    return 0
}

gpg-identity-prompt() {
    # Interactively prompt for GPG identity components
    #
    # Arguments:
    #   $1 - Variable name to store result
    #
    # Returns:
    #   0 on success
    #   1 on user cancellation or invalid input
    #
    # Output:
    #   Sets the named variable to "Real Name <email@example.com>" format

    local result_var="$1"
    local name email identity

    echo
    echo "Enter your identity for the GPG key:"
    echo

    read -rp "  Real Name: " name
    if [[ -z "$name" ]]; then
        log "Error: Name is required"
        return 1
    fi

    read -rp "  Email: " email
    if [[ -z "$email" ]]; then
        log "Error: Email is required"
        return 1
    fi

    # Validate email format (basic check)
    if [[ ! "$email" =~ ^[^@]+@[^@]+\.[^@]+$ ]]; then
        log "Error: Invalid email format"
        return 1
    fi

    identity="$name <$email>"

    echo
    echo "  Identity: $identity"
    echo

    read -rp "  Is this correct? [Y/n] " confirm
    if [[ "$confirm" =~ ^[Nn] ]]; then
        return 1
    fi

    # Set the result variable
    printf -v "$result_var" '%s' "$identity"
    return 0
}

gpg-passphrase-prompt() {
    # Interactively prompt for GPG passphrase with confirmation
    #
    # Arguments:
    #   $1 - Variable name to store result
    #
    # Returns:
    #   0 on success
    #   1 on user cancellation or mismatch

    local result_var="$1"
    local pass1 pass2

    echo
    echo "Enter a strong passphrase to protect your GPG master key."
    echo "This passphrase protects your master key backup."
    echo

    read -rsp "  Passphrase: " pass1
    echo

    if [[ -z "$pass1" ]]; then
        log "Error: Passphrase cannot be empty"
        return 1
    fi

    # Check minimum length
    if [[ ${#pass1} -lt 8 ]]; then
        log "Error: Passphrase must be at least 8 characters"
        return 1
    fi

    read -rsp "  Confirm passphrase: " pass2
    echo

    if [[ "$pass1" != "$pass2" ]]; then
        log "Error: Passphrases do not match"
        return 1
    fi

    # Set the result variable
    printf -v "$result_var" '%s' "$pass1"
    return 0
}

# =============================================================================
# Key Listing Functions
# =============================================================================

gpg-card-status-display() {
    # Parse and display GPG card status in a clean format
    #
    # Arguments:
    #   $1 - Card status output from 'gpg --card-status'
    #
    # Output:
    #   Formatted display of card information and keys

    local card_status="$1"
    local reader serial_number card_holder
    local sig_key enc_key auth_key
    local general_key_info

    # Extract card info
    reader=$(echo "$card_status" | grep "^Reader" | sed 's/Reader[^:]*: *//')
    serial_number=$(echo "$card_status" | grep "^Serial number" | awk '{print $NF}')
    card_holder=$(echo "$card_status" | grep "^Name of cardholder" | sed 's/Name of cardholder: *//')

    # Extract key information
    sig_key=$(echo "$card_status" | grep "^Signature key" | sed 's/Signature key[^:]*: *//')
    enc_key=$(echo "$card_status" | grep "^Encryption key" | sed 's/Encryption key[^:]*: *//')
    auth_key=$(echo "$card_status" | grep "^Authentication key" | sed 's/Authentication key[^:]*: *//')

    # Check for general key info (indicates keys are properly linked)
    general_key_info=$(echo "$card_status" | grep "^General key info")

    # Display card information
    if [[ -n "$reader" ]]; then
        echo "  Reader:        $reader"
    fi
    if [[ -n "$serial_number" ]]; then
        echo "  Serial:        $serial_number"
    fi
    if [[ -n "$card_holder" && "$card_holder" != " " ]]; then
        echo "  Cardholder:    $card_holder"
    fi

    echo

    # Display keys with their status
    if [[ -n "$sig_key" && "$sig_key" != "[none]" ]]; then
        echo "  [S] Signature:     ${sig_key:0:16}..."
    else
        echo "  [S] Signature:     (not set)"
    fi

    if [[ -n "$enc_key" && "$enc_key" != "[none]" ]]; then
        echo "  [E] Encryption:    ${enc_key:0:16}..."
    else
        echo "  [E] Encryption:    (not set)"
    fi

    if [[ -n "$auth_key" && "$auth_key" != "[none]" ]]; then
        echo "  [A] Authentication: ${auth_key:0:16}..."
    else
        echo "  [A] Authentication: (not set)"
    fi

    # Show key status hint
    if [[ -z "$general_key_info" ]] && [[ "$sig_key" != "[none]" || "$enc_key" != "[none]" || "$auth_key" != "[none]" ]]; then
        echo
        echo "  Note: Keys present but not linked to local keyring."
        echo "  Run 'gpg --card-status' to fetch public keys."
    fi
}

# =============================================================================
# Backup Functions
# =============================================================================

gpg-key-backup() {
    # Create encrypted backup of GPG master key and subkeys
    #
    # This function exports the master key, subkeys, and public key in ASCII
    # armor format, then creates an encrypted archive for secure storage.
    #
    # Arguments:
    #   --fingerprint  Key fingerprint to backup (required)
    #   --output-dir   Directory to store backup (default: from config or prompted)
    #   --passphrase   Key passphrase for export (will prompt if not provided)
    #   --backup-pass  Passphrase for backup encryption (will prompt if not provided)
    #
    # Returns:
    #   0 on success
    #   1 on failure
    #
    # Output:
    #   Prints path to encrypted backup on success
    #
    # Environment:
    #   GNUPGHOME must be set and contain the key to backup
    #
    # Example:
    #   gpg-key-backup --fingerprint "ABCD1234..." --output-dir ~/gpg-backups

    local fingerprint=""
    local output_dir=""
    local passphrase=""
    local backup_pass=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --fingerprint)
                fingerprint="$2"
                shift 2
                ;;
            --output-dir)
                output_dir="$2"
                shift 2
                ;;
            --passphrase)
                passphrase="$2"
                shift 2
                ;;
            --backup-pass)
                backup_pass="$2"
                shift 2
                ;;
            *)
                log "Error: Unknown option: $1"
                return 1
                ;;
        esac
    done

    # Load config for defaults
    gpg-config-load

    # Get output directory from config if not provided
    if [[ -z "$output_dir" ]]; then
        output_dir=$(gpg-config-get GPG_BACKUP_DIR "")
        output_dir="${output_dir/#\~/$HOME}"
    fi

    # Validate required parameters
    if [[ -z "$fingerprint" ]]; then
        log "Error: --fingerprint is required"
        return 1
    fi

    if [[ -z "$output_dir" ]]; then
        log "Error: --output-dir is required (or set GPG_BACKUP_DIR in config)"
        return 1
    fi

    # Validate GNUPGHOME
    if [[ -z "${GNUPGHOME:-}" ]]; then
        log "Error: GNUPGHOME not set"
        return 1
    fi

    if [[ ! -d "$GNUPGHOME" ]]; then
        log "Error: GNUPGHOME directory does not exist: $GNUPGHOME"
        return 1
    fi

    # Verify key exists
    if ! gpg --homedir "$GNUPGHOME" --list-secret-keys "$fingerprint" &>/dev/null; then
        log "Error: Key not found: $fingerprint"
        return 1
    fi

    # Get key UID for directory naming
    local uid
    uid=$(gpg --homedir "$GNUPGHOME" --list-keys --with-colons "$fingerprint" 2>/dev/null | \
        awk -F: '/^uid:/ {print $10; exit}')

    # Create backup directory with date and short fingerprint
    local date_stamp
    date_stamp=$(date +%Y-%m-%d)
    local short_fp="${fingerprint: -8}"
    local backup_name="gpg-backup-${date_stamp}-${short_fp}"
    local backup_dir="${output_dir}/${backup_name}"

    # Create output and backup directories
    mkdir -p "$output_dir" || {
        log "Error: Failed to create output directory: $output_dir"
        return 1
    }

    mkdir -p "$backup_dir" || {
        log "Error: Failed to create backup directory: $backup_dir"
        return 1
    }
    chmod 700 "$backup_dir"

    log "Creating backup for key: ${fingerprint:0:16}..."
    log "Backup directory: $backup_dir"

    # Export files with proper permissions
    local export_cmd_base=(
        gpg --homedir "$GNUPGHOME" --armor
    )

    if [[ -n "$passphrase" ]]; then
        export_cmd_base+=(--batch --pinentry-mode loopback --passphrase "$passphrase")
    fi

    # 1. Export master secret key
    log "Exporting master key..."
    if ! "${export_cmd_base[@]}" --export-secret-keys "$fingerprint" > "$backup_dir/master-key.asc" 2>/dev/null; then
        log "Error: Failed to export master key"
        rm -rf "$backup_dir"
        return 1
    fi
    chmod 600 "$backup_dir/master-key.asc"

    # 2. Export secret subkeys only (for separate backup)
    log "Exporting subkeys..."
    if ! "${export_cmd_base[@]}" --export-secret-subkeys "$fingerprint" > "$backup_dir/subkeys.asc" 2>/dev/null; then
        log "Warning: No subkeys to export (may be master-only key)"
        rm -f "$backup_dir/subkeys.asc"
    else
        chmod 600 "$backup_dir/subkeys.asc"
    fi

    # 3. Export public key
    log "Exporting public key..."
    if ! gpg --homedir "$GNUPGHOME" --armor --export "$fingerprint" > "$backup_dir/public-key.asc" 2>/dev/null; then
        log "Error: Failed to export public key"
        rm -rf "$backup_dir"
        return 1
    fi

    # 4. Generate revocation certificate
    log "Generating revocation certificate..."
    local revoke_cmd=(gpg --homedir "$GNUPGHOME" --armor --output "$backup_dir/revocation-cert.asc")
    if [[ -n "$passphrase" ]]; then
        revoke_cmd+=(--batch --pinentry-mode loopback --passphrase "$passphrase")
    fi
    revoke_cmd+=(--gen-revoke "$fingerprint")

    # Generate revoke cert (requires answering 'y' and providing reason)
    if [[ -n "$passphrase" ]]; then
        echo -e "y\n0\n\ny\n" | "${revoke_cmd[@]}" 2>/dev/null || {
            log "Warning: Failed to generate revocation certificate"
            rm -f "$backup_dir/revocation-cert.asc"
        }
    else
        log "Skipping revocation cert generation (requires passphrase in batch mode)"
    fi

    if [[ -f "$backup_dir/revocation-cert.asc" ]]; then
        chmod 600 "$backup_dir/revocation-cert.asc"
    fi

    # 5. Export ownertrust
    log "Exporting trust database..."
    gpg --homedir "$GNUPGHOME" --export-ownertrust > "$backup_dir/ownertrust.txt" 2>/dev/null || true

    # 6. Generate README with restore instructions
    log "Generating restore instructions..."
    gpg-backup-readme-generate "$backup_dir" "$fingerprint" "$uid"

    # 7. Create encrypted archive
    log "Creating encrypted backup archive..."
    local encrypted_backup="${output_dir}/${backup_name}.tar.gz.gpg"

    local encrypt_cmd=(gpg --symmetric --cipher-algo AES256 --armor)
    if [[ -n "$backup_pass" ]]; then
        encrypt_cmd+=(--batch --pinentry-mode loopback --passphrase "$backup_pass")
    fi

    if ! tar -czf - -C "$output_dir" "$backup_name" | "${encrypt_cmd[@]}" > "$encrypted_backup" 2>/dev/null; then
        log "Error: Failed to create encrypted backup"
        rm -rf "$backup_dir"
        return 1
    fi
    chmod 600 "$encrypted_backup"

    # 8. Clean up unencrypted backup directory
    log "Cleaning up unencrypted files..."
    rm -rf "$backup_dir"

    log "Success: Backup created"
    echo "$encrypted_backup"
    return 0
}

gpg-backup-readme-generate() {
    # Generate README file with restore instructions
    #
    # Arguments:
    #   $1 - Backup directory path
    #   $2 - Key fingerprint
    #   $3 - User ID (optional)
    #
    # Returns:
    #   0 always

    local backup_dir="$1"
    local fingerprint="$2"
    local uid="${3:-}"
    local date_stamp
    date_stamp=$(date +%Y-%m-%d)

    cat > "$backup_dir/README.md" <<EOF
# GPG Key Backup

**Created:** ${date_stamp}
**Fingerprint:** ${fingerprint}
**User ID:** ${uid:-Unknown}

## Contents

- \`master-key.asc\` - Master (Certify) key and subkeys - **KEEP SECURE!**
- \`subkeys.asc\` - Secret subkeys only (Sign, Encrypt, Auth)
- \`public-key.asc\` - Public key for distribution
- \`revocation-cert.asc\` - Revocation certificate - **KEEP SECURE!**
- \`ownertrust.txt\` - GPG trust database
- \`README.md\` - This file

## Restore Instructions

### Full Restore (Master Key + Subkeys)

Use this when you need full access to your master key (e.g., for signing other keys,
creating new subkeys, or extending expiration).

\`\`\`bash
# 1. Create a secure ephemeral environment
export GNUPGHOME=\$(mktemp -d)
chmod 700 \$GNUPGHOME

# 2. Import the master key
gpg --import master-key.asc

# 3. Import trust settings
gpg --import-ownertrust ownertrust.txt

# 4. Verify import
gpg --list-secret-keys
\`\`\`

### Subkeys-Only Restore (Daily Use)

Use this to restore just the subkeys to your regular keyring.
The master key stays safely in backup.

\`\`\`bash
# 1. Import subkeys only
gpg --import subkeys.asc

# 2. Import trust settings
gpg --import-ownertrust ownertrust.txt

# 3. Verify import (should show 'sec#' for master - stub only)
gpg --list-secret-keys
\`\`\`

### Transfer to YubiKey

After restoring the master key, you can transfer subkeys to a YubiKey:

\`\`\`bash
keycutter gpg key install --fingerprint ${fingerprint}
\`\`\`

### Publish Public Key

To publish your public key to a keyserver:

\`\`\`bash
gpg --send-keys ${fingerprint}
\`\`\`

Or distribute \`public-key.asc\` directly.

## Security Notes

- **Master key** should only be accessed in air-gapped or ephemeral environments
- **Revocation certificate** can revoke your key - keep it separate and secure
- Store multiple copies in geographically separate secure locations
- Consider storing on encrypted USB drives or in secure cloud storage

## Decrypting This Backup

If you received this as an encrypted \`.tar.gz.gpg\` file:

\`\`\`bash
# Decrypt and extract
gpg --decrypt backup.tar.gz.gpg | tar -xzf -
\`\`\`

---
*Generated by keycutter gpg backup*
EOF

    return 0
}

gpg-master-keys-list() {
    # List available master keys from registered backup locations
    #
    # Searches for GPG key backups in registered locations and displays
    # information about available master keys.
    #
    # Returns:
    #   0 if keys found
    #   1 if no backup locations configured or no keys found

    # Load config to get backup locations
    gpg-config-load

    local backup_dir
    backup_dir=$(gpg-config-get GPG_BACKUP_DIR "")

    if [[ -z "$backup_dir" ]]; then
        echo "  No backup location configured."
        echo "  Set GPG_BACKUP_DIR in config or use 'keycutter gpg backup' to create backups."
        return 1
    fi

    # Expand path
    backup_dir="${backup_dir/#\~/$HOME}"

    if [[ ! -d "$backup_dir" ]]; then
        echo "  Backup directory not found: $backup_dir"
        return 1
    fi

    # Search for key files
    local found_keys=0
    local key_file keyid uid

    # Look for common backup patterns: *.asc, *.gpg, private-key*.asc
    for key_file in "$backup_dir"/*.asc "$backup_dir"/*.gpg "$backup_dir"/*/secret-key*.asc "$backup_dir"/*/master*.asc; do
        if [[ -f "$key_file" ]]; then
            # Extract key info using gpg --show-keys
            keyid=$(gpg --show-keys --with-colons "$key_file" 2>/dev/null | awk -F: '/^sec:/ {print $5; exit}')
            uid=$(gpg --show-keys --with-colons "$key_file" 2>/dev/null | awk -F: '/^uid:/ {print $10; exit}')

            if [[ -n "$keyid" ]]; then
                found_keys=$((found_keys + 1))
                echo "  $keyid"
                if [[ -n "$uid" ]]; then
                    echo "    └─ $uid"
                fi
                echo "    └─ $(basename "$key_file")"
                echo
            fi
        fi
    done

    if [[ $found_keys -eq 0 ]]; then
        echo "  No master keys found in: $backup_dir"
        return 1
    fi

    echo "  Found $found_keys master key(s)"
    return 0
}

# =============================================================================
# YubiKey Detection and Service Management (gpg-010)
# =============================================================================

gpg-pcscd-ensure() {
    # Ensure pcscd service is running (required for smartcard access)
    #
    # This function checks if pcscd is running and starts it if needed.
    # On macOS, pcscd is typically managed by the system.
    # On Linux, it may need to be started via systemctl or service.
    #
    # Returns:
    #   0 if pcscd is running or successfully started
    #   1 if pcscd cannot be started

    # Check if pcscd is needed - skip on macOS where it's automatic
    if [[ "$OSTYPE" == "darwin"* ]]; then
        # macOS handles smartcard daemon automatically
        return 0
    fi

    # On Linux, check and start pcscd if needed
    if command -v systemctl &>/dev/null; then
        if ! systemctl is-active --quiet pcscd; then
            log "Starting pcscd service..."
            if ! sudo systemctl start pcscd; then
                log "Error: Failed to start pcscd service"
                echo "Try: sudo systemctl start pcscd"
                return 1
            fi
            sleep 1
        fi
    elif command -v service &>/dev/null; then
        if ! service pcscd status &>/dev/null; then
            log "Starting pcscd service..."
            if ! sudo service pcscd start; then
                log "Error: Failed to start pcscd service"
                return 1
            fi
            sleep 1
        fi
    fi

    return 0
}

gpg-scdaemon-restart() {
    # Restart scdaemon to refresh smartcard connection
    #
    # scdaemon is the GPG smartcard daemon that communicates with the YubiKey.
    # Sometimes it needs to be restarted after the YubiKey is inserted or
    # after configuration changes.
    #
    # Returns:
    #   0 on success
    #   1 on failure

    local gpg_home="${GNUPGHOME:-$HOME/.gnupg}"

    log "Restarting scdaemon..."

    # Kill existing scdaemon
    gpgconf --kill scdaemon 2>/dev/null || true

    # Brief pause for cleanup
    sleep 0.5

    # Restart via gpg-connect-agent
    if ! gpg-connect-agent "SCD RESTART" /bye &>/dev/null; then
        # Try alternative method - just trigger card access
        gpg --card-status &>/dev/null || true
    fi

    sleep 0.5
    return 0
}

gpg-yubikey-detect() {
    # Detect YubiKey with OpenPGP application
    #
    # This function attempts to detect a YubiKey with OpenPGP support.
    # It uses retry logic since the YubiKey may take a moment to be recognized
    # after insertion.
    #
    # Arguments:
    #   --retries N   Number of retry attempts (default: 3)
    #   --delay N     Delay between retries in seconds (default: 2)
    #   --quiet       Suppress status messages
    #
    # Returns:
    #   0 if YubiKey with OpenPGP detected
    #   1 if no YubiKey found
    #
    # Output:
    #   Prints serial number on success (unless --quiet)

    local retries=3
    local delay=2
    local quiet=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --retries)
                retries="$2"
                shift 2
                ;;
            --delay)
                delay="$2"
                shift 2
                ;;
            --quiet)
                quiet=true
                shift
                ;;
            *)
                log "Error: Unknown option: $1"
                return 1
                ;;
        esac
    done

    # Ensure pcscd is running
    gpg-pcscd-ensure || return 1

    local attempt=1
    local card_status serial_number

    while [[ $attempt -le $retries ]]; do
        # Try to get card status
        if card_status=$(gpg --card-status 2>&1); then
            # Extract serial number
            serial_number=$(echo "$card_status" | grep "^Serial number" | awk '{print $NF}')

            if [[ -n "$serial_number" ]]; then
                if [[ "$quiet" != "true" ]]; then
                    log "YubiKey detected: $serial_number"
                fi
                echo "$serial_number"
                return 0
            fi
        fi

        # Not found yet
        if [[ "$quiet" != "true" && $attempt -lt $retries ]]; then
            log "Attempt $attempt/$retries: YubiKey not detected, retrying in ${delay}s..."
        fi

        if [[ $attempt -lt $retries ]]; then
            sleep "$delay"
            # Restart scdaemon between attempts
            gpg-scdaemon-restart &>/dev/null
        fi

        attempt=$((attempt + 1))
    done

    if [[ "$quiet" != "true" ]]; then
        log "Error: YubiKey with OpenPGP not detected"
        echo "Troubleshooting:"
        echo "  - Ensure YubiKey is inserted"
        echo "  - Try removing and reinserting the YubiKey"
        echo "  - Check: ykman list"
        echo "  - Check: gpg --card-status"
    fi
    return 1
}

gpg-yubikey-openpgp-enabled() {
    # Check if OpenPGP application is enabled on YubiKey
    #
    # Requires ykman (YubiKey Manager) to be installed.
    #
    # Returns:
    #   0 if OpenPGP is enabled
    #   1 if OpenPGP is disabled or ykman not available

    if ! command -v ykman &>/dev/null; then
        log "Warning: ykman not installed, cannot check OpenPGP status"
        # Fall back to gpg --card-status test
        if gpg --card-status &>/dev/null; then
            return 0
        fi
        return 1
    fi

    if ykman info 2>/dev/null | grep -q "OpenPGP.*Enabled"; then
        return 0
    else
        log "OpenPGP application is not enabled on YubiKey"
        echo "Enable with: ykman config usb --enable OPENPGP"
        return 1
    fi
}

gpg-card-has-keys() {
    # Check if the YubiKey already has GPG keys installed
    #
    # Returns:
    #   0 if keys are present
    #   1 if no keys or card not accessible
    #
    # Output:
    #   Prints "empty", "partial", or "full" to indicate key status

    local card_status
    card_status=$(gpg --card-status 2>&1) || return 1

    local sig_key enc_key auth_key
    sig_key=$(echo "$card_status" | grep "^Signature key" | grep -v "\[none\]")
    enc_key=$(echo "$card_status" | grep "^Encryption key" | grep -v "\[none\]")
    auth_key=$(echo "$card_status" | grep "^Authentication key" | grep -v "\[none\]")

    local key_count=0
    [[ -n "$sig_key" ]] && key_count=$((key_count + 1))
    [[ -n "$enc_key" ]] && key_count=$((key_count + 1))
    [[ -n "$auth_key" ]] && key_count=$((key_count + 1))

    if [[ $key_count -eq 0 ]]; then
        echo "empty"
        return 1
    elif [[ $key_count -eq 3 ]]; then
        echo "full"
        return 0
    else
        echo "partial"
        return 0
    fi
}

# =============================================================================
# PIN Management Functions (gpg-010)
# =============================================================================

gpg-pin-generate() {
    # Generate a secure random PIN
    #
    # Arguments:
    #   --length N    PIN length (default: 8 for admin, 6 for user)
    #   --type TYPE   "admin" (8 digits) or "user" (6 digits)
    #
    # Returns:
    #   0 on success
    #
    # Output:
    #   Prints the generated PIN

    local length=""
    local pin_type="user"

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --length)
                length="$2"
                shift 2
                ;;
            --type)
                pin_type="$2"
                shift 2
                ;;
            *)
                log "Error: Unknown option: $1"
                return 1
                ;;
        esac
    done

    # Set default length based on type
    if [[ -z "$length" ]]; then
        case "$pin_type" in
            admin) length=8 ;;
            user)  length=6 ;;
            *)
                log "Error: Unknown PIN type: $pin_type"
                return 1
                ;;
        esac
    fi

    # Generate random PIN using /dev/urandom
    local pin
    pin=$(LC_ALL=C tr -dc '0-9' < /dev/urandom | fold -w"$length" | head -1)

    echo "$pin"
    return 0
}

gpg-pin-change-admin() {
    # Change the YubiKey admin PIN
    #
    # The admin PIN is used for administrative operations like transferring
    # keys to the card. Default factory admin PIN is 12345678.
    #
    # Arguments:
    #   --old-pin PIN     Current admin PIN (default: 12345678)
    #   --new-pin PIN     New admin PIN (will prompt if not provided)
    #
    # Returns:
    #   0 on success
    #   1 on failure
    #
    # Note: Admin PIN must be 8-127 characters.
    #       3 incorrect attempts will DESTROY data on YubiKey!

    local old_pin="12345678"  # Factory default
    local new_pin=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --old-pin)
                old_pin="$2"
                shift 2
                ;;
            --new-pin)
                new_pin="$2"
                shift 2
                ;;
            *)
                log "Error: Unknown option: $1"
                return 1
                ;;
        esac
    done

    # Validate new PIN length
    if [[ -n "$new_pin" && ${#new_pin} -lt 8 ]]; then
        log "Error: Admin PIN must be at least 8 characters"
        return 1
    fi

    # Prompt for new PIN if not provided
    if [[ -z "$new_pin" ]]; then
        echo
        echo "Enter new admin PIN (minimum 8 characters):"
        read -rsp "  New admin PIN: " new_pin
        echo
        if [[ ${#new_pin} -lt 8 ]]; then
            log "Error: Admin PIN must be at least 8 characters"
            return 1
        fi
        local confirm_pin
        read -rsp "  Confirm PIN: " confirm_pin
        echo
        if [[ "$new_pin" != "$confirm_pin" ]]; then
            log "Error: PINs do not match"
            return 1
        fi
    fi

    log "Changing admin PIN..."

    # Use gpg --change-pin with command-fd for non-interactive operation
    # Menu option 3 = Change Admin PIN
    if echo -e "3\n${old_pin}\n${new_pin}\n${new_pin}\nq\n" | \
       gpg --command-fd=0 --pinentry-mode=loopback --change-pin 2>&1; then
        log "Success: Admin PIN changed"
        return 0
    else
        log "Error: Failed to change admin PIN"
        echo "Note: 3 incorrect admin PIN attempts will destroy data on YubiKey"
        return 1
    fi
}

gpg-pin-change-user() {
    # Change the YubiKey user PIN
    #
    # The user PIN is used for signing and decryption operations.
    # Default factory user PIN is 123456.
    #
    # Arguments:
    #   --old-pin PIN     Current user PIN (default: 123456)
    #   --new-pin PIN     New user PIN (will prompt if not provided)
    #
    # Returns:
    #   0 on success
    #   1 on failure
    #
    # Note: User PIN must be 6-127 characters.
    #       3 incorrect attempts will require admin PIN to unblock.

    local old_pin="123456"  # Factory default
    local new_pin=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --old-pin)
                old_pin="$2"
                shift 2
                ;;
            --new-pin)
                new_pin="$2"
                shift 2
                ;;
            *)
                log "Error: Unknown option: $1"
                return 1
                ;;
        esac
    done

    # Validate new PIN length
    if [[ -n "$new_pin" && ${#new_pin} -lt 6 ]]; then
        log "Error: User PIN must be at least 6 characters"
        return 1
    fi

    # Prompt for new PIN if not provided
    if [[ -z "$new_pin" ]]; then
        echo
        echo "Enter new user PIN (minimum 6 characters):"
        read -rsp "  New user PIN: " new_pin
        echo
        if [[ ${#new_pin} -lt 6 ]]; then
            log "Error: User PIN must be at least 6 characters"
            return 1
        fi
        local confirm_pin
        read -rsp "  Confirm PIN: " confirm_pin
        echo
        if [[ "$new_pin" != "$confirm_pin" ]]; then
            log "Error: PINs do not match"
            return 1
        fi
    fi

    log "Changing user PIN..."

    # Use gpg --change-pin with command-fd for non-interactive operation
    # Menu option 1 = Change User PIN
    if echo -e "1\n${old_pin}\n${new_pin}\n${new_pin}\nq\n" | \
       gpg --command-fd=0 --pinentry-mode=loopback --change-pin 2>&1; then
        log "Success: User PIN changed"
        return 0
    else
        log "Error: Failed to change user PIN"
        echo "Note: 3 incorrect user PIN attempts will require admin PIN to unblock"
        return 1
    fi
}

# =============================================================================
# Subkey Transfer to YubiKey (gpg-011)
# =============================================================================

gpg-key-to-yubikey() {
    # Transfer GPG subkeys to YubiKey
    #
    # This function transfers the Sign, Encrypt, and Auth subkeys from the
    # current GNUPGHOME to a YubiKey. After transfer, the local keys become
    # stubs pointing to the hardware device.
    #
    # Arguments:
    #   --fingerprint FP    Master key fingerprint (required)
    #   --passphrase PASS   Key passphrase (required)
    #   --admin-pin PIN     YubiKey admin PIN (default: 12345678)
    #   --force             Overwrite existing keys on YubiKey
    #
    # Returns:
    #   0 on success (all 3 subkeys transferred)
    #   1 on failure
    #
    # Environment:
    #   GNUPGHOME must be set and contain the keys to transfer
    #
    # Note:
    #   - This is a ONE-WAY operation - keys cannot be extracted from YubiKey
    #   - The local keyring will contain stubs after transfer
    #   - Ensure you have a backup before proceeding!
    #
    # Example:
    #   gpg-key-to-yubikey --fingerprint "$FP" --passphrase "$PASS"

    local fingerprint=""
    local passphrase=""
    local admin_pin="12345678"  # Factory default
    local force=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --fingerprint)
                fingerprint="$2"
                shift 2
                ;;
            --passphrase)
                passphrase="$2"
                shift 2
                ;;
            --admin-pin)
                admin_pin="$2"
                shift 2
                ;;
            --force)
                force=true
                shift
                ;;
            *)
                log "Error: Unknown option: $1"
                return 1
                ;;
        esac
    done

    # Validate required parameters
    if [[ -z "$fingerprint" ]]; then
        log "Error: --fingerprint is required"
        return 1
    fi

    if [[ -z "$passphrase" ]]; then
        log "Error: --passphrase is required"
        return 1
    fi

    # Validate GNUPGHOME
    if [[ -z "${GNUPGHOME:-}" ]]; then
        log "Error: GNUPGHOME not set"
        return 1
    fi

    if [[ ! -d "$GNUPGHOME" ]]; then
        log "Error: GNUPGHOME directory does not exist: $GNUPGHOME"
        return 1
    fi

    # Verify key exists in GNUPGHOME
    if ! gpg --homedir "$GNUPGHOME" --list-secret-keys "$fingerprint" &>/dev/null; then
        log "Error: Key not found in GNUPGHOME: $fingerprint"
        return 1
    fi

    # Check YubiKey status
    if ! gpg-yubikey-detect --quiet &>/dev/null; then
        log "Error: No YubiKey detected"
        return 1
    fi

    # Check if YubiKey already has keys
    local card_status
    card_status=$(gpg-card-has-keys 2>/dev/null) || true

    if [[ "$card_status" == "full" && "$force" != "true" ]]; then
        log "Error: YubiKey already has GPG keys installed"
        echo "Use --force to overwrite, or reset the card first:"
        echo "  keycutter gpg card reset"
        return 1
    fi

    if [[ "$card_status" == "partial" && "$force" != "true" ]]; then
        log "Error: YubiKey has some keys installed"
        echo "Use --force to overwrite, or reset the card first:"
        echo "  keycutter gpg card reset"
        return 1
    fi

    # Count subkeys to verify we have all three
    local subkey_count
    subkey_count=$(gpg --homedir "$GNUPGHOME" --list-secret-keys --with-colons "$fingerprint" 2>/dev/null | grep -c "^ssb:")

    if [[ $subkey_count -lt 3 ]]; then
        log "Error: Expected 3 subkeys, found $subkey_count"
        echo "Create subkeys first with: keycutter gpg key create --subkeys --fingerprint $fingerprint"
        return 1
    fi

    log "Transferring subkeys to YubiKey..."
    log "Fingerprint: ${fingerprint:0:16}..."

    # Get subkey capabilities to determine transfer order
    # We need to identify which subkey is Sign [S], Encrypt [E], Auth [A]
    local subkey_info
    subkey_info=$(gpg --homedir "$GNUPGHOME" --list-secret-keys --with-colons "$fingerprint" 2>/dev/null | grep "^ssb:")

    # Parse subkeys and their capabilities
    # Format: ssb:u:256:22:KEYID:created:expires::::s::
    # The 12th field contains capabilities: s=sign, e=encrypt, a=auth
    local sign_keynum=0 encrypt_keynum=0 auth_keynum=0
    local keynum=1

    while IFS=: read -r type trust keylen algo keyid created expires _ _ _ _ caps _; do
        if [[ "$type" == "ssb" ]]; then
            case "$caps" in
                *s*) sign_keynum=$keynum ;;
                *e*) encrypt_keynum=$keynum ;;
                *a*) auth_keynum=$keynum ;;
            esac
            keynum=$((keynum + 1))
        fi
    done <<< "$subkey_info"

    # Verify we found all three
    if [[ $sign_keynum -eq 0 || $encrypt_keynum -eq 0 || $auth_keynum -eq 0 ]]; then
        log "Error: Could not identify all subkey types"
        log "Sign: $sign_keynum, Encrypt: $encrypt_keynum, Auth: $auth_keynum"
        return 1
    fi

    log "Found subkeys - Sign: key $sign_keynum, Encrypt: key $encrypt_keynum, Auth: key $auth_keynum"

    # Transfer each subkey to corresponding YubiKey slot
    # Slot 1 = Signature, Slot 2 = Encryption, Slot 3 = Authentication
    local transfers=("$sign_keynum:1:Signature" "$encrypt_keynum:2:Encryption" "$auth_keynum:3:Authentication")
    local transferred=0

    for transfer in "${transfers[@]}"; do
        local keynum="${transfer%%:*}"
        local rest="${transfer#*:}"
        local slot="${rest%%:*}"
        local name="${rest#*:}"

        log "Transferring $name subkey (key $keynum) to slot $slot..."

        # Build the command sequence for gpg --edit-key
        # Commands: key N -> keytocard -> slot -> passphrase -> admin_pin -> save
        local gpg_commands="key ${keynum}
keytocard
${slot}
${passphrase}
${admin_pin}
save
"

        # Execute transfer
        if echo -e "$gpg_commands" | \
           gpg --homedir "$GNUPGHOME" \
               --command-fd=0 \
               --pinentry-mode loopback \
               --expert \
               --edit-key "$fingerprint" 2>&1 | grep -q "Error\|failed\|No such"; then
            log "Error: Failed to transfer $name subkey"
            return 1
        fi

        log "Success: $name subkey transferred to slot $slot"
        transferred=$((transferred + 1))
    done

    if [[ $transferred -ne 3 ]]; then
        log "Error: Only $transferred of 3 subkeys transferred"
        return 1
    fi

    # Verify transfer by checking card status
    log "Verifying transfer..."
    gpg-scdaemon-restart &>/dev/null
    sleep 1

    local verify_status
    verify_status=$(gpg-card-has-keys 2>/dev/null) || true

    if [[ "$verify_status" != "full" ]]; then
        log "Warning: Card verification shows status: $verify_status"
        log "Some keys may not have transferred correctly"
    fi

    log "Success: All subkeys transferred to YubiKey"
    echo
    echo "Your subkeys are now on the YubiKey. The local keyring contains stubs."
    echo "To verify: gpg --card-status"

    return 0
}

gpg-card-reset() {
    # Reset GPG keys on YubiKey (preserves other YubiKey settings)
    #
    # This function resets only the OpenPGP application on the YubiKey,
    # removing all GPG keys but preserving other settings and applications.
    #
    # Arguments:
    #   --force   Skip confirmation prompt
    #
    # Returns:
    #   0 on success
    #   1 on failure or user cancellation
    #
    # WARNING: This will delete all GPG keys on the YubiKey!

    local force=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --force)
                force=true
                shift
                ;;
            *)
                log "Error: Unknown option: $1"
                return 1
                ;;
        esac
    done

    # Detect YubiKey first
    if ! gpg-yubikey-detect --quiet &>/dev/null; then
        log "Error: No YubiKey detected"
        return 1
    fi

    # Confirmation prompt
    if [[ "$force" != "true" ]]; then
        echo
        echo "WARNING: This will delete ALL GPG keys on the YubiKey!"
        echo "This action cannot be undone."
        echo
        read -rp "Type 'RESET' to confirm: " confirm
        if [[ "$confirm" != "RESET" ]]; then
            log "Reset cancelled"
            return 1
        fi
    fi

    log "Resetting OpenPGP application on YubiKey..."

    # Prefer ykman if available (more reliable)
    if command -v ykman &>/dev/null; then
        if ykman openpgp reset --force 2>&1; then
            log "Success: OpenPGP application reset"
            echo "Default PINs have been restored:"
            echo "  User PIN:  123456"
            echo "  Admin PIN: 12345678"
            return 0
        else
            log "Error: Failed to reset OpenPGP application"
            return 1
        fi
    fi

    # Fall back to gpg-connect-agent method
    log "Using gpg-connect-agent to reset (ykman not available)..."

    # This sequence intentionally triggers PIN lockout to force reset
    # Ref: https://github.com/drduh/YubiKey-Guide
    if gpg-connect-agent -r <<'EOF' 2>&1
/hex
scd serialno
scd apdu 00 20 00 81 08 40 40 40 40 40 40 40 40
scd apdu 00 20 00 81 08 40 40 40 40 40 40 40 40
scd apdu 00 20 00 81 08 40 40 40 40 40 40 40 40
scd apdu 00 20 00 81 08 40 40 40 40 40 40 40 40
scd apdu 00 20 00 83 08 40 40 40 40 40 40 40 40
scd apdu 00 20 00 83 08 40 40 40 40 40 40 40 40
scd apdu 00 20 00 83 08 40 40 40 40 40 40 40 40
scd apdu 00 20 00 83 08 40 40 40 40 40 40 40 40
scd apdu 00 e6 00 00
scd apdu 00 44 00 00
/echo Card has been reset
/bye
EOF
    then
        log "Success: OpenPGP application reset"
        echo "Default PINs have been restored:"
        echo "  User PIN:  123456"
        echo "  Admin PIN: 12345678"

        # Restart scdaemon to pick up changes
        gpg-scdaemon-restart

        return 0
    else
        log "Error: Failed to reset OpenPGP application"
        return 1
    fi
}

# =============================================================================
# Backup Listing and Restoration (gpg-012)
# =============================================================================

gpg-backup-list() {
    # List available GPG key backups from registered locations
    #
    # This function searches for encrypted backup files in the configured
    # backup directory and extracts key information from them.
    #
    # Arguments:
    #   --quiet    Only output backup paths (for scripting)
    #
    # Returns:
    #   0 if backups found
    #   1 if no backup location configured or no backups found
    #
    # Output:
    #   Prints list of backups with fingerprints and user IDs

    local quiet=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --quiet)
                quiet=true
                shift
                ;;
            *)
                log "Error: Unknown option: $1"
                return 1
                ;;
        esac
    done

    # Load config to get backup locations
    gpg-config-load

    local backup_dir
    backup_dir=$(gpg-config-get GPG_BACKUP_DIR "")

    if [[ -z "$backup_dir" ]]; then
        if [[ "$quiet" != "true" ]]; then
            echo "  No backup location configured."
            echo "  Set GPG_BACKUP_DIR in config or use 'keycutter gpg backup' to create backups."
        fi
        return 1
    fi

    # Expand path
    backup_dir="${backup_dir/#\~/$HOME}"

    if [[ ! -d "$backup_dir" ]]; then
        if [[ "$quiet" != "true" ]]; then
            echo "  Backup directory not found: $backup_dir"
        fi
        return 1
    fi

    # Search for encrypted backup files
    local found_backups=0
    local backup_file backup_name fingerprint uid
    local -a backup_list=()

    # Look for encrypted backup pattern: gpg-backup-*.tar.gz.gpg
    for backup_file in "$backup_dir"/gpg-backup-*.tar.gz.gpg; do
        if [[ -f "$backup_file" ]]; then
            found_backups=$((found_backups + 1))
            backup_list+=("$backup_file")

            if [[ "$quiet" != "true" ]]; then
                # Extract info from filename
                # Format: gpg-backup-YYYY-MM-DD-FINGERPRINT.tar.gz.gpg
                backup_name=$(basename "$backup_file")
                # Remove extensions to get base name
                backup_name="${backup_name%.tar.gz.gpg}"

                # Extract fingerprint (last 8 chars before extension)
                fingerprint="${backup_name##*-}"

                # Extract date
                local backup_date
                backup_date=$(echo "$backup_name" | grep -oE '[0-9]{4}-[0-9]{2}-[0-9]{2}' || echo "unknown")

                echo "  [$found_backups] $backup_file"
                echo "      Fingerprint: ...${fingerprint}"
                echo "      Created: $backup_date"
                echo
            else
                echo "$backup_file"
            fi
        fi
    done

    if [[ $found_backups -eq 0 ]]; then
        if [[ "$quiet" != "true" ]]; then
            echo "  No backup files found in: $backup_dir"
            echo "  Create a backup with: keycutter gpg backup"
        fi
        return 1
    fi

    if [[ "$quiet" != "true" ]]; then
        echo "  Found $found_backups backup(s) in: $backup_dir"
    fi
    return 0
}

gpg-backup-restore() {
    # Restore GPG keys from an encrypted backup to ephemeral GNUPGHOME
    #
    # This function decrypts a backup archive and imports the master key
    # and subkeys into the current (ephemeral) GNUPGHOME.
    #
    # Arguments:
    #   --backup-file FILE    Path to encrypted backup (required)
    #   --backup-pass PASS    Passphrase for backup decryption (will prompt if not provided)
    #
    # Returns:
    #   0 on success
    #   1 on failure
    #
    # Output:
    #   Prints the fingerprint of the restored key on success
    #
    # Environment:
    #   GNUPGHOME must be set (typically to ephemeral directory)
    #
    # Example:
    #   gpg-home-temp-create
    #   gpg-backup-restore --backup-file ~/gpg-backups/gpg-backup-2025-01-01-ABCD1234.tar.gz.gpg

    local backup_file=""
    local backup_pass=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --backup-file)
                backup_file="$2"
                shift 2
                ;;
            --backup-pass)
                backup_pass="$2"
                shift 2
                ;;
            *)
                log "Error: Unknown option: $1"
                return 1
                ;;
        esac
    done

    # Validate required parameters
    if [[ -z "$backup_file" ]]; then
        log "Error: --backup-file is required"
        return 1
    fi

    if [[ ! -f "$backup_file" ]]; then
        log "Error: Backup file not found: $backup_file"
        return 1
    fi

    # Validate GNUPGHOME
    if [[ -z "${GNUPGHOME:-}" ]]; then
        log "Error: GNUPGHOME not set. Use gpg-home-temp-create first."
        return 1
    fi

    if [[ ! -d "$GNUPGHOME" ]]; then
        log "Error: GNUPGHOME directory does not exist: $GNUPGHOME"
        return 1
    fi

    # Create temporary directory for extraction
    local temp_extract
    temp_extract=$(mktemp -d) || {
        log "Error: Failed to create temporary directory"
        return 1
    }
    chmod 700 "$temp_extract"

    # Cleanup on exit
    trap "rm -rf '$temp_extract'" RETURN

    log "Decrypting backup: $(basename "$backup_file")..."

    # Decrypt the backup
    local decrypt_cmd=(gpg --decrypt --quiet)
    if [[ -n "$backup_pass" ]]; then
        decrypt_cmd+=(--batch --pinentry-mode loopback --passphrase "$backup_pass")
    fi

    if ! "${decrypt_cmd[@]}" "$backup_file" 2>/dev/null | tar -xzf - -C "$temp_extract" 2>/dev/null; then
        log "Error: Failed to decrypt backup"
        log "Check that the backup passphrase is correct"
        return 1
    fi

    # Find the extracted backup directory
    local extracted_dir
    extracted_dir=$(find "$temp_extract" -maxdepth 1 -type d -name "gpg-backup-*" | head -1)

    if [[ -z "$extracted_dir" ]] || [[ ! -d "$extracted_dir" ]]; then
        log "Error: Could not find backup contents after extraction"
        return 1
    fi

    # Look for the master key file
    local master_key_file=""
    if [[ -f "$extracted_dir/master-key.asc" ]]; then
        master_key_file="$extracted_dir/master-key.asc"
    elif [[ -f "$extracted_dir/secret-key.asc" ]]; then
        master_key_file="$extracted_dir/secret-key.asc"
    fi

    if [[ -z "$master_key_file" ]]; then
        log "Error: No master key file found in backup"
        log "Expected: master-key.asc or secret-key.asc"
        return 1
    fi

    # Copy GPG configuration to ephemeral home if not present
    local gpg_conf="${KEYCUTTER_ROOT}/config/gpg/gpg.conf"
    if [[ -f "$gpg_conf" ]] && [[ ! -f "$GNUPGHOME/gpg.conf" ]]; then
        cp "$gpg_conf" "$GNUPGHOME/gpg.conf"
    fi

    # Configure gpg-agent for pinentry-loopback
    if [[ ! -f "$GNUPGHOME/gpg-agent.conf" ]]; then
        cat > "$GNUPGHOME/gpg-agent.conf" <<EOF
allow-loopback-pinentry
EOF
    fi

    # Restart agent with new config
    gpg-agent-restart "$GNUPGHOME" >/dev/null 2>&1

    log "Importing master key..."

    # Import the master key
    if ! gpg --homedir "$GNUPGHOME" --import "$master_key_file" 2>&1; then
        log "Error: Failed to import master key"
        return 1
    fi

    # Import ownertrust if available
    if [[ -f "$extracted_dir/ownertrust.txt" ]]; then
        log "Importing trust database..."
        gpg --homedir "$GNUPGHOME" --import-ownertrust "$extracted_dir/ownertrust.txt" 2>/dev/null || true
    fi

    # Get the imported key fingerprint
    local fingerprint
    fingerprint=$(gpg --homedir "$GNUPGHOME" --list-secret-keys --with-colons 2>/dev/null | \
        awk -F: '/^sec:/ { getline; if ($1 == "fpr") print $10; exit }')

    if [[ -z "$fingerprint" ]]; then
        # Try alternative method
        fingerprint=$(gpg --homedir "$GNUPGHOME" --list-secret-keys --with-colons 2>/dev/null | \
            awk -F: '/^fpr:/ { print $10; exit }')
    fi

    if [[ -z "$fingerprint" ]]; then
        log "Warning: Could not determine key fingerprint"
        log "Keys imported but fingerprint extraction failed"
        return 0
    fi

    # Count subkeys
    local subkey_count
    subkey_count=$(gpg --homedir "$GNUPGHOME" --list-secret-keys --with-colons "$fingerprint" 2>/dev/null | grep -c "^ssb:")

    log "Success: Key restored"
    log "Fingerprint: $fingerprint"
    log "Subkeys: $subkey_count"

    echo "$fingerprint"
    return 0
}
