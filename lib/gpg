#!/usr/bin/env bash
# keycutter/lib/gpg - Functions for GPG key management with YubiKey support
#
# Configuration:
# - gpg-config-load(): Load GPG configuration with precedence handling
# - gpg-config-get(): Get a specific configuration value
# - gpg-config-dump(): Dump all loaded configuration (for debugging)
#
# Version and Environment:
# - gpg-version-check(): Verify GPG version meets requirements
# - gpg-home-temp-create(): Create ephemeral GNUPGHOME for secure key operations
# - gpg-home-temp-cleanup(): Clean up ephemeral GNUPGHOME
# - gpg-agent-restart(): Restart gpg-agent with proper configuration
# - gpg-agent-ensure(): Ensure gpg-agent is running
#
# Key Creation:
# - gpg-master-key-create(): Create master (Certify) key in ephemeral GNUPGHOME
# - gpg-subkeys-create(): Create Sign, Encrypt, Auth subkeys for master key
# - gpg-identity-prompt(): Interactive prompt for user identity
# - gpg-passphrase-prompt(): Interactive prompt for passphrase with confirmation
#
# Key Listing:
# - gpg-card-status-display(): Parse and display GPG card status
# - gpg-master-keys-list(): List master keys from backup locations

KEYCUTTER_ROOT="$(readlink -f "$(dirname -- "${BASH_SOURCE[0]:-${0:A}}")/../")"
source "${KEYCUTTER_ROOT}/lib/utils"

# Minimum GPG version required for modern key types and features
GPG_MIN_VERSION="2.2.0"

# Track ephemeral home for cleanup
_GPG_EPHEMERAL_HOME=""

# Configuration storage (associative array)
declare -gA _GPG_CONFIG

gpg-config-load() {
    # Load GPG configuration from defaults and environment
    #
    # Configuration precedence (highest to lowest):
    #   1. CLI arguments (passed as name=value pairs)
    #   2. Environment variables (GPG_* prefix)
    #   3. User config file (~/.config/keycutter/gpg.conf)
    #   4. Default values (config/gpg/defaults)
    #
    # Arguments:
    #   $@ - Optional CLI overrides as name=value pairs
    #
    # Returns:
    #   0 on success
    #   1 if defaults file is missing
    #
    # Example:
    #   gpg-config-load GPG_KEY_TYPE=rsa4096 GPG_EXPIRATION=1y

    local defaults_file="${KEYCUTTER_ROOT}/config/gpg/defaults"
    local user_config="${XDG_CONFIG_HOME:-$HOME/.config}/keycutter/gpg.conf"

    # Reset config
    _GPG_CONFIG=()

    # 1. Load defaults (lowest precedence)
    if [[ -f "$defaults_file" ]]; then
        local line key value
        while IFS= read -r line || [[ -n "$line" ]]; do
            # Skip comments and empty lines
            [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue

            # Parse key=value (handling quoted values)
            if [[ "$line" =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
                key="${BASH_REMATCH[1]}"
                value="${BASH_REMATCH[2]}"
                # Remove surrounding quotes if present
                value="${value#\"}"
                value="${value%\"}"
                _GPG_CONFIG["$key"]="$value"
            fi
        done < "$defaults_file"
    else
        log "Warning: GPG defaults file not found: $defaults_file"
    fi

    # 2. Load user config file (if exists)
    if [[ -f "$user_config" ]]; then
        local line key value
        while IFS= read -r line || [[ -n "$line" ]]; do
            [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
            if [[ "$line" =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
                key="${BASH_REMATCH[1]}"
                value="${BASH_REMATCH[2]}"
                value="${value#\"}"
                value="${value%\"}"
                _GPG_CONFIG["$key"]="$value"
            fi
        done < "$user_config"
    fi

    # 3. Apply environment variable overrides
    local var
    for var in GPG_KEY_TYPE GPG_EXPIRATION GPG_MASTER_EXPIRATION GPG_IDENTITY \
               GPG_COMMENT GPG_CIPHER_PREFS GPG_DIGEST_PREFS GPG_COMPRESS_PREFS \
               GPG_DEFAULT_PREFS GPG_CERT_DIGEST GPG_BACKUP_DIR GPG_BACKUP_FORMAT \
               GPG_KEYSERVER YUBIKEY_TOUCH_POLICY YUBIKEY_PIN_RETRIES \
               YUBIKEY_ADMIN_PIN_RETRIES; do
        if [[ -n "${!var:-}" ]]; then
            _GPG_CONFIG["$var"]="${!var}"
        fi
    done

    # 4. Apply CLI argument overrides (highest precedence)
    local arg key value
    for arg in "$@"; do
        if [[ "$arg" =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
            key="${BASH_REMATCH[1]}"
            value="${BASH_REMATCH[2]}"
            _GPG_CONFIG["$key"]="$value"
        fi
    done

    return 0
}

gpg-config-get() {
    # Get a configuration value
    #
    # Arguments:
    #   $1 - Configuration key (e.g., GPG_KEY_TYPE)
    #   $2 - Default value if not set (optional)
    #
    # Returns:
    #   0 if key exists
    #   1 if key doesn't exist and no default provided
    #
    # Output:
    #   Prints the configuration value

    local key="$1"
    local default="${2:-}"

    if [[ -v "_GPG_CONFIG[$key]" ]]; then
        echo "${_GPG_CONFIG[$key]}"
        return 0
    elif [[ -n "$default" ]]; then
        echo "$default"
        return 0
    else
        return 1
    fi
}

gpg-config-dump() {
    # Dump all loaded configuration (for debugging)
    #
    # Returns:
    #   0 always
    #
    # Output:
    #   Prints all configuration key=value pairs

    local key
    for key in "${!_GPG_CONFIG[@]}"; do
        echo "${key}=${_GPG_CONFIG[$key]}"
    done | sort
}

gpg-version-check() {
    # Check if GPG is installed and meets minimum version requirement
    #
    # Arguments:
    #   $1 - Required version (optional, defaults to GPG_MIN_VERSION)
    #
    # Returns:
    #   0 if version requirement met
    #   1 if GPG not found or version too old
    #
    # Output:
    #   Prints GPG version on success, error message on failure

    local required_version="${1:-$GPG_MIN_VERSION}"

    if ! command -v gpg &>/dev/null; then
        log "Error: GPG is not installed"
        echo "Please install GnuPG 2.x:"
        echo "  macOS:  brew install gnupg"
        echo "  Ubuntu: sudo apt install gnupg2"
        echo "  Fedora: sudo dnf install gnupg2"
        return 1
    fi

    local gpg_version
    gpg_version=$(gpg --version | head -n1 | awk '{print $3}')

    if [[ $(check_version "$gpg_version" "$required_version") == "false" ]]; then
        log "Error: GPG version $gpg_version is too old (require >= $required_version)"
        return 1
    fi

    echo "$gpg_version"
    return 0
}

gpg-home-temp-create() {
    # Create a secure ephemeral GNUPGHOME directory
    #
    # This is critical for key generation security - the master key
    # should never touch persistent disk storage unencrypted.
    #
    # Arguments:
    #   $1 - Base directory (optional, defaults to system temp)
    #
    # Returns:
    #   0 on success, 1 on failure
    #
    # Output:
    #   Prints path to ephemeral GNUPGHOME
    #
    # Side effects:
    #   Sets GNUPGHOME environment variable
    #   Creates cleanup trap on EXIT

    local base_dir="${1:-}"
    local temp_home

    # Use ramfs/tmpfs if available for extra security
    if [[ -z "$base_dir" ]]; then
        if [[ -d /dev/shm ]]; then
            base_dir="/dev/shm"
        elif [[ "$OSTYPE" == "darwin"* ]]; then
            # macOS doesn't have /dev/shm, use secure temp
            base_dir="${TMPDIR:-/tmp}"
        else
            base_dir="/tmp"
        fi
    fi

    # Create unique temporary directory with restrictive permissions
    temp_home=$(mktemp -d "${base_dir}/gnupg.XXXXXXXXXX") || {
        log "Error: Failed to create temporary GNUPGHOME"
        return 1
    }

    chmod 700 "$temp_home" || {
        log "Error: Failed to set permissions on GNUPGHOME"
        rm -rf "$temp_home"
        return 1
    }

    # Store for cleanup
    _GPG_EPHEMERAL_HOME="$temp_home"

    # Export GNUPGHOME
    export GNUPGHOME="$temp_home"

    # Set up cleanup trap (additive, won't replace existing traps)
    trap 'gpg-home-temp-cleanup' EXIT

    log "Create ephemeral GNUPGHOME: $temp_home"
    echo "$temp_home"
    return 0
}

gpg-home-temp-cleanup() {
    # Securely clean up ephemeral GNUPGHOME
    #
    # This function securely removes the ephemeral GPG home directory.
    # On Linux with secure-delete available, uses srm for secure removal.
    #
    # Returns:
    #   0 on success or if nothing to clean
    #   1 on failure

    if [[ -z "$_GPG_EPHEMERAL_HOME" ]] || [[ ! -d "$_GPG_EPHEMERAL_HOME" ]]; then
        return 0
    fi

    # Kill any gpg-agent using this home
    if [[ -n "${GNUPGHOME:-}" ]] && [[ "$GNUPGHOME" == "$_GPG_EPHEMERAL_HOME" ]]; then
        gpgconf --homedir "$_GPG_EPHEMERAL_HOME" --kill gpg-agent 2>/dev/null || true
    fi

    # Secure removal if available, otherwise regular rm
    if command -v srm &>/dev/null; then
        log "Securely removing ephemeral GNUPGHOME"
        srm -rf "$_GPG_EPHEMERAL_HOME" 2>/dev/null || rm -rf "$_GPG_EPHEMERAL_HOME"
    else
        log "Removing ephemeral GNUPGHOME"
        rm -rf "$_GPG_EPHEMERAL_HOME"
    fi

    _GPG_EPHEMERAL_HOME=""
    unset GNUPGHOME

    return 0
}

gpg-agent-restart() {
    # Restart gpg-agent with proper configuration
    #
    # Arguments:
    #   $1 - GNUPGHOME to use (optional, uses current GNUPGHOME or default)
    #
    # Returns:
    #   0 on success
    #   1 on failure

    local gpg_home="${1:-${GNUPGHOME:-$HOME/.gnupg}}"

    log "Restarting gpg-agent"

    # Kill existing agent
    gpgconf --homedir "$gpg_home" --kill gpg-agent 2>/dev/null || true

    # Brief pause for socket cleanup
    sleep 0.5

    # Restart agent
    if ! gpg-connect-agent --homedir "$gpg_home" /bye &>/dev/null; then
        # Try alternative method
        gpg --homedir "$gpg_home" --list-keys &>/dev/null || {
            log "Error: Failed to restart gpg-agent"
            return 1
        }
    fi

    log "Success: gpg-agent restarted"
    return 0
}

gpg-agent-ensure() {
    # Ensure gpg-agent is running with proper configuration
    #
    # Arguments:
    #   $1 - GNUPGHOME to use (optional, uses current GNUPGHOME or default)
    #
    # Returns:
    #   0 on success
    #   1 on failure

    local gpg_home="${1:-${GNUPGHOME:-$HOME/.gnupg}}"

    # Check if agent is responding
    if gpg-connect-agent --homedir "$gpg_home" /bye &>/dev/null; then
        return 0
    fi

    # Agent not running, start it
    gpg-agent-restart "$gpg_home"
}

# =============================================================================
# Key Creation Functions
# =============================================================================

gpg-master-key-create() {
    # Create a GPG master (Certify) key in ephemeral GNUPGHOME
    #
    # This function creates a master key that will be used to certify subkeys.
    # The key is created in an ephemeral GNUPGHOME for security - it should
    # never touch persistent disk storage unencrypted.
    #
    # Arguments:
    #   --identity    User ID for the key (e.g., "Name <email@example.com>")
    #   --key-type    Algorithm: ed25519 (default) or rsa4096
    #   --expiration  Expiration period: 0 (never), 1y, 2y, etc. (default: 0)
    #   --passphrase  Passphrase for the key (will prompt if not provided)
    #
    # Returns:
    #   0 on success
    #   1 on failure
    #
    # Output:
    #   Prints the key fingerprint on success
    #
    # Environment:
    #   GNUPGHOME must be set to ephemeral directory (use gpg-home-temp-create)
    #
    # Example:
    #   gpg-home-temp-create
    #   gpg-master-key-create --identity "Test User <test@example.com>"

    local identity=""
    local key_type=""
    local expiration=""
    local passphrase=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --identity)
                identity="$2"
                shift 2
                ;;
            --key-type)
                key_type="$2"
                shift 2
                ;;
            --expiration)
                expiration="$2"
                shift 2
                ;;
            --passphrase)
                passphrase="$2"
                shift 2
                ;;
            *)
                log "Error: Unknown option: $1"
                return 1
                ;;
        esac
    done

    # Load config for defaults
    gpg-config-load

    # Use provided values or fall back to config
    key_type="${key_type:-$(gpg-config-get GPG_KEY_TYPE ed25519)}"
    expiration="${expiration:-$(gpg-config-get GPG_MASTER_EXPIRATION 0)}"

    # Validate required parameters
    if [[ -z "$identity" ]]; then
        log "Error: --identity is required"
        log "Example: --identity 'Your Name <your@email.com>'"
        return 1
    fi

    # Validate GNUPGHOME is set and is ephemeral
    if [[ -z "${GNUPGHOME:-}" ]]; then
        log "Error: GNUPGHOME not set. Use gpg-home-temp-create first."
        return 1
    fi

    if [[ ! -d "$GNUPGHOME" ]]; then
        log "Error: GNUPGHOME directory does not exist: $GNUPGHOME"
        return 1
    fi

    # Validate key type
    case "$key_type" in
        ed25519|rsa4096|rsa3072)
            ;;
        *)
            log "Error: Invalid key type: $key_type"
            log "Supported types: ed25519, rsa4096, rsa3072"
            return 1
            ;;
    esac

    # Copy GPG configuration to ephemeral home
    local gpg_conf="${KEYCUTTER_ROOT}/config/gpg/gpg.conf"
    if [[ -f "$gpg_conf" ]]; then
        cp "$gpg_conf" "$GNUPGHOME/gpg.conf"
    fi

    # Configure gpg-agent for pinentry-loopback
    cat > "$GNUPGHOME/gpg-agent.conf" <<EOF
allow-loopback-pinentry
EOF

    # Restart agent with new config
    gpg-agent-restart "$GNUPGHOME" >/dev/null 2>&1

    log "Creating master key for: $identity"
    log "Key type: $key_type, Expiration: ${expiration:-never}"

    # Build the gpg command
    local gpg_cmd=(
        gpg
        --homedir "$GNUPGHOME"
        --batch
        --expert
    )

    # Add passphrase handling
    if [[ -n "$passphrase" ]]; then
        gpg_cmd+=(--pinentry-mode loopback --passphrase "$passphrase")
    fi

    # Generate the master key (Certify only)
    if ! "${gpg_cmd[@]}" --quick-generate-key "$identity" "$key_type" cert "$expiration" 2>&1; then
        log "Error: Failed to create master key"
        return 1
    fi

    # Get the key fingerprint
    local fingerprint
    fingerprint=$(gpg --homedir "$GNUPGHOME" --list-keys --with-colons "$identity" 2>/dev/null | awk -F: '/^fpr:/ { print $10; exit }')

    if [[ -z "$fingerprint" ]]; then
        log "Error: Failed to retrieve key fingerprint"
        return 1
    fi

    log "Success: Master key created"
    echo "$fingerprint"
    return 0
}

gpg-subkeys-create() {
    # Create subkeys (Sign, Encrypt, Auth) for an existing master key
    #
    # This function generates the three operational subkeys that will be
    # transferred to YubiKey. The master key (Certify only) remains secure
    # in the ephemeral GNUPGHOME or backup storage.
    #
    # Arguments:
    #   --fingerprint  Master key fingerprint (required)
    #   --key-type     Algorithm: ed25519 (default) or rsa4096
    #   --expiration   Expiration period: 2y (default), 1y, etc.
    #   --passphrase   Passphrase for the master key (required)
    #
    # Returns:
    #   0 on success (all 3 subkeys created)
    #   1 on failure
    #
    # Output:
    #   Prints subkey fingerprints on success
    #
    # Environment:
    #   GNUPGHOME must be set and contain the master key
    #
    # Example:
    #   gpg-subkeys-create --fingerprint "$FP" --passphrase "$PASS"

    local fingerprint=""
    local key_type=""
    local expiration=""
    local passphrase=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --fingerprint)
                fingerprint="$2"
                shift 2
                ;;
            --key-type)
                key_type="$2"
                shift 2
                ;;
            --expiration)
                expiration="$2"
                shift 2
                ;;
            --passphrase)
                passphrase="$2"
                shift 2
                ;;
            *)
                log "Error: Unknown option: $1"
                return 1
                ;;
        esac
    done

    # Load config for defaults
    gpg-config-load

    # Use provided values or fall back to config
    key_type="${key_type:-$(gpg-config-get GPG_KEY_TYPE ed25519)}"
    expiration="${expiration:-$(gpg-config-get GPG_EXPIRATION 2y)}"

    # Validate required parameters
    if [[ -z "$fingerprint" ]]; then
        log "Error: --fingerprint is required"
        return 1
    fi

    if [[ -z "$passphrase" ]]; then
        log "Error: --passphrase is required for batch subkey creation"
        return 1
    fi

    # Validate GNUPGHOME is set
    if [[ -z "${GNUPGHOME:-}" ]]; then
        log "Error: GNUPGHOME not set"
        return 1
    fi

    if [[ ! -d "$GNUPGHOME" ]]; then
        log "Error: GNUPGHOME directory does not exist: $GNUPGHOME"
        return 1
    fi

    # Validate key type
    case "$key_type" in
        ed25519|rsa4096|rsa3072)
            ;;
        *)
            log "Error: Invalid key type: $key_type"
            log "Supported types: ed25519, rsa4096, rsa3072"
            return 1
            ;;
    esac

    # Verify master key exists in GNUPGHOME
    if ! gpg --homedir "$GNUPGHOME" --list-keys "$fingerprint" &>/dev/null; then
        log "Error: Master key not found: $fingerprint"
        return 1
    fi

    log "Creating subkeys for master key: ${fingerprint:0:16}..."
    log "Key type: $key_type, Expiration: $expiration"

    # Subkey capabilities to create
    local subkeys=("sign" "encrypt" "auth")
    local created_count=0

    for subkey in "${subkeys[@]}"; do
        log "Creating $subkey subkey..."

        if gpg --homedir "$GNUPGHOME" \
               --batch \
               --pinentry-mode loopback \
               --passphrase "$passphrase" \
               --quick-add-key "$fingerprint" "$key_type" "$subkey" "$expiration" 2>&1; then
            log "Success: $subkey subkey created"
            created_count=$((created_count + 1))
        else
            log "Error: Failed to create $subkey subkey"
            return 1
        fi
    done

    # Verify all subkeys were created
    if [[ $created_count -ne 3 ]]; then
        log "Error: Expected 3 subkeys, created $created_count"
        return 1
    fi

    # List the subkeys we created
    local subkey_info
    subkey_info=$(gpg --homedir "$GNUPGHOME" --list-keys --with-colons "$fingerprint" 2>/dev/null | \
        awk -F: '/^sub:/ { print $5 }')

    log "Success: All subkeys created"
    echo "$subkey_info"
    return 0
}

gpg-identity-prompt() {
    # Interactively prompt for GPG identity components
    #
    # Arguments:
    #   $1 - Variable name to store result
    #
    # Returns:
    #   0 on success
    #   1 on user cancellation or invalid input
    #
    # Output:
    #   Sets the named variable to "Real Name <email@example.com>" format

    local result_var="$1"
    local name email identity

    echo
    echo "Enter your identity for the GPG key:"
    echo

    read -rp "  Real Name: " name
    if [[ -z "$name" ]]; then
        log "Error: Name is required"
        return 1
    fi

    read -rp "  Email: " email
    if [[ -z "$email" ]]; then
        log "Error: Email is required"
        return 1
    fi

    # Validate email format (basic check)
    if [[ ! "$email" =~ ^[^@]+@[^@]+\.[^@]+$ ]]; then
        log "Error: Invalid email format"
        return 1
    fi

    identity="$name <$email>"

    echo
    echo "  Identity: $identity"
    echo

    read -rp "  Is this correct? [Y/n] " confirm
    if [[ "$confirm" =~ ^[Nn] ]]; then
        return 1
    fi

    # Set the result variable
    printf -v "$result_var" '%s' "$identity"
    return 0
}

gpg-passphrase-prompt() {
    # Interactively prompt for GPG passphrase with confirmation
    #
    # Arguments:
    #   $1 - Variable name to store result
    #
    # Returns:
    #   0 on success
    #   1 on user cancellation or mismatch

    local result_var="$1"
    local pass1 pass2

    echo
    echo "Enter a strong passphrase to protect your GPG master key."
    echo "This passphrase protects your master key backup."
    echo

    read -rsp "  Passphrase: " pass1
    echo

    if [[ -z "$pass1" ]]; then
        log "Error: Passphrase cannot be empty"
        return 1
    fi

    # Check minimum length
    if [[ ${#pass1} -lt 8 ]]; then
        log "Error: Passphrase must be at least 8 characters"
        return 1
    fi

    read -rsp "  Confirm passphrase: " pass2
    echo

    if [[ "$pass1" != "$pass2" ]]; then
        log "Error: Passphrases do not match"
        return 1
    fi

    # Set the result variable
    printf -v "$result_var" '%s' "$pass1"
    return 0
}

# =============================================================================
# Key Listing Functions
# =============================================================================

gpg-card-status-display() {
    # Parse and display GPG card status in a clean format
    #
    # Arguments:
    #   $1 - Card status output from 'gpg --card-status'
    #
    # Output:
    #   Formatted display of card information and keys

    local card_status="$1"
    local reader serial_number card_holder
    local sig_key enc_key auth_key
    local general_key_info

    # Extract card info
    reader=$(echo "$card_status" | grep "^Reader" | sed 's/Reader[^:]*: *//')
    serial_number=$(echo "$card_status" | grep "^Serial number" | awk '{print $NF}')
    card_holder=$(echo "$card_status" | grep "^Name of cardholder" | sed 's/Name of cardholder: *//')

    # Extract key information
    sig_key=$(echo "$card_status" | grep "^Signature key" | sed 's/Signature key[^:]*: *//')
    enc_key=$(echo "$card_status" | grep "^Encryption key" | sed 's/Encryption key[^:]*: *//')
    auth_key=$(echo "$card_status" | grep "^Authentication key" | sed 's/Authentication key[^:]*: *//')

    # Check for general key info (indicates keys are properly linked)
    general_key_info=$(echo "$card_status" | grep "^General key info")

    # Display card information
    if [[ -n "$reader" ]]; then
        echo "  Reader:        $reader"
    fi
    if [[ -n "$serial_number" ]]; then
        echo "  Serial:        $serial_number"
    fi
    if [[ -n "$card_holder" && "$card_holder" != " " ]]; then
        echo "  Cardholder:    $card_holder"
    fi

    echo

    # Display keys with their status
    if [[ -n "$sig_key" && "$sig_key" != "[none]" ]]; then
        echo "  [S] Signature:     ${sig_key:0:16}..."
    else
        echo "  [S] Signature:     (not set)"
    fi

    if [[ -n "$enc_key" && "$enc_key" != "[none]" ]]; then
        echo "  [E] Encryption:    ${enc_key:0:16}..."
    else
        echo "  [E] Encryption:    (not set)"
    fi

    if [[ -n "$auth_key" && "$auth_key" != "[none]" ]]; then
        echo "  [A] Authentication: ${auth_key:0:16}..."
    else
        echo "  [A] Authentication: (not set)"
    fi

    # Show key status hint
    if [[ -z "$general_key_info" ]] && [[ "$sig_key" != "[none]" || "$enc_key" != "[none]" || "$auth_key" != "[none]" ]]; then
        echo
        echo "  Note: Keys present but not linked to local keyring."
        echo "  Run 'gpg --card-status' to fetch public keys."
    fi
}

gpg-master-keys-list() {
    # List available master keys from registered backup locations
    #
    # Searches for GPG key backups in registered locations and displays
    # information about available master keys.
    #
    # Returns:
    #   0 if keys found
    #   1 if no backup locations configured or no keys found

    # Load config to get backup locations
    gpg-config-load

    local backup_dir
    backup_dir=$(gpg-config-get GPG_BACKUP_DIR "")

    if [[ -z "$backup_dir" ]]; then
        echo "  No backup location configured."
        echo "  Set GPG_BACKUP_DIR in config or use 'keycutter gpg backup' to create backups."
        return 1
    fi

    # Expand path
    backup_dir="${backup_dir/#\~/$HOME}"

    if [[ ! -d "$backup_dir" ]]; then
        echo "  Backup directory not found: $backup_dir"
        return 1
    fi

    # Search for key files
    local found_keys=0
    local key_file keyid uid

    # Look for common backup patterns: *.asc, *.gpg, private-key*.asc
    for key_file in "$backup_dir"/*.asc "$backup_dir"/*.gpg "$backup_dir"/*/secret-key*.asc "$backup_dir"/*/master*.asc; do
        if [[ -f "$key_file" ]]; then
            # Extract key info using gpg --show-keys
            keyid=$(gpg --show-keys --with-colons "$key_file" 2>/dev/null | awk -F: '/^sec:/ {print $5; exit}')
            uid=$(gpg --show-keys --with-colons "$key_file" 2>/dev/null | awk -F: '/^uid:/ {print $10; exit}')

            if [[ -n "$keyid" ]]; then
                found_keys=$((found_keys + 1))
                echo "  $keyid"
                if [[ -n "$uid" ]]; then
                    echo "    └─ $uid"
                fi
                echo "    └─ $(basename "$key_file")"
                echo
            fi
        fi
    done

    if [[ $found_keys -eq 0 ]]; then
        echo "  No master keys found in: $backup_dir"
        return 1
    fi

    echo "  Found $found_keys master key(s)"
    return 0
}
