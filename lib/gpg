#!/usr/bin/env bash
# keycutter/lib/gpg - Functions for GPG key management with YubiKey support
#
# Configuration:
# - gpg-config-load(): Load GPG configuration with precedence handling
# - gpg-config-get(): Get a specific configuration value
# - gpg-config-dump(): Dump all loaded configuration (for debugging)
#
# Version and Environment:
# - gpg-version-check(): Verify GPG version meets requirements
# - gpg-home-temp-create(): Create ephemeral GNUPGHOME for secure key operations
# - gpg-home-temp-cleanup(): Clean up ephemeral GNUPGHOME
# - gpg-agent-restart(): Restart gpg-agent with proper configuration
# - gpg-agent-ensure(): Ensure gpg-agent is running
#
# Key Listing:
# - gpg-card-status-display(): Parse and display GPG card status
# - gpg-master-keys-list(): List master keys from backup locations

KEYCUTTER_ROOT="$(readlink -f "$(dirname -- "${BASH_SOURCE[0]:-${0:A}}")/../")"
source "${KEYCUTTER_ROOT}/lib/utils"

# Minimum GPG version required for modern key types and features
GPG_MIN_VERSION="2.2.0"

# Track ephemeral home for cleanup
_GPG_EPHEMERAL_HOME=""

# Configuration storage (associative array)
declare -gA _GPG_CONFIG

gpg-config-load() {
    # Load GPG configuration from defaults and environment
    #
    # Configuration precedence (highest to lowest):
    #   1. CLI arguments (passed as name=value pairs)
    #   2. Environment variables (GPG_* prefix)
    #   3. User config file (~/.config/keycutter/gpg.conf)
    #   4. Default values (config/gpg/defaults)
    #
    # Arguments:
    #   $@ - Optional CLI overrides as name=value pairs
    #
    # Returns:
    #   0 on success
    #   1 if defaults file is missing
    #
    # Example:
    #   gpg-config-load GPG_KEY_TYPE=rsa4096 GPG_EXPIRATION=1y

    local defaults_file="${KEYCUTTER_ROOT}/config/gpg/defaults"
    local user_config="${XDG_CONFIG_HOME:-$HOME/.config}/keycutter/gpg.conf"

    # Reset config
    _GPG_CONFIG=()

    # 1. Load defaults (lowest precedence)
    if [[ -f "$defaults_file" ]]; then
        local line key value
        while IFS= read -r line || [[ -n "$line" ]]; do
            # Skip comments and empty lines
            [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue

            # Parse key=value (handling quoted values)
            if [[ "$line" =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
                key="${BASH_REMATCH[1]}"
                value="${BASH_REMATCH[2]}"
                # Remove surrounding quotes if present
                value="${value#\"}"
                value="${value%\"}"
                _GPG_CONFIG["$key"]="$value"
            fi
        done < "$defaults_file"
    else
        log "Warning: GPG defaults file not found: $defaults_file"
    fi

    # 2. Load user config file (if exists)
    if [[ -f "$user_config" ]]; then
        local line key value
        while IFS= read -r line || [[ -n "$line" ]]; do
            [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
            if [[ "$line" =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
                key="${BASH_REMATCH[1]}"
                value="${BASH_REMATCH[2]}"
                value="${value#\"}"
                value="${value%\"}"
                _GPG_CONFIG["$key"]="$value"
            fi
        done < "$user_config"
    fi

    # 3. Apply environment variable overrides
    local var
    for var in GPG_KEY_TYPE GPG_EXPIRATION GPG_MASTER_EXPIRATION GPG_IDENTITY \
               GPG_COMMENT GPG_CIPHER_PREFS GPG_DIGEST_PREFS GPG_COMPRESS_PREFS \
               GPG_DEFAULT_PREFS GPG_CERT_DIGEST GPG_BACKUP_DIR GPG_BACKUP_FORMAT \
               GPG_KEYSERVER YUBIKEY_TOUCH_POLICY YUBIKEY_PIN_RETRIES \
               YUBIKEY_ADMIN_PIN_RETRIES; do
        if [[ -n "${!var:-}" ]]; then
            _GPG_CONFIG["$var"]="${!var}"
        fi
    done

    # 4. Apply CLI argument overrides (highest precedence)
    local arg key value
    for arg in "$@"; do
        if [[ "$arg" =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
            key="${BASH_REMATCH[1]}"
            value="${BASH_REMATCH[2]}"
            _GPG_CONFIG["$key"]="$value"
        fi
    done

    return 0
}

gpg-config-get() {
    # Get a configuration value
    #
    # Arguments:
    #   $1 - Configuration key (e.g., GPG_KEY_TYPE)
    #   $2 - Default value if not set (optional)
    #
    # Returns:
    #   0 if key exists
    #   1 if key doesn't exist and no default provided
    #
    # Output:
    #   Prints the configuration value

    local key="$1"
    local default="${2:-}"

    if [[ -v "_GPG_CONFIG[$key]" ]]; then
        echo "${_GPG_CONFIG[$key]}"
        return 0
    elif [[ -n "$default" ]]; then
        echo "$default"
        return 0
    else
        return 1
    fi
}

gpg-config-dump() {
    # Dump all loaded configuration (for debugging)
    #
    # Returns:
    #   0 always
    #
    # Output:
    #   Prints all configuration key=value pairs

    local key
    for key in "${!_GPG_CONFIG[@]}"; do
        echo "${key}=${_GPG_CONFIG[$key]}"
    done | sort
}

gpg-version-check() {
    # Check if GPG is installed and meets minimum version requirement
    #
    # Arguments:
    #   $1 - Required version (optional, defaults to GPG_MIN_VERSION)
    #
    # Returns:
    #   0 if version requirement met
    #   1 if GPG not found or version too old
    #
    # Output:
    #   Prints GPG version on success, error message on failure

    local required_version="${1:-$GPG_MIN_VERSION}"

    if ! command -v gpg &>/dev/null; then
        log "Error: GPG is not installed"
        echo "Please install GnuPG 2.x:"
        echo "  macOS:  brew install gnupg"
        echo "  Ubuntu: sudo apt install gnupg2"
        echo "  Fedora: sudo dnf install gnupg2"
        return 1
    fi

    local gpg_version
    gpg_version=$(gpg --version | head -n1 | awk '{print $3}')

    if [[ $(check_version "$gpg_version" "$required_version") == "false" ]]; then
        log "Error: GPG version $gpg_version is too old (require >= $required_version)"
        return 1
    fi

    echo "$gpg_version"
    return 0
}

gpg-home-temp-create() {
    # Create a secure ephemeral GNUPGHOME directory
    #
    # This is critical for key generation security - the master key
    # should never touch persistent disk storage unencrypted.
    #
    # Arguments:
    #   $1 - Base directory (optional, defaults to system temp)
    #
    # Returns:
    #   0 on success, 1 on failure
    #
    # Output:
    #   Prints path to ephemeral GNUPGHOME
    #
    # Side effects:
    #   Sets GNUPGHOME environment variable
    #   Creates cleanup trap on EXIT

    local base_dir="${1:-}"
    local temp_home

    # Use ramfs/tmpfs if available for extra security
    if [[ -z "$base_dir" ]]; then
        if [[ -d /dev/shm ]]; then
            base_dir="/dev/shm"
        elif [[ "$OSTYPE" == "darwin"* ]]; then
            # macOS doesn't have /dev/shm, use secure temp
            base_dir="${TMPDIR:-/tmp}"
        else
            base_dir="/tmp"
        fi
    fi

    # Create unique temporary directory with restrictive permissions
    temp_home=$(mktemp -d "${base_dir}/gnupg.XXXXXXXXXX") || {
        log "Error: Failed to create temporary GNUPGHOME"
        return 1
    }

    chmod 700 "$temp_home" || {
        log "Error: Failed to set permissions on GNUPGHOME"
        rm -rf "$temp_home"
        return 1
    }

    # Store for cleanup
    _GPG_EPHEMERAL_HOME="$temp_home"

    # Export GNUPGHOME
    export GNUPGHOME="$temp_home"

    # Set up cleanup trap (additive, won't replace existing traps)
    trap 'gpg-home-temp-cleanup' EXIT

    log "Create ephemeral GNUPGHOME: $temp_home"
    echo "$temp_home"
    return 0
}

gpg-home-temp-cleanup() {
    # Securely clean up ephemeral GNUPGHOME
    #
    # This function securely removes the ephemeral GPG home directory.
    # On Linux with secure-delete available, uses srm for secure removal.
    #
    # Returns:
    #   0 on success or if nothing to clean
    #   1 on failure

    if [[ -z "$_GPG_EPHEMERAL_HOME" ]] || [[ ! -d "$_GPG_EPHEMERAL_HOME" ]]; then
        return 0
    fi

    # Kill any gpg-agent using this home
    if [[ -n "${GNUPGHOME:-}" ]] && [[ "$GNUPGHOME" == "$_GPG_EPHEMERAL_HOME" ]]; then
        gpgconf --homedir "$_GPG_EPHEMERAL_HOME" --kill gpg-agent 2>/dev/null || true
    fi

    # Secure removal if available, otherwise regular rm
    if command -v srm &>/dev/null; then
        log "Securely removing ephemeral GNUPGHOME"
        srm -rf "$_GPG_EPHEMERAL_HOME" 2>/dev/null || rm -rf "$_GPG_EPHEMERAL_HOME"
    else
        log "Removing ephemeral GNUPGHOME"
        rm -rf "$_GPG_EPHEMERAL_HOME"
    fi

    _GPG_EPHEMERAL_HOME=""
    unset GNUPGHOME

    return 0
}

gpg-agent-restart() {
    # Restart gpg-agent with proper configuration
    #
    # Arguments:
    #   $1 - GNUPGHOME to use (optional, uses current GNUPGHOME or default)
    #
    # Returns:
    #   0 on success
    #   1 on failure

    local gpg_home="${1:-${GNUPGHOME:-$HOME/.gnupg}}"

    log "Restarting gpg-agent"

    # Kill existing agent
    gpgconf --homedir "$gpg_home" --kill gpg-agent 2>/dev/null || true

    # Brief pause for socket cleanup
    sleep 0.5

    # Restart agent
    if ! gpg-connect-agent --homedir "$gpg_home" /bye &>/dev/null; then
        # Try alternative method
        gpg --homedir "$gpg_home" --list-keys &>/dev/null || {
            log "Error: Failed to restart gpg-agent"
            return 1
        }
    fi

    log "Success: gpg-agent restarted"
    return 0
}

gpg-agent-ensure() {
    # Ensure gpg-agent is running with proper configuration
    #
    # Arguments:
    #   $1 - GNUPGHOME to use (optional, uses current GNUPGHOME or default)
    #
    # Returns:
    #   0 on success
    #   1 on failure

    local gpg_home="${1:-${GNUPGHOME:-$HOME/.gnupg}}"

    # Check if agent is responding
    if gpg-connect-agent --homedir "$gpg_home" /bye &>/dev/null; then
        return 0
    fi

    # Agent not running, start it
    gpg-agent-restart "$gpg_home"
}

# =============================================================================
# Key Listing Functions
# =============================================================================

gpg-card-status-display() {
    # Parse and display GPG card status in a clean format
    #
    # Arguments:
    #   $1 - Card status output from 'gpg --card-status'
    #
    # Output:
    #   Formatted display of card information and keys

    local card_status="$1"
    local reader serial_number card_holder
    local sig_key enc_key auth_key
    local general_key_info

    # Extract card info
    reader=$(echo "$card_status" | grep "^Reader" | sed 's/Reader[^:]*: *//')
    serial_number=$(echo "$card_status" | grep "^Serial number" | awk '{print $NF}')
    card_holder=$(echo "$card_status" | grep "^Name of cardholder" | sed 's/Name of cardholder: *//')

    # Extract key information
    sig_key=$(echo "$card_status" | grep "^Signature key" | sed 's/Signature key[^:]*: *//')
    enc_key=$(echo "$card_status" | grep "^Encryption key" | sed 's/Encryption key[^:]*: *//')
    auth_key=$(echo "$card_status" | grep "^Authentication key" | sed 's/Authentication key[^:]*: *//')

    # Check for general key info (indicates keys are properly linked)
    general_key_info=$(echo "$card_status" | grep "^General key info")

    # Display card information
    if [[ -n "$reader" ]]; then
        echo "  Reader:        $reader"
    fi
    if [[ -n "$serial_number" ]]; then
        echo "  Serial:        $serial_number"
    fi
    if [[ -n "$card_holder" && "$card_holder" != " " ]]; then
        echo "  Cardholder:    $card_holder"
    fi

    echo

    # Display keys with their status
    if [[ -n "$sig_key" && "$sig_key" != "[none]" ]]; then
        echo "  [S] Signature:     ${sig_key:0:16}..."
    else
        echo "  [S] Signature:     (not set)"
    fi

    if [[ -n "$enc_key" && "$enc_key" != "[none]" ]]; then
        echo "  [E] Encryption:    ${enc_key:0:16}..."
    else
        echo "  [E] Encryption:    (not set)"
    fi

    if [[ -n "$auth_key" && "$auth_key" != "[none]" ]]; then
        echo "  [A] Authentication: ${auth_key:0:16}..."
    else
        echo "  [A] Authentication: (not set)"
    fi

    # Show key status hint
    if [[ -z "$general_key_info" ]] && [[ "$sig_key" != "[none]" || "$enc_key" != "[none]" || "$auth_key" != "[none]" ]]; then
        echo
        echo "  Note: Keys present but not linked to local keyring."
        echo "  Run 'gpg --card-status' to fetch public keys."
    fi
}

gpg-master-keys-list() {
    # List available master keys from registered backup locations
    #
    # Searches for GPG key backups in registered locations and displays
    # information about available master keys.
    #
    # Returns:
    #   0 if keys found
    #   1 if no backup locations configured or no keys found

    # Load config to get backup locations
    gpg-config-load

    local backup_dir
    backup_dir=$(gpg-config-get GPG_BACKUP_DIR "")

    if [[ -z "$backup_dir" ]]; then
        echo "  No backup location configured."
        echo "  Set GPG_BACKUP_DIR in config or use 'keycutter gpg backup' to create backups."
        return 1
    fi

    # Expand path
    backup_dir="${backup_dir/#\~/$HOME}"

    if [[ ! -d "$backup_dir" ]]; then
        echo "  Backup directory not found: $backup_dir"
        return 1
    fi

    # Search for key files
    local found_keys=0
    local key_file keyid uid

    # Look for common backup patterns: *.asc, *.gpg, private-key*.asc
    for key_file in "$backup_dir"/*.asc "$backup_dir"/*.gpg "$backup_dir"/*/secret-key*.asc "$backup_dir"/*/master*.asc; do
        if [[ -f "$key_file" ]]; then
            # Extract key info using gpg --show-keys
            keyid=$(gpg --show-keys --with-colons "$key_file" 2>/dev/null | awk -F: '/^sec:/ {print $5; exit}')
            uid=$(gpg --show-keys --with-colons "$key_file" 2>/dev/null | awk -F: '/^uid:/ {print $10; exit}')

            if [[ -n "$keyid" ]]; then
                found_keys=$((found_keys + 1))
                echo "  $keyid"
                if [[ -n "$uid" ]]; then
                    echo "    └─ $uid"
                fi
                echo "    └─ $(basename "$key_file")"
                echo
            fi
        fi
    done

    if [[ $found_keys -eq 0 ]]; then
        echo "  No master keys found in: $backup_dir"
        return 1
    fi

    echo "  Found $found_keys master key(s)"
    return 0
}
